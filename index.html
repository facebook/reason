<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Reason</title>

  <!-- Flatdoc -->
  <script src='support/vendor/jquery.js'></script>
  <script src='legacy.js'></script>
  <script src="highlightJs/build/highlight.pack.js"></script>
  <link  href='highlightJs/src/styles/xcode.css' rel='stylesheet'>
  <script src='flatdoc.js'></script>


  <!-- Flatdoc theme -->
  <link  href='theme-white/style.css' rel='stylesheet'>
  <script src='theme-white/script.js'></script>
  <link  href='support/theme.css' rel='stylesheet'>
  <script src='support/theme.js'></script>


  <script id="markdown" type="text/markdown" src="index.html">

Reason
=======

- **Learn rapidly:** Familiar, functional syntax.
- **Edit rapidly:** Powerful, always-consistent source formatting.
- **Execute rapidly:** Ahead of Time, bare metal compilation - No Virtual Machine.
- **Adopt incrementally:** One file at a time, link with `clang` or `JavaScript`.
- **Build and Share easily:** `package.json` driven compilation/sharing.


Install
---------------
Install `OPAM` so that you can easily switch compiler versions (using
[Homebrew](http://brew.sh/)). Then switch to a supported compiler version
(`4.02.1` or `4.02.3` will work). Finally have `OPAM` install `Reason` from
Github by "pinning" it.

```sh
brew install opam --HEAD
opam init
# Add this to your ~/.bashrc (or ~/.zshrc):
#   eval `opam config env`

opam switch 4.02.3
opam pin add -y reason git@github.com:facebook/Reason.git#bdd6f3990570d20a7f70e7667223d4a68f4e4915
opam pin add -y merlin git@github.com:the-lambda-church/merlin.git#8211529bf77936e3c20d3689243c22744936f02f
opam pin add -y merlin_extend git@github.com:def-lkb/merlin-extend.git#f2cd1f260c2bcfad033faaf02146935bdf9e5883
```

REPL
---------------

`Reason` comes with a custom build of the REPL called `rtop` which lets you
interactively evaluate `Reason` syntax in the REPL. It will show printed results
for each command. To submit commands, end each entry with a `;` and the REPL
will print the resulting value and inferred type.

```sh
# The rtop command begins a REPL session
rtop
```

```sh
let myVar = "Hello Reason!";
# myVar: bytes = "Hello Reason!"

let result = 100 + 200;
# result : int = 300;
```

> Note: `rtop` is a merely a thin wrapper around the excellent `utop` REPL but
> with a custom extension to handle `Reason` syntax. Correct value printing is
> still under development.


Reason Atom IDE.
-------

#### Install
`Reason` works best in Atom when the `Nuclide` plugin is installed. There is _one_ plugin called `atom-reason-loader` that must be installed using the instructions here.
`atom-reason-loader` has one job - to dynamically install any other necessary `Reason` plugins. Your
OPAM installation of `Reason` provides the _real_ IDE plugins, that `atom-reason-loader` will install.
Those other plugins include `NuclideReason` (IDE features), and `language-reason` (syntax highlighting).

> **Installation Instructions**
>
> - Install [Atom](https://atom.io/) editor.
> - Open the package installer from the menu `Packages > Settings View > Install Packages/Themes`.
> - Search for and install `nuclide` if not already installed.
> - Then install `atom-reason-loader`.
> - `atom-reason-loader` will automatically install/load two plugins (`NuclideReason` and
> `language-reason`) and will walk you through removing any existing conflicting versions.
> - When installation is complete, open a `.re` file and make sure the `Reason` syntax is selected
> (lower right corner of Atom). Restarting Atom after installation is not a bad idea but should not be necessary.

#### Features/Configuration
The `Reason` IDE experience is powered by `reasonfmt`, the `Reason` AST formatting tool, and
even moreso by the excellent [merlin](https://github.com/the-lambda-church/merlin) project.
`reasonfmt` provides source code beautifying/printing, and Merlin provides type information, autocompletion,
and professional IDE features even in the face of partially invalid files/projects.

To configure Merlin, include a `.merlin` file at the root of your project that notes the location
of source files and build artifacts. Also register the `Reason` suffixes with Merlin using the `SUFFIX` config.
See [this doc](https://github.com/the-lambda-church/merlin/wiki/project-configuration) for more
details, and note the example here.


> Example `.merlin` file
```
S relative/path/to/your/sourcefiles/dir/
B relative/path/to/your/build/artifacts/dir/
SUFFIX .re .rei
```

<img width=470 height=440 src="images/NuclideReason.png" />

> **Type Driven Development**
>
> - (Coming soon) With [`hyperclick`](https://atom.io/packages/hyperclick) installed/enabled -
`⌘+click` will allow navigating to definition location.
> - When you save your file, you will see compilation errors/warnings highlighted.
> Open the "Diagnostics" window to see a summary of errors.
> - With `Nuclide` type-hints enabled, hovering over your source code will display
> a pretty printed type annotation for the term.


<img width=470 height=440 src="images/autoformat.png" />

> **Powerful Reformatting**
>
> - `Reason` for Atom integrates `reasonfmt`, the `Reason` AST formatter.
> - With Nuclide, `⌘+shift+c` will reformat the entire file or let you know
> if a syntax error prevented formatting.
> - As always, `reasonfmt` will remove superfluous parenthesis, or precedence tokens.
> - `reasonfmt` will wrap your lines at the width you have configured in your
> plugin settings. To change these, open the Package Settings (`Packages > Settings View > Manage Packages)
> and click on `NuclideReason` in order to customize the "print width" configuration.


<img width=470 height=440 src="images/autocomplete.png" />
> `Reason` for Atom uses Merlin's powerful autocompletion system.

Syntax Basics
=======

Much of Reason's core syntax should be familiar to anyone that has ever
used `JavaScript` or `Rust`.

> While no substitute for the guide below, these references are helpful to
> quickly compare syntaxes with other syntaxes.

> [JavaScript >](./javaScriptCompared.html) [ML >](./mlCompared.html)


######Primitives

Primitive                                  | Example
--------------------------------------|--------------------------------
Strings                               |  <pre>"Hello"</pre>
Characters                            |  <pre>'x'</pre>
Integers                              |  <pre>23</pre>
Floats                                |  <pre>23.0</pre>
Negative Integer                      |  <pre>-23</pre>
Integer Addition                      |  <pre>23 + 1</pre>
Float Addition                        |  <pre>23.0 +. 1.0</pre>
Integer Division/Multiplication       |  <pre>2 / 23 * 1</pre>
Float Division/Multiplication         |  <pre>2.0 /. 23.0 \*. 1.0</pre>
String Concatenation                  |  <pre>"Hello" ^ "World"</pre>
Immutable Lists                       |  <pre>[1, 2, 3]</pre>
Immutable Lists append                |  <pre>[hd, hd2, ...tl]</pre>
Reference Equality Comparison         |  <pre>thisThing === thatThing</pre>
Records                               |  <pre>{contents: 100}</pre>
Record Field Update (if mutable field)|  <pre>myRecord.contents = 200</pre>



Bindings and Functions
------------

#### Let Bindings in Source Files

Reason source files begin with a lowercase letter and use the `.re` file
suffix. Each `.re` file includes a series of `let` bindings and/or `type`
definitions, separated by semicolons. For example, you might have the file
`react.re` and has two `let` bindings as shown. The
[REPL](#reason-repl)
can be used to input bindings line by line and receive feedback interactively.

```reason
/*
 * Contents of react.re
 */
let frameworkName = "React";
let renderCount = 0;
```

`let` binds names to values that may be accessed within "block scope". To
further limit scope of bindings, `Reason` provides `{}` block *expressions*
which sequence `let`s together and *evaluates* to the last item in the
sequence. In this example, the binding `three` evaluates to the `integer` `3`.
The `{}` block ensures that `one` and `two` are not accessible after `three` is
computed.

```reason
let three = {
  let one = 1;
  let two = 2;
  one + two
};
/* one and two not accessible here! */
```

#### Functions

Functions are first class values and can be assigned to a let binding. Functions
are introduced with the `fun` keyword, followed by a list of arguments, an
arrow `=>` then any expression acting as the return value.

```reason
let increment = fun x => x + 1;
let sumBoth = fun x y => x + y;
```

Functions "application" is expressed by simply supplying the arguments
separated by spaces, after the name of the function.

```reason
increment 5;    /* Evaluates to six */
sumBoth 6 1;   /* Evaluates to seven */
```

##### 

To resolve precedence when applying arguments, simply wrap in parenthesis.  In
this example, `(increment 2)` is *first* evaluated to `3`, then `3` is passed
as the second argument to `sumBoth`.

```reason
sumBoth 2 (increment 2);   /* 5 */
```

This syntactic pattern of space-separated lists is used in many places in
`Reason`.

#### 

Functions can use sequence expressions as their return values in order to
declare temporary variables while computing their result. This isn't some special
kind of function body on the right side of the `=>`, it's just a standard
sequence expression, and the function is doing what functions always do -
evaluating to the expression on the right side of the `=>`.

```reason
let longerFunc = fun argOne argTwo => {
  let tmp = 2 * argOne;
  let next = 3 * argTwo;
  tmp * next
};
```

As with any sequence or module scope, you may invoke other functions that
perform side effects such as printing, logging, or warming a cache.
```reason
let longerFunc = fun argOne argTwo => {
  print_string "Entering the function";
  let tmp = 2 * argOne;
  let next = 3 * argTwo;
  print_string "Returning from the function";
  tmp * next
};
```

Types Basics
--------------------------

#### Type Annotations

Even though types are inferred, you may still choose to write "type assertions"
on any expression. These assertions are then verified by the compiler. Just
append `: yourType` to an expression, and wrap the result in parenthesis.
```reason
let bindingOne = 5;
let bindingOne = (5 :int);
let bindingOne = (5 :int) + (4 :int);
let bindingOne = ((5 :int) + (4 :int) :int);
```
The other place that type assertions are accepted, is immediately following the
`let` keyword. This is equivalent to asserting the type of the expression on
the right hand side of the `=`.

```reason
/* Equivalent type assertions. */
let frameworkName = ("React": string);
let frameworkName: string = "React";
```

#### Type Aliases

You may refer to a type by a different name, by creating a type alias with the
`type` keyword. The new type alias may be used in annotations as well. You can
see there is somewhat of a "scope" for `type` aliases, similar to `let`
bindings, but type aliases must be placed directly in a module file, and not
inside of a sequence expression.

```reason
type myType = int;
let x: myType = 10;  /* Now we can "see" myType */
```

#### Function Types
To describe the types of functions, we list the types of the arguments,
separated by `=>`, and then list the return type after one final `=>`.

For example:
```reason
type addsTwoInts = int => int => int;
let myFun: addsTwoInts = fun a b => a + b;
```

Tuples
--------------------------

A tuple is a list of values of *known* size, such as "pair". They differ from
lists not only in that they are of known size, but in that every item in a
tuple may be of a different type. They are written as comma delimited lists,
always wrapped in parenthesis.


```reason
let myPairOfInts = (20, 40);
let myThreeFloats = (20.0, 30.0, 100.0);
let myIntAndString = (20, "totallyNotAnInteger");
```

Tuples have types and those types can be used in type annotations as well.
Tuple types resemble tuples themselves - comma delimited lists of types,
wrapped in parenthesis.

```reason
let myPairOfInts: (int, int) = (20, 40);
let myThreeFloats: (float, float, float)  = (20.0, 30.0, 100.0);
let myIntAndString: (int, string) = (20, "totallyNotAnInteger");
```

You may create type aliases for tuple types just like you can with any other
type.
```reason
type pairOfInts = (int, int);
type threeFloats = (float, float, float);
type intAndString = (int, string);

let myPairOfInts: pairOfInts = (20, 40);
let myThreeFloats: threeFloats = (20.0, 30.0, 100.0);
let myIntAndString: intAndString = (20, "totallyNotAnInteger");
```

Records
-------

Records are an unordered collection of named fields. Records are similar to
"objects" that you might be familiar with, but they are much simpler, less
flexible, and compile to very efficient machine code. To create a record, some
type definition describing its fields must be in scope.  In `Reason`,  type
definitions for records resemble the shape of the records values they describe.

```reason
type person = {age: int, name: string};
let me = {age: 30, name: "Jordan"};
print_string me.name;
```

New records may be easily created from old records with the `...` spread
operator, which changes a subset of the fields, but doesn't alter the original
record.

```reason
let meNextYear =  {
  ...me,
  age: me.age + 1
};
```

##### Mutable record fields.

If you must, record fields may be mutated with the `=` operator, but only if
the record type has marked a field `mutable`. In general, having language level
distinction between `mutable` and immutable, allows the compiler to make
several optimizations, including avoiding allocations.

```reason
type person = {
  name: string,
  mutable age: int
};
let me = {name: "Jordan", age: 30};
me.age = me.age + 1;
```

Destructuring
-------------
"Destructuring" can be used to extract one or more fields from a record or
tuple, while automatically binding them to local variables. Any place variables
are introduced into scope, you may use destructuring. To destructure, instead
of writing the variable name as usual, write out the deep shape of the object.


> The following binds variables:
> `ten = 10`, `twenty = 20`

```reason
let someInts = (10, 20);
let (ten, twenty) = someInts;
```

> The following binds variables:
> `n = "Guy"`, `a = 30`

```reason
let somePerson = {name: "Guy", age: 30};
let {name: n, age: a} = somePerson;
```
Function arguments may also be destructured. This function takes one tuple
argument and destructures that tuple's fields "on the way into" the function.
Notice how this resembles `C`/`JavaScript` style argument syntax.

```reason

let addTupleFields = fun (first, second) => {
  first + second
};
let five = addTupleFields (4, 1);
```

Named arguments can be simulated via one destructured record argument. As
always, record type definitions must be in scope when records are used.

```reason
let isOverThirty = fun {name: n, age: a} => {
  let ret = a > 30;
  ret
};
let overThirty = isOverThirty {name: "Jay", age: 31};
```

Destructuring also allows type annotations *while* destructuring.
```reason
let (ten: int, twenty: int) = someInts;
let {name: (n:string), age: (a:int)} = somePerson;

let addTupleFields = fun (first:int, second:int) => {
  first + second
};
let isOverThirty = fun {name: (n:int), age: (a:int)} => {
  let ret = a > 30;
  ret
};
```

Variants
--------

Variant types allows data to have either one form *or* another. In Reason, each
form is given a capitalized name called a "constructor" (not in the OO sense).
To declare a variant type, enumerate every constructor by the `|` token.

```reason
type response =
  | Yes
  | No
  | PrettyMuch;
let areYouCrushingIt = Yes;
```

`switch` expressions are like large `if/elseif/elseif..` expressions but much
more powerful because they ensure that all cases are covered. To use `switch`,
enumerate every variant constructor in "table" form followed by an `=>` and
finally the value to be returned by the `switch` for that case. In this
example, the `message` variable is assigned the string `"..."`.


> Note: Compilation will raise a type error if you've forgotten to have your
> `switch` cover a case, or if two cases are redundant.

```reason
let isSafeToLaunchRocket = PrettyMuch;
let message = switch isSafeToLaunchRocket {
    | No => "Check Integrity."
    | Yes => "All Systems Go."
    | PrettyMuch => "..."
  };
```
##### Constructor Arguments

Constructors may contain one or more pieces of data by declaring those
contained types in a space-separated list after an `of` keyword.
```reason
type account =
  | None
  | Facebook of string int
  | Instagram of string;

```

> Instantiating a constructor that carries data is exactly the same as
calling a function. Supply the data as space separated "arguments".

```reason
let myAccount = Facebook "Kay" 1234;  /* Accepts two arguments */
let yourAccount = None;               /* Accepts no arguments */
```

##### Destructuring Arguments of a Constructor

Once created, constructor data can be extracted via destructuring, much like
with tuples. In this example, a local variable `x` is bound to `42`.
`getTheInt` extracts a `Leaf`'s contained integer "on the way into" the function.

```reason
type intLeaf = | Leaf of int;
let myIntLeaf = Leaf 42;

let Leaf x = myIntLeaf;
let getTheInt = fun (Leaf q) => q;
let fourtyTwo = getTheInt myIntLeaf;
let twentyNine = getTheInt (Leaf 29);
```

** When Simple Destructuring Isn't Enough: **
Simple destructuring isn't sufficient for variants types with many
constructors. The following example would clearly have to fail at runtime!
Fortunately, the compiler forbids this.

```reason
type possibleNum =
  | NotDefined
  | Defined of integer;

let myNumber = NotDefined;
let Defined x = myNumber;   /* Type error! */
```
** The Solution: ** To recover data in variants with many constructors,
`switch` allows us to enumerate each constructor *while* destructuring the
constructor's data on the left side of the `=>`.  Unlike our previous naive
attempt, this works because we enumerate every possible constructor name inside
of the `switch`.

> Note: We've safely unpacked the `i` from `Defined i`, because we've *also*
> specified what to do when `myNumber` was `NotDefined`.

```reason
let x = switch myNumber {
  | Defined i => i
  | NotDefined => 0
};
```
##### Multiple Arguments vs. Tuples (*Details*)

Notice that a variant constructor that contains many fields is different than a
variant constructor that carries a single field that happens to be a tuple.
Among other differences, tuples are not "inlined" into the variant object's
runtime representation, whereas, multiple constructor arguments incur no
additional abstraction cost (they are "inlined" into the variant data).

```reason
type toTupleOrNotToTuple =
   | HasTuple of (int, int, int)
   | NoTuple of int int int;

let aTuple = HasTuple (1, 2, 3);
let notTuple = NoTuple 1 2 3;

let sumsZero = switch x {
  | HasTuple (a, b, c) => a + b + b == 0
  | NoTuple a b c => a + b + b == 0
};

```

Expressive Pattern Matching
---------------------------
There are several destructuring conveniences that pair well with compiler
verified `switch` expressions.
For example, you can express arbitrarily nested destructuring "patterns", which
the compiler will ensure have no uncovered cases. In this example, `name` is
bound to `"Jo"` and `model` is bound to `"Tacoma"`.

```reason
type car = {model: string, make: string};
let toyota = {make: "Toyota", model: "Tacoma"};

type carOwner =
  | CarOwner of string car; /* May as well be a tuple */

let CarOwner name {model: model, make: make} = CarOwner "Jo" toyota;
```

##### 
This deep pattern matching is especially expressive when used in `switch`
expressions. In this example, the function `hasExactlyTwoCars` has specified
what to return in four cases in very little code. Even more helpful, is the
fact that the compiler verifies that no two edge cases are redundant, and that
every possible case has been covered. It turns out, that pattern matching
becomes an extremely powerful tool to enforce constraints in your program. The
more you model your program in terms of variants, the more the compiler assists
you stop bugs before they even run - the end result being more rapid
development. This `ML` pattern matching is famous for coining the phrase: "If
it compiles, it works!".

```reason
type carList =
  | List of car carList
  | NoMore;

let chevy = {make: "Chevy", model: "Suburban"};
let toyota = {make: "Toyota", model: "Tacoma"};
let myCarList = List chevy (List toyota NoMore);

let hasExactlyTwoCars = fun lst =>
  switch lst {
    | NoMore => false                         /* 0 */
    | List p NoMore => false                  /* 1 */
    | List p (List p2 NoMore) => true         /* 2 */
    | List p (List p2 (List p3 rest)) => false  /* 3+ */
  };

let justTwo = hasExactlyTwoCars myCarList;  /* true! */

```

Advanced Features
=======

The section below demonstrates the syntax for advanced language constructs such
as modules, which enable rapid large-scale development.

Modules
----------------------------------
*Note: This documentation on modules is a temporary, and will be improved*

Modules are like records, but with the following differences.

- They are "compile-time" concepts, not easy to pass to standard functions.
- They may contain types, instead of just values.
- Their values are specified using `let` bindings.
- Variables that refer to modules must begin with a capital letter.
- They form the basis for separate compilation and namespacing.


###### Creating Modules
To create a module, use the `let module` keywords instead of `let`, and ensure
that the variable name given to the module begins with a capital letter.

```reason
let module MyModule = {
  /* Module contents here */
};
```
The contents of modules are placed between the `{}` blocks. In fact, you
already know how to define module contents - the rules for module contents are
the exact same as the rules for the contents of `.re` files. Whatever you could
place in a `.re` file, you may place inside a module definition's `{}` block.
That means that you can include `let` bindings, and even `type` definitions.

```reason
let module MyModule = {
  type twoStrings = (string, string);
  let makePair = fun s => {
    let returnVal = (s, s): twoString;
    returnVal;
  };
};
```

Once a module has been defined, the contents of the module may be accessed much
like a record using the `.` notation. Furthermore, even a module's declared
*types* may be accessed using that same `.` notation. This demonstrates
modules' utility for namespacing.

```reason
let twoStrings: MyModule.twoString = MyModule.makePair "hello modules";
```

```reason
let module MyModule = {
  let module NestedModule = {
     let msg = "hello";
  };
};

let msg = MyModule.NestedModule.msg;
```

###### Extending modules
Contents of modules may be *copied* into other modules by using the `include`
keyword. Once `include`d, following `let` bindings can "see" the `include`d
content. This can often fulfill the role of "inheritance".


```reason
let module Login = {
   let login = fun auth => 0;
};
let module RepeatedLogin = {
  include Login;
  let loginTwice = fun auth => {
    (login auth, login auth)
  };
};
```


###### Every `.re` file is a module
Furthermore, ever file *is* a module. The file `react.re` implicitly forms a
module `React`, which can be seen by other source files. The [build
system](#scalable-development-modules-and-package-visibility) determines which
particular files can see `React`.



Signatures
----------------------------------
Similar to how records are described by types, modules themselves can be
described by *module* types, which we call "signatures". Signatures are similar
to record type definitions, with the following differences:

- They describe the structure of *modules* (which are compile-time constructs)
  instead of describing *values* (which are runtime constructs).
- They describe values being inside of modules via the following syntax: `let q: s;` (as opposed to
  `key:keyType,`).
- Signatures can include entries for `type` fields - which is admitedly
  difficult to wrap your head around.
- Identifiers that refer to signatures must begin with a capital letter.
- The rules for satisfying signatures are based on "subtyping", whereas records
  are more rigid.

###### Creating Signatures
Module signatures are declared using the `module type` keywords.  Module
signatures define the list of requirements that a module must satisfy in order
for that module to "match". Those requirements are of the form:

- `let x: typeOfName;` to require that a module have a `let` binding named `x`.
- `type t = someType;` to require that a module have a type field `t` being
  equal to `someType`.
- `type t;` to require that a module have a type field `t`, but without
  imposing any requirements on the actual type of `t`. We can still use this `t`
  in other entries in the signature, which will require enforce certain
  relationships between `t` and other types/fields *within* the signature, but
  we cannot, for example, assume that `t` is an `int`.

To illustrate the various kinds of type entries, consider the signature
`HasXAndTInt` which requires that a module:

- Declare a type definition under the name `t` being equivalent to `int`.
- Must include a `let` binding named `x` assigned to an `int`.

```reason
module type HasXAndTInt = {
   type t = int;
   let x: int;
};
```

Constrast that with the signature `HasXAndTAbstract` which requires that a
module:

- Declare a type definition under the name `t`.
- Have a `let` binding `x` that is of that *same* type `t`, regardless of what `t` happens to be.

```reason
module type HasXAndTAbstract = {
   type t;
   let x: t;
};
```

###### Asserting
Similar to what we saw with type assertions, we can assert that various
*modules* implement various *signatures*, via the type assertion operator `:`.

In this example, the first type assertion asserts that `XTInt` implements
`HasXAndTInt` and it succeeds because `XTint` has all of the members of
`HasXAndTInt` and the types of those members match exactly.  The second
assertion asserts that `XTInt` implements `HasXAndTAbstract` and succeeds
because `XTInt.x` is in fact of type `XTint.t`. `XTint.t` also happens to be an
`int`, but `HasXAndTAbstract` never specified what `t` could or could not be -
it only required that `x` be of type `t`.

```reason
let module XTInt: HasXAndTInt = {
   type t = int;
   let x = 20;
};
let module XTInt: HasXAndTAbstract = {
   type t = int;
   let x = 20;
};
```
###### Constraining
What it means to "implement" a signature is fairly intuitive, and roughly
corresponds to the popular notion of "implementing an interface". For example,
modules may implement a signature while having *more* fields (but no fewer)
than the signature required.

Because of this, signature assertions do more than just *verify* that a module
implements, a signature - they also *constrain* a module to the signature. In
this example, `XYAndT.y` is visible, but `Constrained.y` is not.  Furthermore,
`XYAndT.t` is of type `int`, whereas `Constrained.t` now matches the signature
in that it is now "abstract". If you were to ask the `REPL` what the type of
`Constrained.t` is, it will tell you `Constrained.t`! If you asked it what the
type of `Constrained.x` was, it would again tell you `Constrained.t`. It has
lost track of the type itself, but not lost track of the fact that the type of
`Constrained.x` is identical to the type of `Constrained.t`.

```reason
let module XYAndT = {
   type t = int;
   let x = 20;
   let y = "you'll never see me!";
};
let module Constrained: HasXAndTAbstract = XYAndT;
```
> This kind of "constraining" allows *hiding* of information that should be
> considered implementation details.


###### Every `.rei` file is a signature
Similar to how every `react.re` file implicitly defines a module `React`, every
file `react.rei` implicitly defines a signature that is automatically asserts
and constrains `React`. The optional `react.rei` file would include the
contents of a module signature (stuff in between the `{}`). `.rei` files also
serve as a place to document the public API for their corresponding modules.

> Example contents of react.re

```reason
type descriptor = int;
let render = fun str => str;
```

> Example contents of react.rei

```reason
type descriptor = int;
let render: str => str;
```

- Module signatures may also help ensure that [incremental
  compilation](#scalable-development-incremental-compilation)
  remains fast.
- Signatures have many powerful features for constraining relationships between
  modules in very nuanced ways. Those are out of the scope of this document.

Module Functions
----------------------------------
Modules act as compile-time records, and signatures act as the types of those
compile-time records, but the most power comes from being able to pass modules
through functions. But since modules are compile-time constructs, we can't use
*regular* runtime functions - we need functions that can operate on *modules*.
We call these special functions "functors", and designate them by using the keyword
`functor` instead of `fun` at definition time.

> The combination of modules, signatures and module functions are incredibly
powerful, especially when combined with module `include`ing. Together they
provide power that feels much like a type based macro systems, allowing the
creation of sophisticated type hierarchies, generators, and factories. Covering
all of these use cases are out of the scope of this document.

The syntax for defining and using module functions is very much like the syntax for
defining and using regular functions. The primary differences are:


- Module functions use the `let module` keywords instead of `let` and the `functor`
  keyword instead of `fun`.
- Module functions accept modules as arguments and return a module.
- Module functions *require* annotating arguments.
- Module functions must start with a capital letter (just like modules/signatures).

```reason
module type HasT = {
  type t;
};
let module Pairify = functor (X: HasT) => {
   type p = (X.t, X.t);
   let create = fun (x: X.t) => (x, x);
};
```
Module functions can be "applied" using function application syntax, by passing modules
as their space-separated arguments.
In this case, a module *literal* is passed as the module functions argument, but we
could have passed the name of a module instead.

```reason
let module IntPair = Pairify {
  type t = int;
};

let ints = IntPair.create 200;
```

Module functions, among other things can for powerful module type (*and* value)
factories. Module functions can even accept other Module functions as arguments!


###### Module functions types

Module functions may have type assertions applied with `:` as we've seen with values
and modules. Like with module types, module function types also act to *constrain* what
we may assume about module functions, beyond what is true about them (you may hide
things about the module function).
The syntax for module function types are consistent with those for function types, but
with types capitalized to represent the signatures of modules the module function
accepts as arguments and return values.


> Previous example with module function type assertions.

```reason
module type HasT = {
  type t;
};
module type ParifyT = (HasTInstance: HasT) => {
  type p;
  let create: HasTInstance.t => p;
};

let module Pairify: ParifyT = functor (X:HasT) => {
  type p = (X.t, X.t);
  let create = fun (x: X.t) => (x, x);
};
```


Syntax Sugars
----------------------------------


##### Function sugar
You've already seen one form of function syntax sugar. Though it appears that
functions accept multiple arguments, every function actually only accepts a
single argument. "Multiple arguments" separated by spaces are actually defining
a series of curried functions. These two function definitions are equivalent.

```reason
let add = fun a b => a + b;
let add = fun a => fun b => a + b;
```

You've also seen a sugar for applying arguments to curried functions. Space
separated function application such as `x y z` is sugar that first invokes `x`
with single argument `y` which returns a separate function, which is then
invoked with the single argument `z`. For example, the following two are
*always* equivalent.

```reason
let five = add 4 1;
let five = ((add 4) 1);
```
> Note: You pay no additional performance cost for curried functions
when they are invoked with all arguments. You may even ignore the fact that
currying is occurring at all, if you like.

##### Function let binding sugar
There's one more function binding syntax that hasn't yet been shown: When
assigning a `let` binding to a function, the `= fun` portion may be omitted.
This means writing functions in the form: `let functionName arg1 arg2 =>
expression`.

```reason
/**
 * All of the following are equivalent:
 */
let add a b => a + b;
let add = fun a b => a + b;
let add = fun a => fun b => a + b;
```

##### Module function Binding Sugar

[Module Functions](#syntax-basics-module-functions) follow the same sugar convention as regular
functions. Space-separated arguments are actually currified *module functions*
and the `= functor` may be omitted, resulting in three forms of module function
definitions which are all equivalent.

```reason
let module ModuleFunc (A:ASig) (B:BSig) => {};
let module ModuleFunc = functor (A:ASig) (B:BSig) => {};
let module ModuleFunc = functor (A:ASig) => functor (B:BSig) => {};
```

##### Record value "punning"

If variables names in scope perfectly correspond to record property names, then
records can be written in a shorter form.

```reason
type myRecord = {first: int, second: int};
let first = "f";
let second = "s";

/* These following are equivalent. */
let theRecord = {first:first, second:second};
let theRecord = {first, second};

/* Or only take the shortcut for a subset of the fields */
let theRecord = {first, second: 0};

```

##### Record *pattern* punning

The same record "punning" syntax may be used with destructuring, in all of the
places where destructuring is allowed (`let` bindings, function arguments,
`switch` matching).

```reason
let {first:first, second:second} = theRecord;
let {first, second} = theRecord;   /* Shortcut */

let sumsToZero = fun {first, second} => first + second == 0;
```

Scalable Development
=====================================

Example Project
------------------------

#### Clone the Sample Project

Clone the example `Reason` project and use `npm` to install its dependencies.
`Reason` uses [`CommonML`](http://github.com/jordwalke/CommonML) for
`package.json` style sharing and building of native modules. Several
compilation modes are supported such as bytecode, full-metal binary, and even
debuggable `JavaScript`.

```sh
git clone git+ssh://git@github.com/jordwalke/ReasonExampleProject.git
cd ReasonExampleProject
npm install
```

###### Build Interpreted Mode

The default compilation mode compiles very quickly, and is ideal for rapid
development.

```sh
node ./node_modules/CommonML/build.js     # Build
_build_byte/ReasonExampleProject/reasonExampleProject.out  # Run
```


###### Build for Native

Passing `--compiler=native` will generate fast bare metal binaries.


```sh
node ./node_modules/CommonML/build.js --compiler=native
_build_native/ReasonExampleProject/reasonExampleProject.out
```

###### Compile to `JavaScript`

Passing `--forDebug=true --jSCompile=true` will compile debuggable `JavaScript`
builds of your native application, with source maps support.

```sh
node ./node_modules/CommonML/build.js --forDebug=true --jsCompile=true
node _build_byte/ReasonExampleProject/reasonExampleProject.out
```

Modules and Package Visibility
--------------------

Reason creates opinionated conventions for defining namespaces for the code you
write in `.re` files.

**Who can access my modules?**:
Suppose two packages exist as shown in the diagram. `myModule.re` can access
the module `Utils`, and `utils.re` can access the module `MyModule`. If
`YourProject` depends on `MyProject`, then `yourModule.re` can access
`MyProject.MyModule` and `MyProject.Utils`. The build system does not support
circular dependencies.

    └── MyProject/
        ├── package.json
        └── src/
            ├── myModule.re
            └── myUtils/
                └── utils.re

    └── YourProject/
        ├── package.json   #depends on MyProject
        └── src/
            └── yourModule.re

** Adding new privately visible modules **

To add a new privately visible module, just add a new `yourModule.re` file
anywhere in your project. Other internal modules will instantly be able to see
it as `YourModule`. Adding a corresponding `yourModule.rei` in the same
directory will ensure that compilation times remain fast, and allow you to
constrain the type of `YourModule`.

** Adding new publicly visible modules **

The process for adding new publicly visible modules is the same as private
modules, but they must be added to the `CommonML.exports` field of the
`package.json`

Incremental Compilation
-----------------------
Module signatures can greatly reduce compilation time by providing separate
compilation boundaries. They can play the role of "header files" in some sense.
If a module `X`'s, implementation changes we must recompile `X`.  If `X` had
been explicitly constrained to have a signature `XSig` which has *not* changed,
then other modules `Y`, `Z`, that depend on `X`, don't need to be recompiled
against the new build for `X`. We merely need to *relink* the previous build
artifacts for `Y` and `Z` against the new `X` artifact (which is much quicker).
However, if `X` did *not* constrain its signature to `XSig`, `Y` and `Z` *must*
be recompiled against the new artifact for `X`, and *then* relinked with `X`'s
new artifact.


How Reason Works
=========================


`Reason` implements a completely new *frontend* compiler toolchain
including parsing (both with and without error recovery), printing,
building, and namespacing. Like many other language toolchains
(such as `Flow` and `Hack`), `Reason` is mostly implemented in
`OCaml`, however `Reason` is different because it also uses later
stages of the `OCaml` `compiler-libs` to type check the `Reason` AST.
This approach has many benefits:

- Allows sharing of industrial grade developer tools such as
the excellent [`Merlin`](https://github.com/the-lambda-church/merlin) and `utop`.
- Allows direct use of the `ocamlopt` compiler backend
to generate (Ahead of Time) efficient native machine code without a
Virtual Machine.
- Allows seamless interop with, as well as an upgrade path for any
`OCaml` project.
- Allows building native libraries that can be linked with `clang`.


Interop
==============

**Integrating with `clang`/`gcc`:**

> Instructions Coming Soon

**Integrating with JavaScript:**

> Instructions Coming Soon

**Integrating with OCaml projects:**

Soon, there will be a drop in replacement for `ocamlbuild` called `rebuild`, that will
automatically build any `reason` file along with your `ocaml` files, with no
additional configuration.

Until then, the easiest way to use `Reason` with `ocamlopt/ocamlc` is by running the compiler with the following flags:
```sh
# intf-suffix tells the compiler where to look for corresponding interface files
ocamlopt -pp reasonfmt -intf-suffix rei -impl myFile.re
ocamlopt -pp reasonfmt -intf myFile.rei

```


Tooling
==============

`Reason` includes editor support for popular editors. Consistent,
line-wrapping AST based formatting is an important feature of `Reason`
that we've integrated directly into editors. Furthermore, because
`Reason` is fully compatible with [`Merlin`](https://github.com/the-lambda-church/merlin),
the `Reason` plugins provide professional IDE-quality autocompletion,
in-editor type checking (even when the file is invalid).


##### Atom Plugin


 * **Syntax Highlighting **
 * **Error Reporting **
 * **Powerful source formatting/indenting/wrapping **
 * **Basic autocompletion  **


<img src="images/VimReason.png" width=470 height=440 />


##### Vim Plugin

The [VimReason Plugin](https://github.com/facebook/Reason/tree/master/editorSupport/VimReason) plugin
implements basic IDE features for `Reason`.

 * **Syntax Highlighting **
 * **Error Reporting **
 * **Powerful source formatting/indenting/wrapping **
 * **Basic autocompletion  **


<img src="images/VimReason.png" width=470 height=440 />

##### Sublime Plugin

The
[SublimeReason](https://github.com/facebook/Reason/tree/master/editorSupport/sublime-reason)
plugin is included in the main [Reason](http://github.com/facebook/Reason)
repo. It includes basic highlighting support. Pull requests to invoke the
formatting program (and reporting of parsing errors) are appreciated.


* **Syntax Highlighting **

<img src="images/SublimeReason.png" width=470 height=440 />




Getting Involved
==============


Developing/Contributing
---------------

**1. Prepare Environemnt:**
If you already [installed](./index.html#reason-install) Reason by `pin`ing the
github repos, then you only need to unpin the packages and continue
to the next step.
```sh
opam unpin reasonsyntax
opam unpin reason
```
Otherwise, you may need to install some dependencies first:
```sh
opam install easy-format.1.2.0
opam install utop.1.18
```
### 
**2. Clone and `pin` locally:** Pinning makes built packages visible globally.
Pinning `ReasonSyntax` allows `Reason` to depend on it. Pinning `Reason` makes the
`reasonfmt` program available on the command line. Any time you change `ReasonSyntax`,
you must repin it so that `Reason` may be rebuilt while seeing those new changes. Any
time you change `Reason`, you must rebuild and repin it if you want the global `reasonfmt`
command to reflect those changes.

```sh
# 4.02.3 should also work
opam switch 4.02.1
git clone git+ssh://git@github.com/facebook/ReasonSyntax.git
git clone git+ssh://git@github.com/facebook/Reason.git
cd ReasonSyntax
make
opam pin add -y reasonsyntax .
cd ../Reason
make
opam pin add -y reason .
```
### 
**3. Run Test Cases:**
To test the pretty printer/parser, run the formatting tests and verify any
changes in the output file.

```sh
# Test changes - verify output in formatOutput.re
cd Reason/formatTest
./test.sh
```
  </script>

  <!-- Initializer -->
  <script>
    Flatdoc.run({
      fetcher: function(callback) {
        callback(null, document.getElementById('markdown').innerHTML);
      },
      highlight: function (code, value) {
        return (value === 'reason') ? hljs.highlight('reason', code).value : hljs.highlight(value, code).value;
      },
    });
  </script>

  <!-- Meta -->
  <meta property="og:image" content="./images/CubeRed598_614.png" />
  <meta property="og:image:secure_url" content="./images/CubeRed598_614.png" />
  <meta property="og:image:type" content="image/jpeg" />
  <meta property="og:image:width" content="1196" />
  <meta property="og:image:height" content="1228" />

  <meta content="Reason: Rapid Expressive Systems Programming." name="description">
  <meta content="Reason: Rapid Expressive Systems Programming." property="og:description">
  <!-- <meta content="http://ricostacruz.com/flatdoc/support/preview.jpg" property="og:image"> -->
</head>
<body role='flatdoc' class='big-h3 large-brief'>

  <!-- <div class='title&#45;area title&#45;card' style='background&#45;image: url(support/blur.jpg)'> -->

  <div class='title-area title-card'>
    <div class='in'>
      <div class='headline'>
        <h5><img style="width:80%; max-height:614px; max-width:598px;" src="images/CubeRed598_614.png"></img></h5>
      </div>
    </div>
  </div>

  <div class='header'>
    <div class='left'>
      <h1><a href='index.html'>Reason</a></h1>
      <ul>
        <li><a href='https://github.com/facebook/Reason'>View on GitHub</a></li>
        <li><a href='javaScriptCompared.html'>JavaScript Compared</a></li>
        <li><a href='mlCompared.html'>ML Compared</a></li>
      </ul>
    </div>
  </div>

  <div class='content-root'>
    <div class='menubar'>
      <div class='menu section' role='flatdoc-menu'></div>
    </div>
    <div role='flatdoc-content' class='content'></div>
  </div>

</body>
</html>
