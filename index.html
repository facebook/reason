<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Reason</title>

  <!-- Flatdoc -->
  <script src='support/vendor/jquery.js'></script>
  <script src='legacy.js'></script>
  <script src="highlightJs/build/highlight.pack.js"></script>
  <link  href='highlightJs/src/styles/xcode.css' rel='stylesheet'>
  <link rel="stylesheet" href="./octicons/octicons.css">
  <script src='flatdoc.js'></script>


  <!-- Flatdoc theme -->
  <link  href='theme-white/style.css' rel='stylesheet'>
  <script src='theme-white/script.js'></script>
  <link  href='support/theme.css' rel='stylesheet'>
  <script src='support/theme.js'></script>


  <script id="markdown" type="text/markdown" src="index.html">


Reason
=======
A new, approachable interface to the ML language.

<table style="width:100%">
  <tr style="border:none">
    <td style="border:none; padding:0px">
      <div class="featureContainer" style="">
        <div class="featureColumn" style="">
          <div class="featureIcon octicon octicon-code"></div>
          <div class="featureItemBox" style="">
            <span class="featureHeader">
              Syntax
            </span>
          </div>
        </div>
        <div class="featureColumn featureComingSoon" style="">
          <div class="featureIcon octicon octicon-zap"></div>
          <div class="featureItemBox" style="">
            <span class="featureHeader">
              Build
            </span>
          </div>
        </div>
        <div class="featureColumn featureComingSoon" style="">
          <div class="featureIcon octicon octicon-package"></div>
          <div class="featureItemBox" style="">
            <span class="featureHeader">
              Share
            </span>
          </div>
        </div>
      </div>
    </td>
  </tr>
  <tr style="border:none">
    <td style="padding: 20px; border:none; text-align:center">
[Compare JS >](./javaScriptCompared.html) [Compare ML >](./mlCompared.html)
    </td>

  </tr>


</table>

`Reason` is a new "interface" to the ML langauge - a toolchain writing, building,
and sharing code that targets the OCaml compiler. Reason's completely new syntax
works well with your existing tools/build systems so it is possible to use all
of `Reason` or just a portion, while gradually upgrading one file at a time.

Install
---------------
Install `OPAM` so that you can easily switch compiler versions (using
[Homebrew](http://brew.sh/)). Then switch to a supported compiler version
(`4.02.1` or `4.02.3` will work). Finally have `OPAM` install `Reason` from
Github by "pinning" it.

```sh
brew install opam --HEAD
opam init
# Add this to your ~/.bashrc (or ~/.zshrc):
#   eval `opam config env`

opam switch 4.02.3
opam pin add -y reasonsyntax git@github.com:facebook/ReasonSyntax.git#68d504daa9c8579e125e31c563c7388b7008ae86
opam pin add -y reason git@github.com:facebook/Reason.git#bdd6f3990570d20a7f70e7667223d4a68f4e4915
opam pin add -y merlin git@github.com:the-lambda-church/merlin.git#7f2f29ba85e07c9d0367456649e626d6ea6d037d

```

REPL
---------------

`Reason` comes with REPL called `rtop` which lets you interactively evaluate
`Reason` syntax in the REPL. It will also show printed results in `Reason` syntax.
It features intelligent, type-driven autocompletion (thanks to `utop`).
To submit commands, end each entry with a `;` and the REPL will print the
resulting value and inferred type.

```sh
# The rtop command begins a REPL session
rtop
```

```sh
let myVar = "Hello Reason!";
# myVar: bytes = "Hello Reason!"

let result = 100 + 200;
# result : int = 300;
```

> Note: `rtop` is a merely a wrapper around the excellent `utop` REPL
that has been customized for `Reason`.


Syntax Basics
=======

Much of Reason's core syntax should be familiar to anyone that has ever used
modern `JavaScript`/`Flow` or `Rust`. The examples in this document give an
overview of the most important language constructs and their respective syntax.

> Primitive                                  | Example
> --------------------------------------|--------------------------------
> Strings                               |  <pre>"Hello"</pre>
> Characters                            |  <pre>'x'</pre>
> Integers                              |  <pre>23</pre>
> Floats                                |  <pre>23.0</pre>
> Negative Integer                      |  <pre>-23</pre>
> Integer Addition                      |  <pre>23 + 1</pre>
> Float Addition                        |  <pre>23.0 +. 1.0</pre>
> Integer Division/Multiplication       |  <pre>2 / 23 * 1</pre>
> Float Division/Multiplication         |  <pre>2.0 /. 23.0 \*. 1.0</pre>
> String Concatenation                  |  <pre>"Hello" ^ "World"</pre>
> Immutable Lists                       |  <pre>[1, 2, 3]</pre>
> Immutable Lists append                |  <pre>[hd, hd2, ...tl]</pre>
> Reference Equality Comparison         |  <pre>thisThing === thatThing</pre>
> Records                               |  <pre>{contents: 100}</pre>
> Record Field Update (if mutable field)|  <pre>myRecord.contents = 200</pre>


Let Bindings
------------
`let` bindings give names to values. Those bindings can be seen and referenced
by code that comes after those bindings, so long as the bindings are still "in scope".
To make `let` bindings, use the `let` keyword with an `=` symbol, and put a `;` after
the binding. Try creating some bindings in the [`rtop REPL`](#reason-repl)

```reason
let identifier = expression;
let identifier = expression;
...
```

#### Let Bindings in Source Files

Reason source files begin with a lowercase letter and use the `.re` file
suffix. Among other things, each `.re` file includes a series of `let` bindings.
In this example, a file `react.re` has two `let` bindings.

```reason
/*
 * Contents of react.re
 */
let frameworkName = "React";
let renderCount = 0;
```

#### Limiting Scope

`let` bindings tie a name to a value and that name may be referenced at a later
point in the file. To further limit scope of bindings, `Reason` provides `{}`
block *expressions* which let you sequence `let`s together and then *evaluates*
to the last item in the sequence. In this example, the binding `three`
evaluates to the `integer` `3`.  The `{}` block ensures that `one` and `two`
are not accessible after `three` is computed.

```reason
let three = {
  let one = 1;
  let two = 2;
  one + two
};
/* one and two not accessible here! */
```
> Note that the last item may optionally include a terminating semicolon.

#### Constant bindings

`let` bindings are immutable. Once a binding refers to a value, it cannot
refer to anything else. However, you may create a new binding of the same
name which will *shadow* the previous binding.

```reason
/* Prints "hello bye" */
let msg = "hello ";
print_string msg;
let msg = "bye";
print_string msg;
```


#### Imperative Code

You may interleave imperative commands such as logging along with your let
bindings. This works both for `let` bindings in files, and also in block
scopes. Interleaved imperative commands don't change what block expressions
evaluate to.

```reason
let three = {
  let one = 1;
  print_string "fire the missiles";
  let two = 2;
  one + two
};
```

Types Basics
--------------------------

#### Type Annotations

Even though types are inferred, you may still choose to write "type assertions"
on any expression. Anywhere you would normally write an expression, just append
`: yourType`, and then wrap the result in parenthesis.


```reason
(expression : typeConstraint)
```


These assertions are then verified by the compiler.
```reason
let bindingOne = 5;
let bindingOne = (5 : int);
let bindingOne = (5 : int) + (4 : int);
let bindingOne = ((5 : int) + (4 : int) : int);
```
The other place that type assertions are accepted, is immediately following the
`let` keyword. This is equivalent to asserting the type of the expression on
the right hand side of the `=`.
```reason
let identifier : typeConstraint = expression;
let identifier = (expression : typeConstraint);
```

<br />

```reason
/* Equivalent type assertions. */
let frameworkName = ("React": string);
let frameworkName : string = "React";
```

#### Type Aliases

You may refer to a type by a different name, by creating a type alias with the
`type` keyword. The new type alias may be used in annotations as well. You can
see there is somewhat of a "scope" for `type` aliases, similar to `let`
bindings.

```reason
type myType = int;
let x: myType = 10;  /* Now we can "see" myType */
```

Tuples
--------------------------

A tuple is a list of values of *known* size, such as "pair". They are written
as comma delimited lists, always wrapped in parenthesis.


```reason
let myThreeFloats = (20.0, 30.0, 100.0);
let myIntAndString = (20, "totallyNotAnInteger");
```

Tuples have types and those types can be used in type annotations as well.
Tuple types resemble tuples themselves - comma delimited lists of types,
wrapped in parenthesis.

```reason
let myThreeFloats: (float, float, float)  = (20.0, 30.0, 100.0);
let myIntAndString: (int, string) = (20, "totallyNotAnInteger");
```

Tuples represent two or more values together, but sometimes you want to
represent *zero* values. In `Reason`, you can express this idea by writing
`()`. We call this thing "unit", and it has type `unit`.

```reason
let nothing = ();
```

You may create type aliases for tuple types just like you can with any other
type.
```reason
type threeFloats = (float, float, float);
type intAndString = (int, string);

let myThreeFloats: threeFloats = (20.0, 30.0, 100.0);
let myIntAndString: intAndString = (20, "totallyNotAnInteger");
```

Records
-------

Records are a set of named values. They resemble "objects" (from OO) but they
are simpler, less flexible, and offer extremely fast field access. To create a
record, some type definition describing its fields must be in scope.  In
`Reason`,  type definitions for records resemble the shape of the records
values they describe.


```reason
type person = {age: int, name: string};
let me = {age: 30, name: "Jordan"};
print_string me.name;
```

New records may be easily created from old records with the `...` spread
operator, which changes a subset of the fields, but doesn't alter the original
record.

```reason
let meNextYear =  {
  ...me,
  age: me.age + 1
};
```

##### Mutable record fields.

When defining the record type, you can mark some record fields as `mutable`.
This allows you to update those fields with the `=` operator. In general,
having language level distinction between `mutable` and immutable offers
opportunities for compile time performance optimizations.

```reason
type person = {
name: string,
  mutable age: int
};
let me = {name: "Jordan", age: 30};
me.age = me.age + 1;
```

Destructuring
-------------
"Destructuring" can be used to extract one or more fields from a record or
tuple, while automatically binding them to local variables. Any place variables
are introduced into scope, you may use destructuring. To destructure, instead
of writing the variable name as usual, write out the deep shape of the object.


> The following binds variables:
> `ten = 10`, `twenty = 20`

```reason
let someInts = (10, 20);
let (ten, twenty) = someInts;
```

> The following binds variables:
> `n = "Guy"`, `a = 30`

```reason
let somePerson = {name: "Guy", age: 30};
let {name: n, age: a} = somePerson;
```

Destructuring also allows type annotations *while* destructuring.
```reason
let (ten: int, twenty: int) = someInts;
let {name: (n:string), age: (a:int)} = somePerson;
```



Functions
---------

Functions are introduced with the `fun` keyword, followed by the name of the
arguments, an arrow `=>` then any expression acting as the return value.  All
functions accept a single argument, and return a single value. This ends up
being very convenient.

```reason
fun argument => expression
```
Functions are first class and you can use `let` bindings to give them names.


```reason
let increment = fun x => x + 1;
let double = fun x => x + x;
```
To call a function, supply its argument after the name of the function.

```reason
let six = increment(5);
let thirteen = increment(double(6));
```
The parenthesis around the argument may be omitted if the argument is
clearly "one unit" (such as a single word or number). In this example, the `5`
is clearly one unit so the `()` were omitted. The parenthesis around `double
6`, could _not_ be omitted because `double 6` is not "one unit".

```reason
let six = increment 5;
let thirteen = increment (double 6);
```

#### 

Although functions can return any expression, "block expressions" are often
chosen because they allow declaring temporary, block-scoped variables, and
allow performing side effects.

```reason
let doSomeMath = fun arg => {
  let tmp = 2 * arg;
  let next = 3 * arg;
  tmp * next
};

let performsSideEffects = fun arg => {
  print_string "Entering the function";
  let tmp = 2 * arg;
  let next = 3 * arg;
  print_string "Returning from the function";
  tmp * next
};
```

#### Arguments

If you want to pass more data to the input of your function all at once, simply
pass a tuple containing all the data.  Function arguments may be
[destructured](#syntax-basics-destructuring) "on the
way into" the function. This example of passes a tuple to a function and
destructuring that tuple on the way in.
```reason
let addTupleFields = fun (first, second) => {
  first + second
};
let five = addTupleFields (4, 1);
```

The tuple is still first class, and the function still accepts a single argument, so
you could have also called the function like this:
```reason
let myTuple = (4, 1);
let five = addTupleFields myTuple;
```


You can pass, and destructure a tuple with zero elements as well.

```reason
let logToUser = fun () => {
  print_string "Logging to user";
  print_string "Okay, logging done";
};
/* Now call it */
logToUser ();
```


#### 
You can pass/destructure records too. (If record type
definitions are in scope).

```reason
let isOverThirty = fun {name: n, age: a} => {
  let ret = a > 30;
  ret
};
let overThirty = isOverThirty {name: "Jay", age: 31};
```

You may annotate the types of individual parts of the destructuring on the way
into the function.
```reason
let addTupleFields = fun (first:int, second:int) => {
  first + second
};
let isOverThirty = fun {name: (n:int), age: (a:int)} => {
  let ret = a > 30;
  ret
};
```


#### Function Types
Function types are written by listing the argument type, an arrow, and then
the return type.

```reason
argumentType => expressionType
```

Here, we create a type alias for the types of functions in the previous
examples and then we assert that they are compatible with those functions.

```reason
type intTupleToInt = (int, int) => int
type intToInt = int => int;
let a = (increment : intToInt);
let b = (addTupleFields : intTupleToInt);
```




#### Recursive Functions

By default, values can't see a binding that points to it, but including the
`rec` keyword in a `let` binding makes this possible. This allows functions
to see and call themselves, giving us the power of recursion.

```reason
let rec neverTerminate = fun n => n + neverTerminate (n - 1);
```



#### Mutually Recursive Functions



Variants
--------

Variant types allows data to have either one form *or* another. In Reason, each
form is given a capitalized name called a "constructor" (not in the OO sense).
To declare a variant type, enumerate every constructor by the `|` token.

```reason
type response =
  | Yes
  | No
  | PrettyMuch;
let areYouCrushingIt = Yes;
```

`switch` expressions are like large `if/elseif/elseif..` expressions but much
more powerful because they ensure that all cases are covered. To use `switch`,
enumerate every variant constructor in "table" form followed by an `=>` and
finally the value to be returned by the `switch` for that case. In this
example, the `message` variable is assigned the string `"..."`.


> Note: Compilation will raise a type error if you've forgotten to have your
> `switch` cover a case, or if two cases are redundant.

```reason
let isSafeToLaunchRocket = PrettyMuch;
let message = switch isSafeToLaunchRocket {
  | No => "Check Integrity."
  | Yes => "All Systems Go."
  | PrettyMuch => "..."
};
```
##### Constructor Arguments

Constructors may contain one or more pieces of data by declaring those
contained types in a space-separated list after an `of` keyword.
```reason
type account =
  | None
  | Facebook of string int
  | Instagram of string;

```

> Instantiating a constructor that carries data is exactly the same as
calling a function. Supply the data as space separated "arguments".

```reason
let myAccount = Facebook "Kay" 1234;  /* Accepts two arguments */
let yourAccount = None;               /* Accepts no arguments */
```

##### Destructuring Arguments of a Constructor

Once created, constructor data can be extracted via destructuring, much like
with tuples. In this example, a local variable `x` is bound to `42`.
`getTheInt` extracts a `Leaf`'s contained integer "on the way into" the function.

```reason
type intLeaf = | Leaf of int;
let myIntLeaf = Leaf 42;

let Leaf x = myIntLeaf;
let getTheInt = fun (Leaf q) => q;
let fourtyTwo = getTheInt myIntLeaf;
let twentyNine = getTheInt (Leaf 29);
```

** When Simple Destructuring Isn't Enough: **
Simple destructuring isn't sufficient for variants types with many
constructors. The following example would clearly have to fail at runtime!
Fortunately, the compiler forbids this.

```reason
type possibleNum =
  | NotDefined
  | Defined of integer;

let myNumber = NotDefined;
let Defined x = myNumber;   /* Type error! */
```
** The Solution: ** To recover data in variants with many constructors,
`switch` allows us to enumerate each constructor *while* destructuring the
constructor's data on the left side of the `=>`.  Unlike our previous naive
attempt, this works because we enumerate every possible constructor name inside
of the `switch`.

> Note: We've safely unpacked the `i` from `Defined i`, because we've *also*
> specified what to do when `myNumber` was `NotDefined`.

```reason
let x = switch myNumber {
  | Defined i => i
  | NotDefined => 0
};
```
##### Multiple Arguments vs. Tuples (*Details*)

Notice that a variant constructor that contains many fields is different than a
variant constructor that carries a single field that happens to be a tuple.
Among other differences, tuples are not "inlined" into the variant object's
runtime representation, whereas, multiple constructor arguments incur no
additional abstraction cost (they are "inlined" into the variant data).

```reason
type toTupleOrNotToTuple =
   | HasTuple of (int, int, int)
   | NoTuple of int int int;

let aTuple = HasTuple (1, 2, 3);
let notTuple = NoTuple 1 2 3;

let sumsZero = switch x {
  | HasTuple (a, b, c) => a + b + b == 0
  | NoTuple a b c => a + b + b == 0
};

```

Loops and Tests
--------------------------

#### If Expressions

The syntax for `if` expressions should look very familiar. Just like within
function "bodies", the `{}` braces may include a sequence of temporary `let`
bindings or imperative commands, all separated by `;`. An `if` statement may
include an optional `else` branch.

```reason
if (testCondition) {
  ifTrue
};

if (testCondition) {
  ifTrue
} else {
  ifFalse
};
```

In this example, the word `"hi"` is printed if `sayHi` is `true`, and prints
`"bye"` otherwise.
```reason
if (sayHi) {
  print_string "hi";
} else {
  print_string "bye";
};
```

> Note: The parenthesis around the test condition may be omitted if the test
condition is "simple" enough (meaning it is a single, standalone word).

If expressions aren't just for imperative code - they can also be used to
compute a result. Just place an expression on the final line of the `{}`
sequence for each branch. If your `if` expression has no `else` branch, it
is clearly only useful for imperative programming and therefore the entire `if`
will evaluate to the unit value `()`.


```reason
let valueToLog =
  if (booleanTest) {
    let tmp = "name";
    String.capitalize tmp;
  } else {
    "default";
  };
```

`if`/`else` expressions may be chained together in a familiar manner.

```reason
if (sayHi) {
  print_string "hi";
} else if (sayBye) {
  print_string "bye";
} else {
  print_string "nothing to say";
};
```
#### Ternaries

For smaller boolean if else statements, `Reason` includes a ternary expression
which might look more aesthetically pleasing in some cases.

```reason
testCondition ? ifTrue : ifFalse
```

```reason
let valueToLog = shouldUseDefault ? 200 : yourNumber;
```


#### For Loops

For loops are fully imperative constructs that iterate through a range of
numbers, from a beginning value up to (and including) the ending value. The
general form of a `for` loop includes an identifier that is incremented each
iteration, and a range `startVal` to `endVal`.

```reason
for identifier in (startVal) to (endVal) {
  statements
}
```

The parenthesis around the `startVal` and `endVal` may be omitted if they are
clearly unnecessary as in the following example.

```reason
let xStart = 1;
let xEnd = 3;
/* prints: 1 2 3 */
for x in xStart to xEnd {
  print_int x;
  print_string " ";
}
```

You can make the `for` loop count in the opposite direction by using the `downto`
keyword.

```reason
for identifier in (startVal) downto (endVal) {
  statements
}
```

```reason
let xStart = 3;
let xEnd = 1;
/* prints: 3 2 1 */
for x in xStart downto xEnd {
  print_int x;
  print_string " ";
}
```

#### While Loops


Diving Deeper
==============

Curried Functions
-------------------

"Curried" functions are simply functions that, when called, return another function.
Any language that allows first class functions supports currying and there is
nothing special about curried functions. Currying is something _you_ the
programmer do - it's not typically a language feature. In general, curried
functions have the following form:

```reason
let curried =
  fun argOne => fun argTwo => ... fun finalArg => expression
```
When `curried` is called with an argument, it returns another function. When
_that_ function is called with _its_ argument, it returns yet another function.
This continues on until finally the last function is called, and then
`expression` is returned.

```reason
let result = curried(argOne)(argTwo) ... (finalArg);
```

It's much easier to understand what's going on by looking at a simple example.


```reason
let add = fun a => fun b => a + b;
let eight = add(2)(6);
let nine = add(2)(add 6 1);
let addFour = add (4);
let five = addFour(1);
let six = addFour (2);
```
> This example shows why currying can be elegant - it allows you to easily create
new versions of functions that are the same as the old ones, but with _some_ of
the argument data filled in. Here, `addFour` is like a specialized version of `add`
with the first argument "filled in".

Instead of having a function accept a tuple as an argument, you might chose to
make that function curried instead. Currying accomplishes the same goal, but
allows you to supply the set of input data one at a time, potentially "pausing"
when you've only supplied a portion of the argument data. Compare this to
passing a tuple where you must supply all of the data at once.

#### Syntax to make currying easier

Reason includes the following syntax shortcut to make currying easier: The
following two are equivalent.

```reason
fun argOne => fun argTwo => expression
```
```reason
fun argOne argTwo => expression
```

When applying curried functions, the ability to omit parenthesis when arguments
are "obviously one unit" makes applying curried arguments much cleaner. Putting
it all together:
```reason
let add = fun a b => a + b;
let eight = add 2 6;
let nine = add 2 (add 6 1);
```

#### Curried function types

A function defined as:
```reason
let add = fun a => fun b => a + b;
```

Will have the following type:
```
int => int => int
```

In general, the following function definitions:
```reason
fun argOne argTwo ... finalArg => expression
```

Will will have the following type:
```reason
argOneType => argTwoType ... => finalArgType => expression
```


#### Named Curried Functions

One downside to curried functions is that they are "biased" to arguments that
appear first. Meaning, when you curry functions, you can "partially apply" some
of the arguments, saving the rest for later, but you can only partially apply
the arguments that come *first*. Labelled curried functions address this
concern by letting you assign *labels* to arguments, and then partially apply
arguments by their label, regardless of their *position*. Labels are created by
simply prepending `labelName::` to the function argument.

```reason

let add =
  fun first::f second::s => f + s;

let result = add first::10 second::20;

let addFour = add second::4;

let five = addFour first::1;

```

Labelled curried arguments also allow setting default values using the equals
sign. The way defaults work is a little tricky, but here's the general rule:
When calling functions, default arguments are "filled in" as soon as you supply
a *non-named* argument. More specifically - all of the default arguments to the
*left* of that non-named argument are filled in, as soon as the non-named argument
is supplied at invocation time.

```reason

/* Notice how `by` is to the left of `num` */
let increment = fun by::by=0 num => num + by;

let two = increment by::1 1;

let four = increment 4;

```


Type Families
---------------------------

*TODO: Improve this*

Some types are very specific, such as `int`, or `string`, but other types
are much more general. For example, knowing that a value has type `list`,
leaves so many unanswered questions - namely, what's in the list?! Sometimes
you don't *need* to know that level of detail, but other times you do.

In `Reason`, the type of a `list` that contains `string`s is written as `list string`.

```reason
let listOfStrings : list string = ["hi", "bye"];
```

The type of a `list` containing `int`s is written `list int`.

```reason
let listOfInts : list string = [4, 4];
```

It's clear that `list` represents an entire "family" of types. `list` can be
thought of as a "function" that generates types - you pass it a type, and it
generates a new type.

The way you can define your own custom "family" of types is by using the
following syntax. Notice the `'` before the `argOne`.

```reason
type 'argOne = typeStructure;
```

For example, you could define a family of tuple types like this:

```reason
type awesomeTuple 'a = ('a, 'a);
```

Then you could create more specific types by "calling" the `awesomeTuple` type
generating "function" as follows:

```reason
type awesomeTuple 'a = ('a, 'a);
type tupleOfInts = awesomeTuple int;
```


Expressive Pattern Matching
---------------------------
There are several destructuring conveniences that pair well with compiler
verified `switch` expressions.
For example, you can express arbitrarily nested destructuring "patterns", which
the compiler will ensure have no uncovered cases. In this example, `name` is
bound to `"Jo"` and `model` is bound to `"Tacoma"`.

```reason
type car = {model: string, make: string};
let toyota = {make: "Toyota", model: "Tacoma"};

type carOwner =
  | CarOwner of string car; /* May as well be a tuple */

let CarOwner name {model: model, make: make} = CarOwner "Jo" toyota;
```

##### 
This deep pattern matching is especially expressive when used in `switch`
expressions. In this example, the function `hasExactlyTwoCars` has specified
what to return in four cases in very little code. Even more helpful, is the
fact that the compiler verifies that no two edge cases are redundant, and that
every possible case has been covered. It turns out, that pattern matching
becomes an extremely powerful tool to enforce constraints in your program. The
more you model your program in terms of variants, the more the compiler assists
you stop bugs before they even run - the end result being more rapid
development. This `ML` pattern matching is famous for coining the phrase: "If
it compiles, it works!".

```reason
type carList =
  | List of car carList
  | NoMore;

let chevy = {make: "Chevy", model: "Suburban"};
let toyota = {make: "Toyota", model: "Tacoma"};
let myCarList = List chevy (List toyota NoMore);

let hasExactlyTwoCars = fun lst =>
  switch lst {
    | NoMore => false                         /* 0 */
    | List p NoMore => false                  /* 1 */
    | List p (List p2 NoMore) => true         /* 2 */
    | List p (List p2 (List p3 rest)) => false  /* 3+ */
  };

let justTwo = hasExactlyTwoCars myCarList;  /* true! */

```

Syntax Sugars
----------------------------------


##### Function sugar
You've already seen one form of function syntax sugar. Though it appears that
functions accept multiple arguments, every function actually only accepts a
single argument. "Multiple arguments" separated by spaces are actually defining
a series of curried functions. These two function definitions are equivalent.

```reason
let add = fun a b => a + b;
let add = fun a => fun b => a + b;
```

Because parenthesis around the function argument may be omitted if the argument
is clearly a single word or a grouping, function application for a curried
function can look very clean in many cases.

```reason
let five = add(4)(1);
/* Is the same as */
let five = add 4 1;
```

You only need to include parenthesis around arguments when it otherwise
wouldn't obviously be a single item.
```reason
let five = add (firstEvaluateThis 0 0) 1;
```
> Note: You pay no additional performance cost for curried functions
when they are invoked with all arguments. You may even ignore the fact that
currying is occurring at all, if you like.

##### Function let binding sugar
There's one more function binding syntax that hasn't yet been shown: When
assigning a `let` binding to a function, the `= fun` portion may be omitted.
This means writing functions in the form: `let functionName arg1 arg2 =>
expression`.

```reason
/**
 * All of the following are equivalent:
 */
let add a b => a + b;
let add = fun a b => a + b;
let add = fun a => fun b => a + b;
```

##### Module function Binding Sugar

[Module Functions](./modules.html#modules-module-functions) follow the same sugar convention as regular
functions. Space-separated arguments are actually currified *module functions*
and the `= functor` may be omitted, resulting in three forms of module function
definitions which are all equivalent.

```reason
let module ModuleFunc (A:ASig) (B:BSig) => {};
let module ModuleFunc = functor (A:ASig) (B:BSig) => {};
let module ModuleFunc = functor (A:ASig) => functor (B:BSig) => {};
```

##### Record value "punning"

If variables names in scope perfectly correspond to record property names, then
records can be written in a shorter form.

```reason
type myRecord = {first: int, second: int};
let first = "f";
let second = "s";

/* These following are equivalent. */
let theRecord = {first:first, second:second};
let theRecord = {first, second};

/* Or only take the shortcut for a subset of the fields */
let theRecord = {first, second: 0};

```

##### Record *pattern* punning

The same record "punning" syntax may be used with destructuring, in all of the
places where destructuring is allowed (`let` bindings, function arguments,
`switch` matching).

```reason
let {first:first, second:second} = theRecord;
let {first, second} = theRecord;   /* Shortcut */

let sumsToZero = fun {first, second} => first + second == 0;
```


Advanced 
=======

###### Modules:

See [Modules](./modules.html)


How Reason Works
=========================

The OCaml compiler is organized into several stages, which are exposed as
libraries. `Reason` replaces part of the compiler toolchain with a completely
new syntax parser that, is more approachable, while still fully compatible with
the rest of the compiler.  `Reason` also implemented a new source printer which
integrates into your IDE and the new custom [`REPL`](#reason-repl).

###### Why OCaml?

OCaml is a great tool for writing highly expressive, type inferenced functional
*or* imperative code that performs very well. In this role, OCaml has helped
Facebook quickly build scalable infrastructure such as
[Hack](http://hacklang.org/), [Flow](http://flowtype.org/), and
[Infer](http://fbinfer.com/). It is also used for other performance sensitive
applications in the financial industry (Jane Street, Bloomberg). At the same
time, OCaml has a very mature (*and still growing*) ecosystem for targeting
browser and `JavaScript` environments with a focus on interop and integration
with existing `JavaScript` code.


`Reason`'s non-invasive approach to the `OCaml` compiler allows `Reason` code
to take advantage of all of the existing `OCaml` compiler
optimizations/backends such as bare metal `ARM`, `x86`, and even `JavaScript`
compilation.

###### Acknowledgments

`Reason` is also a curation of best-in-class tools. It already incorporate or
directly includes several technologies that make the `Reason` developer
experience possible.

- `OCaml` - itself.
- `utop` - highly customizable top level.
- `Merlin` - The Merlin team has completely refactored Merlin to be able to
support `Reason`'s, use case.



Getting Involved
==============


#### Developing/Contributing

**1. Prepare Environemnt:**
If you already [installed](./index.html#reason-install) Reason by `pin`ing the
github repos, then you only need to unpin the packages and continue
to the next step.
```sh
opam unpin reasonsyntax
opam unpin reason
```
Otherwise, you may need to install some dependencies first:
```sh
opam install easy-format.1.2.0
opam install utop.1.18
```
### 
**2. Clone and `pin` locally:** Pinning makes built packages visible globally.
Pinning `ReasonSyntax` allows `Reason` to depend on it. Pinning `Reason` makes the
`reasonfmt` program available on the command line. Any time you change `ReasonSyntax`,
you must repin it so that `Reason` may be rebuilt while seeing those new changes. Any
time you change `Reason`, you must rebuild and repin it if you want the global `reasonfmt`
command to reflect those changes.

```sh
# 4.02.3 should also work
opam switch 4.02.1
git clone git+ssh://git@github.com/facebook/ReasonSyntax.git
git clone git+ssh://git@github.com/facebook/Reason.git
cd ReasonSyntax
make
opam pin add -y reasonsyntax .
cd ../Reason
make
opam pin add -y reason .
```
### 
**3. Run Test Cases:**
To test the pretty printer/parser, run the formatting tests and verify any
changes in the output file.

```sh
# Test changes - verify output in formatOutput.re
cd Reason/formatTest
./test.sh
```
  </script>

  <!-- Initializer -->
  <script>
    Flatdoc.run({
      fetcher: function(callback) {
        callback(null, document.getElementById('markdown').innerHTML);
      },
      highlight: function (code, value) {
        return (value === 'reason') ? hljs.highlight('reason', code).value : hljs.highlight(value, code).value;
      },
    });
  </script>

  <!-- Meta -->
  <meta property="og:image" content="./images/CubeRed598_614.png" />
  <meta property="og:image:secure_url" content="./images/CubeRed598_614.png" />
  <meta property="og:image:type" content="image/jpeg" />
  <meta property="og:image:width" content="1196" />
  <meta property="og:image:height" content="1228" />

  <meta content="Reason: Rapid Expressive Systems Programming." name="description">
  <meta content="Reason: Rapid Expressive Systems Programming." property="og:description">
  <!-- <meta content="http://ricostacruz.com/flatdoc/support/preview.jpg" property="og:image"> -->
</head>
<body role='flatdoc' class='big-h3 large-brief'>

  <!-- <div class='title&#45;area title&#45;card' style='background&#45;image: url(support/blur.jpg)'> -->

  <div class='title-area title-card'>
    <div class='in'>
      <div class='headline'>
        <h5><img style="width:80%; max-height:614px; max-width:598px;" src="images/CubeRed598_614.png"></img></h5>
      </div>
    </div>
  </div>

  <div class='header'>
    <div class='left'>
      <h1><a href='index.html'>Reason</a></h1>
      <ul>
        <li><a href='index.html#reason-install-link'>Install</a></li>
        <li><a href='index.html#syntax-basics'>Learn</a></li>
        <li><a href='projects.html'>Projects</a></li>
        <li><a href='tools.html'>Tools</a></li>
        <li><a href='https://github.com/facebook/Reason'>Github</a></li>
      </ul>
    </div>
  </div>

  <div class='content-root'>
    <div class='menubar'>
      <div class='menu section' role='flatdoc-menu'></div>
    </div>
    <div role='flatdoc-content' class='content'></div>
  </div>

</body>
</html>


