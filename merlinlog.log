# 0.00 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.00 dot_merlin - load filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.00 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.00 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.00 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.00 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.00 frontend - output
[ "return", true ]
# 0.00 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.02 frontend - output
[ "return", [] ]
# 0.02 dot_merlin - load filenames
[]
# 0.03 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.03 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.03 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.03 frontend - output
[ "return", true ]
# 0.03 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 13, "col": 22 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 frontend - output
[
  "return",
  [
    {
      "start": { "line": 13, "col": 4 },
      "end": { "line": 13, "col": 26 },
      "type": "'a",
      "tail": "no"
    }
  ]
]
# 0.03 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.03 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.03 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.03 frontend - output
[ "return", true ]
# 0.03 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 13, "col": 35 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 frontend - output
[
  "return",
  [
    {
      "start": { "line": 13, "col": 29 },
      "end": { "line": 13, "col": 38 },
      "type":
        "{\n  type any;\n  external inject : 'a => any = \"%identity\";\n  external coerce : Js.t 'a => Js.t 'b = \"%identity\";\n  external get : 'a => 'b => 'c = \"caml_js_get\";\n  external set : 'a => 'b => 'c => unit = \"caml_js_set\";\n  external delete : 'a => 'b => unit = \"caml_js_delete\";\n  external call : 'a => 'b => array any => 'c = \"caml_js_call\";\n  external fun_call : 'a => array any => 'b = \"caml_js_fun_call\";\n  external meth_call : 'a => string => array any => 'b = \"caml_js_meth_call\";\n  external new_obj : 'a => array any => 'b = \"caml_js_new\";\n  external obj : array (string, any) => 'a = \"caml_js_object\";\n  external pure_expr : (unit => 'a) => 'a = \"caml_js_pure_expr\";\n  external eval_string : string => 'a = \"caml_js_eval_string\";\n  external js_expr : string => 'a = \"caml_js_expr\";\n  external pure_js_expr : string => 'a = \"caml_pure_js_expr\";\n  let global : Js.t < .. >;\n  external callback : ('a => 'b) => Js.meth_callback 'c 'a => 'b\n    = \"%identity\";\n  external meth_callback : ('b => 'a) => Js.meth_callback 'b 'a\n    = \"caml_js_wrap_meth_callback_unsafe\";\n  external variable : string => 'a = \"caml_js_var\";\n}",
      "tail": "no"
    },
    {
      "start": { "line": 13, "col": 29 },
      "end": { "line": 13, "col": 46 },
      "type": "string => 'a",
      "tail": "no"
    },
    {
      "start": { "line": 13, "col": 29 },
      "end": { "line": 33, "col": 2 },
      "type": "'a",
      "tail": "no"
    }
  ]
]
# 0.03 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.03 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.03 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.03 frontend - output
[ "return", true ]
# 0.03 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 13, "col": 16 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 frontend - output
[
  "return",
  [
    {
      "start": { "line": 13, "col": 4 },
      "end": { "line": 13, "col": 26 },
      "type": "'a",
      "tail": "no"
    }
  ]
]
# 0.03 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.03 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.03 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.03 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.03 frontend - output
[ "return", true ]
# 0.03 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 10, "col": 18 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.04 frontend - output
[
  "return",
  [
    {
      "start": { "line": 10, "col": 15 },
      "end": { "line": 10, "col": 24 },
      "type":
        "{\n  type any;\n  external inject : 'a => any = \"%identity\";\n  external coerce : Js.t 'a => Js.t 'b = \"%identity\";\n  external get : 'a => 'b => 'c = \"caml_js_get\";\n  external set : 'a => 'b => 'c => unit = \"caml_js_set\";\n  external delete : 'a => 'b => unit = \"caml_js_delete\";\n  external call : 'a => 'b => array any => 'c = \"caml_js_call\";\n  external fun_call : 'a => array any => 'b = \"caml_js_fun_call\";\n  external meth_call : 'a => string => array any => 'b = \"caml_js_meth_call\";\n  external new_obj : 'a => array any => 'b = \"caml_js_new\";\n  external obj : array (string, any) => 'a = \"caml_js_object\";\n  external pure_expr : (unit => 'a) => 'a = \"caml_js_pure_expr\";\n  external eval_string : string => 'a = \"caml_js_eval_string\";\n  external js_expr : string => 'a = \"caml_js_expr\";\n  external pure_js_expr : string => 'a = \"caml_pure_js_expr\";\n  let global : Js.t < .. >;\n  external callback : ('a => 'b) => Js.meth_callback 'c 'a => 'b\n    = \"%identity\";\n  external meth_callback : ('b => 'a) => Js.meth_callback 'b 'a\n    = \"caml_js_wrap_meth_callback_unsafe\";\n  external variable : string => 'a = \"caml_js_var\";\n}",
      "tail": "no"
    },
    {
      "start": { "line": 10, "col": 15 },
      "end": { "line": 10, "col": 32 },
      "type": "string => 'a",
      "tail": "no"
    },
    {
      "start": { "line": 10, "col": 15 },
      "end": { "line": 10, "col": 61 },
      "type": "'a",
      "tail": "no"
    }
  ]
]
# 0.04 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.04 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.04 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\nJ\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.04 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.04 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.04 frontend - output
[ "return", true ]
# 0.04 frontend - input
{
  "query": [ "complete", "prefix", "J", "at", { "line": 11, "col": 1 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.04 frontend - output
[
  "return",
  {
    "entries": [
      { "name": "Js", "kind": "Module", "desc": "", "info": "" },
      { "name": "JsUtils", "kind": "Module", "desc": "", "info": "" },
      { "name": "Jstable", "kind": "Module", "desc": "", "info": "" },
      { "name": "JsooTopError", "kind": "Module", "desc": "", "info": "" },
      { "name": "JsooTop", "kind": "Module", "desc": "", "info": "" },
      {
        "name": "Jsoo_findlib_support",
        "kind": "Module",
        "desc": "",
        "info": ""
      },
      { "name": "Jsonp", "kind": "Module", "desc": "", "info": "" },
      { "name": "Json", "kind": "Module", "desc": "", "info": "" }
    ],
    "context": null
  }
]
# 0.04 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.04 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.04 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\nJs\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.04 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.04 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.04 frontend - output
[ "return", true ]
# 0.04 frontend - input
{
  "query": [ "complete", "prefix", "Js", "at", { "line": 11, "col": 2 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.04 frontend - output
[
  "return",
  {
    "entries": [
      { "name": "Js", "kind": "Module", "desc": "", "info": "" },
      { "name": "JsUtils", "kind": "Module", "desc": "", "info": "" },
      { "name": "Jstable", "kind": "Module", "desc": "", "info": "" },
      { "name": "JsooTopError", "kind": "Module", "desc": "", "info": "" },
      { "name": "JsooTop", "kind": "Module", "desc": "", "info": "" },
      {
        "name": "Jsoo_findlib_support",
        "kind": "Module",
        "desc": "",
        "info": ""
      },
      { "name": "Jsonp", "kind": "Module", "desc": "", "info": "" },
      { "name": "Json", "kind": "Module", "desc": "", "info": "" }
    ],
    "context": null
  }
]
# 0.04 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.04 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.04 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\nJs.\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.04 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.04 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.04 frontend - output
[ "return", true ]
# 0.04 frontend - input
{
  "query": [ "complete", "prefix", "Js.", "at", { "line": 11, "col": 3 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.05 frontend - output
[
  "return",
  {
    "entries": [
      {
        "name": "Error",
        "kind": "Constructor",
        "desc": "(Js.t Js.error) => exn",
        "info": ""
      },
      {
        "name": "_JSON",
        "kind": "Value",
        "desc": "Js.t Js.json",
        "info": ""
      },
      { "name": "_false", "kind": "Value", "desc": "Js.t bool", "info": "" },
      { "name": "_true", "kind": "Value", "desc": "Js.t bool", "info": "" },
      {
        "name": "array",
        "kind": "Value",
        "desc": "array 'a => Js.t (Js.js_array 'a)",
        "info": ""
      },
      {
        "name": "array_empty",
        "kind": "Value",
        "desc": "Js.constr (Js.t (Js.js_array 'a))",
        "info": ""
      },
      {
        "name": "array_get",
        "kind": "Value",
        "desc": "Js.t #Js.js_array 'a => int => Js.optdef 'a",
        "info": ""
      },
      {
        "name": "array_length",
        "kind": "Value",
        "desc": "Js.constr int => Js.t (Js.js_array 'a)",
        "info": ""
      },
      {
        "name": "array_map",
        "kind": "Value",
        "desc": "('a => 'b) => Js.t #Js.js_array 'a => Js.t #Js.js_array 'b",
        "info": ""
      },
      {
        "name": "array_mapi",
        "kind": "Value",
        "desc":
          "(int => 'a => 'b) => Js.t #Js.js_array 'a => Js.t #Js.js_array 'b",
        "info": ""
      },
      {
        "name": "array_set",
        "kind": "Value",
        "desc": "Js.t #Js.js_array 'a => int => 'a => unit",
        "info": ""
      },
      {
        "name": "bool",
        "kind": "Value",
        "desc": "bool => Js.t bool",
        "info": ""
      },
      {
        "name": "bytestring",
        "kind": "Value",
        "desc": "string => Js.t Js.js_string",
        "info": ""
      },
      {
        "name": "coerce",
        "kind": "Value",
        "desc": "'a => ('a => Js.Opt.t 'b) => ('a => 'b) => 'b",
        "info": ""
      },
      {
        "name": "coerce_opt",
        "kind": "Value",
        "desc": "Js.Opt.t 'a => ('a => Js.Opt.t 'b) => ('a => 'b) => 'b",
        "info": ""
      },
      {
        "name": "date",
        "kind": "Value",
        "desc": "Js.t Js.date_constr",
        "info": ""
      },
      {
        "name": "date_day",
        "kind": "Value",
        "desc": "Js.constr int => int => int => Js.t Js.date",
        "info": ""
      },
      {
        "name": "date_fromTimeValue",
        "kind": "Value",
        "desc": "Js.constr float => Js.t Js.date",
        "info": ""
      },
      {
        "name": "date_hour",
        "kind": "Value",
        "desc": "Js.constr int => int => int => int => Js.t Js.date",
        "info": ""
      },
      {
        "name": "date_min",
        "kind": "Value",
        "desc": "Js.constr int => int => int => int => int => Js.t Js.date",
        "info": ""
      },
      {
        "name": "date_month",
        "kind": "Value",
        "desc": "Js.constr int => int => Js.t Js.date",
        "info": ""
      },
      {
        "name": "date_ms",
        "kind": "Value",
        "desc":
          "Js.constr int => int => int => int => int => int => int => Js.t Js.date",
        "info": ""
      },
      {
        "name": "date_now",
        "kind": "Value",
        "desc": "Js.constr (Js.t Js.date)",
        "info": ""
      },
      {
        "name": "date_sec",
        "kind": "Value",
        "desc":
          "Js.constr int => int => int => int => int => int => Js.t Js.date",
        "info": ""
      },
      {
        "name": "debugger",
        "kind": "Value",
        "desc": "unit => unit",
        "info": ""
      },
      {
        "name": "decodeURI",
        "kind": "Value",
        "desc": "Js.t Js.js_string => Js.t Js.js_string",
        "info": ""
      },
      {
        "name": "decodeURIComponent",
        "kind": "Value",
        "desc": "Js.t Js.js_string => Js.t Js.js_string",
        "info": ""
      },
      {
        "name": "def",
        "kind": "Value",
        "desc": "'a => Js.optdef 'a",
        "info": ""
      },
      {
        "name": "encodeURI",
        "kind": "Value",
        "desc": "Js.t Js.js_string => Js.t Js.js_string",
        "info": ""
      },
      {
        "name": "encodeURIComponent",
        "kind": "Value",
        "desc": "Js.t Js.js_string => Js.t Js.js_string",
        "info": ""
      },
      {
        "name": "error_constr",
        "kind": "Value",
        "desc": "Js.constr Js.t Js.js_string => Js.t Js.error",
        "info": ""
      },
      {
        "name": "escape",
        "kind": "Value",
        "desc": "Js.t Js.js_string => Js.t Js.js_string",
        "info": ""
      },
      {
        "name": "float",
        "kind": "Value",
        "desc": "float => float",
        "info": ""
      },
      {
        "name": "float_of_number",
        "kind": "Value",
        "desc": "Js.t Js.number => float",
        "info": ""
      },
      {
        "name": "instanceof",
        "kind": "Value",
        "desc": "Js.t 'a => Js.constr 'b => bool",
        "info": ""
      },
      { "name": "isNaN", "kind": "Value", "desc": "'a => bool", "info": "" },
      {
        "name": "match_result",
        "kind": "Value",
        "desc": "Js.t Js.match_result_handle => Js.t Js.match_result",
        "info": ""
      },
      { "name": "math", "kind": "Value", "desc": "Js.t Js.math", "info": "" },
      { "name": "null", "kind": "Value", "desc": "Js.opt 'a", "info": "" },
      {
        "name": "number_of_float",
        "kind": "Value",
        "desc": "float => Js.t Js.number",
        "info": ""
      },
      {
        "name": "parseFloat",
        "kind": "Value",
        "desc": "Js.t Js.js_string => float",
        "info": ""
      },
      {
        "name": "parseInt",
        "kind": "Value",
        "desc": "Js.t Js.js_string => int",
        "info": ""
      },
      {
        "name": "raise_js_error",
        "kind": "Value",
        "desc": "Js.t Js.error => 'a",
        "info": ""
      },
      {
        "name": "regExp",
        "kind": "Value",
        "desc": "Js.constr Js.t Js.js_string => Js.t Js.regExp",
        "info": ""
      },
      {
        "name": "regExp_copy",
        "kind": "Value",
        "desc": "Js.constr Js.t Js.regExp => Js.t Js.regExp",
        "info": ""
      },
      {
        "name": "regExp_withFlags",
        "kind": "Value",
        "desc":
          "Js.constr Js.t Js.js_string => Js.t Js.js_string => Js.t Js.regExp",
        "info": ""
      },
      {
        "name": "some",
        "kind": "Value",
        "desc": "'a => Js.opt 'a",
        "info": ""
      },
      {
        "name": "str_array",
        "kind": "Value",
        "desc":
          "Js.t Js.string_array => Js.t (Js.js_array (Js.t Js.js_string))",
        "info": ""
      },
      {
        "name": "string",
        "kind": "Value",
        "desc": "string => Js.t Js.js_string",
        "info": ""
      },
      {
        "name": "string_constr",
        "kind": "Value",
        "desc": "Js.t Js.string_constr",
        "info": ""
      },
      {
        "name": "string_of_error",
        "kind": "Value",
        "desc": "Js.t Js.error => string",
        "info": ""
      },
      {
        "name": "to_array",
        "kind": "Value",
        "desc": "Js.t (Js.js_array 'a) => array 'a",
        "info": ""
      },
      {
        "name": "to_bool",
        "kind": "Value",
        "desc": "Js.t bool => bool",
        "info": ""
      },
      {
        "name": "to_bytestring",
        "kind": "Value",
        "desc": "Js.t Js.js_string => string",
        "info": ""
      },
      {
        "name": "to_float",
        "kind": "Value",
        "desc": "float => float",
        "info": ""
      },
      {
        "name": "to_string",
        "kind": "Value",
        "desc": "Js.t Js.js_string => string",
        "info": ""
      },
      {
        "name": "typeof",
        "kind": "Value",
        "desc": "Js.t 'a => Js.t Js.js_string",
        "info": ""
      },
      {
        "name": "undefined",
        "kind": "Value",
        "desc": "Js.optdef 'a",
        "info": ""
      },
      {
        "name": "unescape",
        "kind": "Value",
        "desc": "Js.t Js.js_string => Js.t Js.js_string",
        "info": ""
      },
      {
        "name": "wrap_callback",
        "kind": "Value",
        "desc": "('a => 'b) => Js.meth_callback 'c 'a => 'b",
        "info": ""
      },
      {
        "name": "wrap_meth_callback",
        "kind": "Value",
        "desc": "('b => 'a) => Js.meth_callback 'b 'a",
        "info": ""
      },
      {
        "name": "#date",
        "kind": "Type",
        "desc": "type #date = #Js.date",
        "info": ""
      },
      {
        "name": "#date_constr",
        "kind": "Type",
        "desc": "type #date_constr = #Js.date_constr",
        "info": ""
      },
      {
        "name": "#error",
        "kind": "Type",
        "desc": "type #error = #Js.error",
        "info": ""
      },
      {
        "name": "#js_array",
        "kind": "Type",
        "desc": "type #js_array 'a = #Js.js_array 'a",
        "info": ""
      },
      {
        "name": "#js_string",
        "kind": "Type",
        "desc": "type #js_string = #Js.js_string",
        "info": ""
      },
      {
        "name": "#json",
        "kind": "Type",
        "desc": "type #json = #Js.json",
        "info": ""
      },
      {
        "name": "#match_result",
        "kind": "Type",
        "desc": "type #match_result = #Js.match_result",
        "info": ""
      },
      {
        "name": "#math",
        "kind": "Type",
        "desc": "type #math = #Js.math",
        "info": ""
      },
      {
        "name": "#number",
        "kind": "Type",
        "desc": "type #number = #Js.number",
        "info": ""
      },
      {
        "name": "#regExp",
        "kind": "Type",
        "desc": "type #regExp = #Js.regExp",
        "info": ""
      },
      {
        "name": "#string_constr",
        "kind": "Type",
        "desc": "type #string_constr = #Js.string_constr",
        "info": ""
      },
      {
        "name": "callback",
        "kind": "Type",
        "desc": "type callback 'a = Js.meth_callback unit 'a",
        "info": ""
      },
      {
        "name": "constr",
        "kind": "Type",
        "desc": "type constr +'a",
        "info": ""
      },
      {
        "name": "date",
        "kind": "Type",
        "desc":
          "type date =\n    < getDate : Js.meth int, getDay : Js.meth int, getFullYear : Js.meth int,\n      getHours : Js.meth int, getMilliseconds : Js.meth int,\n      getMinutes : Js.meth int, getMonth : Js.meth int,\n      getSeconds : Js.meth int, getTime : Js.meth float,\n      getTimezoneOffset : Js.meth int, getUTCDate : Js.meth int,\n      getUTCDay : Js.meth int, getUTCFullYear : Js.meth int,\n      getUTCHours : Js.meth int, getUTCMilliseconds : Js.meth int,\n      getUTCMinutes : Js.meth int, getUTCMonth : Js.meth int,\n      getUTCSeconds : Js.meth int, setDate : int => Js.meth float,\n      setDay : int => Js.meth float, setFullYear : int => Js.meth float,\n      setHours : int => Js.meth float,\n      setMilliseconds : int => Js.meth float,\n      setMinutes : int => Js.meth float, setMonth : int => Js.meth float,\n      setSeconds : int => Js.meth float, setTime : float => Js.meth float,\n      setUTCDate : int => Js.meth float, setUTCDay : int => Js.meth float,\n      setUTCFullYear : int => Js.meth float,\n      setUTCHours : int => Js.meth float,\n      setUTCMilliseconds : int => Js.meth float,\n      setUTCMinutes : int => Js.meth float,\n      setUTCMonth : int => Js.meth float,\n      setUTCSeconds : int => Js.meth float,\n      toDateString : Js.meth (Js.t Js.js_string),\n      toISOString : Js.meth (Js.t Js.js_string),\n      toJSON : 'a. 'a => Js.meth (Js.t Js.js_string),\n      toLocaleDateString : Js.meth (Js.t Js.js_string),\n      toLocaleString : Js.meth (Js.t Js.js_string),\n      toLocaleTimeString : Js.meth (Js.t Js.js_string),\n      toString : Js.meth (Js.t Js.js_string),\n      toTimeString : Js.meth (Js.t Js.js_string),\n      toUTCString : Js.meth (Js.t Js.js_string), valueOf : Js.meth float >",
        "info": ""
      },
      {
        "name": "date_constr",
        "kind": "Type",
        "desc":
          "type date_constr =\n    < _UTC_day : int => int => Js.meth float,\n      _UTC_hour : int => int => int => int => Js.meth float,\n      _UTC_min : int => int => int => int => int => Js.meth float,\n      _UTC_month : int => int => Js.meth float,\n      _UTC_ms : int =>\n                int => int => int => int => int => int => Js.meth float,\n      _UTC_sec : int => int => int => int => int => int => Js.meth float,\n      parse : Js.t Js.js_string => Js.meth float >",
        "info": ""
      },
      {
        "name": "error",
        "kind": "Type",
        "desc":
          "type error =\n    < message : Js.prop (Js.t Js.js_string),\n      name : Js.prop (Js.t Js.js_string),\n      stack : Js.prop (Js.optdef (Js.t Js.js_string)),\n      toString : Js.meth (Js.t Js.js_string) >",
        "info": ""
      },
      {
        "name": "float_prop",
        "kind": "Type",
        "desc": "type float_prop = Js.prop float",
        "info": ""
      },
      {
        "name": "gen_prop",
        "kind": "Type",
        "desc": "type gen_prop +'a",
        "info": ""
      },
      {
        "name": "js_array",
        "kind": "Type",
        "desc":
          "type js_array 'a =\n    < concat : Js.t (Js.js_array 'a) => Js.meth (Js.t (Js.js_array 'a)),\n      every : Js.callback 'a => int => Js.t (Js.js_array 'a) => Js.t bool =>\n              Js.meth (Js.t bool),\n      filter : Js.callback 'a => int => Js.t (Js.js_array 'a) => Js.t bool =>\n               Js.meth (Js.t (Js.js_array 'a)),\n      forEach : Js.callback 'a => int => Js.t (Js.js_array 'a) => unit =>\n                Js.meth unit,\n      join : Js.t Js.js_string => Js.meth (Js.t Js.js_string),\n      length : Js.prop int,\n      map : Js.callback 'a => int => Js.t (Js.js_array 'a) => 'a =>\n            Js.meth (Js.t (Js.js_array 'a)),\n      pop : Js.meth (Js.optdef 'a), push : 'a => Js.meth int,\n      push_2 : 'a => 'a => Js.meth int,\n      push_3 : 'a => 'a => 'a => Js.meth int,\n      push_4 : 'a => 'a => 'a => 'a => Js.meth int,\n      reduce : Js.callback 'a => 'a => int => Js.t (Js.js_array 'a) => 'a =>\n               Js.meth 'a,\n      reduceRight : Js.callback\n                    'a => 'a => int => Js.t (Js.js_array 'a) => 'a =>\n                    Js.meth 'a,\n      reduceRight_init : 'b.\n                           Js.callback\n                           'b => 'a => int => Js.t (Js.js_array 'a) => 'b =>\n                           'b => Js.meth 'b,\n      reduce_init : 'b.\n                      Js.callback\n                      'b => 'a => int => Js.t (Js.js_array 'a) => 'b =>\n                      'b => Js.meth 'b,\n      reverse : Js.meth (Js.t (Js.js_array 'a)),\n      shift : Js.meth (Js.optdef 'a),\n      slice : int => int => Js.meth (Js.t (Js.js_array 'a)),\n      slice_end : int => Js.meth (Js.t (Js.js_array 'a)),\n      some : Js.callback 'a => int => Js.t (Js.js_array 'a) => Js.t bool =>\n             Js.meth (Js.t bool),\n      sort : Js.callback 'a => 'a => float => Js.meth (Js.t (Js.js_array 'a)),\n      sort_asStrings : Js.meth (Js.t (Js.js_array 'a)),\n      splice : int => int => Js.meth (Js.t (Js.js_array 'a)),\n      splice_1 : int => int => 'a => Js.meth (Js.t (Js.js_array 'a)),\n      splice_2 : int => int => 'a => 'a => Js.meth (Js.t (Js.js_array 'a)),\n      splice_3 : int =>\n                 int => 'a => 'a => 'a => Js.meth (Js.t (Js.js_array 'a)),\n      splice_4 : int =>\n                 int =>\n                 'a => 'a => 'a => 'a => Js.meth (Js.t (Js.js_array 'a)),\n      toLocaleString : Js.meth (Js.t Js.js_string),\n      toString : Js.meth (Js.t Js.js_string), unshift : 'a => Js.meth int,\n      unshift_2 : 'a => 'a => Js.meth int,\n      unshift_3 : 'a => 'a => 'a => Js.meth int,\n      unshift_4 : 'a => 'a => 'a => 'a => Js.meth int >",
        "info": ""
      },
      {
        "name": "js_string",
        "kind": "Type",
        "desc":
          "type js_string =\n    < _match : Js.t Js.regExp =>\n               Js.meth (Js.opt (Js.t Js.match_result_handle)),\n      charAt : int => Js.meth (Js.t Js.js_string),\n      charCodeAt : int => Js.meth float,\n      concat : Js.t Js.js_string => Js.meth (Js.t Js.js_string),\n      concat_2 : Js.t Js.js_string =>\n                 Js.t Js.js_string => Js.meth (Js.t Js.js_string),\n      concat_3 : Js.t Js.js_string =>\n                 Js.t Js.js_string =>\n                 Js.t Js.js_string => Js.meth (Js.t Js.js_string),\n      concat_4 : Js.t Js.js_string =>\n                 Js.t Js.js_string =>\n                 Js.t Js.js_string =>\n                 Js.t Js.js_string => Js.meth (Js.t Js.js_string),\n      indexOf : Js.t Js.js_string => Js.meth int,\n      indexOf_from : Js.t Js.js_string => int => Js.meth int,\n      lastIndexOf : Js.t Js.js_string => Js.meth int,\n      lastIndexOf_from : Js.t Js.js_string => int => Js.meth int,\n      length : Js.readonly_prop int,\n      localeCompare : Js.t Js.js_string => Js.meth float,\n      replace : Js.t Js.regExp =>\n                Js.t Js.js_string => Js.meth (Js.t Js.js_string),\n      replace_string : Js.t Js.js_string =>\n                       Js.t Js.js_string => Js.meth (Js.t Js.js_string),\n      search : Js.t Js.regExp => Js.meth int,\n      slice : int => int => Js.meth (Js.t Js.js_string),\n      slice_end : int => Js.meth (Js.t Js.js_string),\n      split : Js.t Js.js_string => Js.meth (Js.t Js.string_array),\n      split_limited : Js.t Js.js_string =>\n                      int => Js.meth (Js.t Js.string_array),\n      split_regExp : Js.t Js.regExp => Js.meth (Js.t Js.string_array),\n      split_regExpLimited : Js.t Js.regExp =>\n                            int => Js.meth (Js.t Js.string_array),\n      substring : int => int => Js.meth (Js.t Js.js_string),\n      substring_toEnd : int => Js.meth (Js.t Js.js_string),\n      toLocaleLowerCase : Js.meth (Js.t Js.js_string),\n      toLocaleUpperCase : Js.meth (Js.t Js.js_string),\n      toLowerCase : Js.meth (Js.t Js.js_string),\n      toString : Js.meth (Js.t Js.js_string),\n      toUpperCase : Js.meth (Js.t Js.js_string),\n      trim : Js.meth (Js.t Js.js_string),\n      valueOf : Js.meth (Js.t Js.js_string) >",
        "info": ""
      },
      {
        "name": "json",
        "kind": "Type",
        "desc":
          "type json =\n    < parse : 'a. Js.t Js.js_string => Js.meth 'a,\n      stringify : 'a. 'a => Js.meth (Js.t Js.js_string) >",
        "info": ""
      },
      {
        "name": "match_result",
        "kind": "Type",
        "desc":
          "type match_result =\n    < concat : Js.t (Js.js_array (Js.t Js.js_string)) =>\n               Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      every : Js.callback\n              Js.t Js.js_string =>\n              int => Js.t (Js.js_array (Js.t Js.js_string)) => Js.t bool =>\n              Js.meth (Js.t bool),\n      filter : Js.callback\n               Js.t Js.js_string =>\n               int => Js.t (Js.js_array (Js.t Js.js_string)) => Js.t bool =>\n               Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      forEach : Js.callback\n                Js.t Js.js_string =>\n                int => Js.t (Js.js_array (Js.t Js.js_string)) => unit =>\n                Js.meth unit,\n      index : Js.readonly_prop int,\n      input : Js.readonly_prop (Js.t Js.js_string),\n      join : Js.t Js.js_string => Js.meth (Js.t Js.js_string),\n      length : Js.prop int,\n      map : Js.callback\n            Js.t Js.js_string =>\n            int =>\n            Js.t (Js.js_array (Js.t Js.js_string)) => Js.t Js.js_string =>\n            Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      pop : Js.meth (Js.optdef (Js.t Js.js_string)),\n      push : Js.t Js.js_string => Js.meth int,\n      push_2 : Js.t Js.js_string => Js.t Js.js_string => Js.meth int,\n      push_3 : Js.t Js.js_string =>\n               Js.t Js.js_string => Js.t Js.js_string => Js.meth int,\n      push_4 : Js.t Js.js_string =>\n               Js.t Js.js_string =>\n               Js.t Js.js_string => Js.t Js.js_string => Js.meth int,\n      reduce : Js.callback\n               Js.t Js.js_string =>\n               Js.t Js.js_string =>\n               int =>\n               Js.t (Js.js_array (Js.t Js.js_string)) => Js.t Js.js_string =>\n               Js.meth (Js.t Js.js_string),\n      reduceRight : Js.callback\n                    Js.t Js.js_string =>\n                    Js.t Js.js_string =>\n                    int =>\n                    Js.t (Js.js_array (Js.t Js.js_string)) =>\n                    Js.t Js.js_string => Js.meth (Js.t Js.js_string),\n      reduceRight_init : 'b.\n                           Js.callback\n                           'b =>\n                           Js.t Js.js_string =>\n                           int =>\n                           Js.t (Js.js_array (Js.t Js.js_string)) => 'b =>\n                           'b => Js.meth 'b,\n      reduce_init : 'b.\n                      Js.callback\n                      'b =>\n                      Js.t Js.js_string =>\n                      int => Js.t (Js.js_array (Js.t Js.js_string)) => 'b =>\n                      'b => Js.meth 'b,\n      reverse : Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      shift : Js.meth (Js.optdef (Js.t Js.js_string)),\n      slice : int => int => Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      slice_end : int => Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      some : Js.callback\n             Js.t Js.js_string =>\n             int => Js.t (Js.js_array (Js.t Js.js_string)) => Js.t bool =>\n             Js.meth (Js.t bool),\n      sort : Js.callback Js.t Js.js_string => Js.t Js.js_string => float =>\n             Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      sort_asStrings : Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      splice : int => int => Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      splice_1 : int =>\n                 int =>\n                 Js.t Js.js_string =>\n                 Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      splice_2 : int =>\n                 int =>\n                 Js.t Js.js_string =>\n                 Js.t Js.js_string =>\n                 Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      splice_3 : int =>\n                 int =>\n                 Js.t Js.js_string =>\n                 Js.t Js.js_string =>\n                 Js.t Js.js_string =>\n                 Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      splice_4 : int =>\n                 int =>\n                 Js.t Js.js_string =>\n                 Js.t Js.js_string =>\n                 Js.t Js.js_string =>\n                 Js.t Js.js_string =>\n                 Js.meth (Js.t (Js.js_array (Js.t Js.js_string))),\n      toLocaleString : Js.meth (Js.t Js.js_string),\n      toString : Js.meth (Js.t Js.js_string),\n      unshift : Js.t Js.js_string => Js.meth int,\n      unshift_2 : Js.t Js.js_string => Js.t Js.js_string => Js.meth int,\n      unshift_3 : Js.t Js.js_string =>\n                  Js.t Js.js_string => Js.t Js.js_string => Js.meth int,\n      unshift_4 : Js.t Js.js_string =>\n                  Js.t Js.js_string =>\n                  Js.t Js.js_string => Js.t Js.js_string => Js.meth int >",
        "info": ""
      },
      {
        "name": "match_result_handle",
        "kind": "Type",
        "desc": "type match_result_handle",
        "info": ""
      },
      {
        "name": "math",
        "kind": "Type",
        "desc":
          "type math =\n    < _E : Js.readonly_prop float, _LN10 : Js.readonly_prop float,\n      _LN2 : Js.readonly_prop float, _LOG10E : Js.readonly_prop float,\n      _LOG2E : Js.readonly_prop float, _PI : Js.readonly_prop float,\n      _SQRT1_2_ : Js.readonly_prop float, _SQRT2 : Js.readonly_prop float,\n      abs : float => Js.meth float, acos : float => Js.meth float,\n      asin : float => Js.meth float, atan : float => Js.meth float,\n      atan2 : float => float => Js.meth float, ceil : float => Js.meth float,\n      cos : float => Js.meth float, exp : float => Js.meth float,\n      floor : float => Js.meth float, log : float => Js.meth float,\n      max : float => float => Js.meth float,\n      max_3 : float => float => float => Js.meth float,\n      max_4 : float => float => float => float => Js.meth float,\n      min : float => float => Js.meth float,\n      min_3 : float => float => float => Js.meth float,\n      min_4 : float => float => float => float => Js.meth float,\n      pow : float => float => Js.meth float, random : Js.meth float,\n      round : float => Js.meth float, sin : float => Js.meth float,\n      sqrt : float => Js.meth float, tan : float => Js.meth float >",
        "info": ""
      },
      { "name": "meth", "kind": "Type", "desc": "type meth +'a", "info": "" },
      {
        "name": "meth_callback",
        "kind": "Type",
        "desc": "type meth_callback -'a +'b",
        "info": ""
      },
      {
        "name": "number",
        "kind": "Type",
        "desc":
          "type number =\n    < toExponential : Js.meth (Js.t Js.js_string),\n      toExponential_digits : int => Js.meth (Js.t Js.js_string),\n      toFixed : int => Js.meth (Js.t Js.js_string),\n      toLocaleString : Js.meth (Js.t Js.js_string),\n      toPrecision : int => Js.meth (Js.t Js.js_string),\n      toString : Js.meth (Js.t Js.js_string),\n      toString_radix : int => Js.meth (Js.t Js.js_string) >",
        "info": ""
      },
      { "name": "opt", "kind": "Type", "desc": "type opt +'a", "info": "" },
      {
        "name": "optdef",
        "kind": "Type",
        "desc": "type optdef +'a",
        "info": ""
      },
      {
        "name": "optdef_prop",
        "kind": "Type",
        "desc":
          "type optdef_prop 'a = Js.gen_prop < get : Js.optdef 'a, set : 'a => unit >",
        "info": ""
      },
      {
        "name": "prop",
        "kind": "Type",
        "desc": "type prop 'a = Js.gen_prop < get : 'a, set : 'a => unit >",
        "info": ""
      },
      {
        "name": "readonly_prop",
        "kind": "Type",
        "desc": "type readonly_prop 'a = Js.gen_prop < get : 'a >",
        "info": ""
      },
      {
        "name": "regExp",
        "kind": "Type",
        "desc":
          "type regExp =\n    < exec : Js.t Js.js_string =>\n             Js.meth (Js.opt (Js.t Js.match_result_handle)),\n      global : Js.readonly_prop (Js.t bool),\n      ignoreCase : Js.readonly_prop (Js.t bool), lastIndex : Js.prop int,\n      multiline : Js.readonly_prop (Js.t bool),\n      source : Js.readonly_prop (Js.t Js.js_string),\n      test : Js.t Js.js_string => Js.meth (Js.t bool),\n      toString : Js.meth (Js.t Js.js_string) >",
        "info": ""
      },
      {
        "name": "string_array",
        "kind": "Type",
        "desc": "type string_array",
        "info": ""
      },
      {
        "name": "string_constr",
        "kind": "Type",
        "desc":
          "type string_constr = < fromCharCode : int => Js.meth (Js.t Js.js_string) >",
        "info": ""
      },
      { "name": "t", "kind": "Type", "desc": "type t +'a", "info": "" },
      {
        "name": "writeonly_prop",
        "kind": "Type",
        "desc": "type writeonly_prop 'a = Js.gen_prop < set : 'a => unit >",
        "info": ""
      },
      { "name": "Opt", "kind": "Module", "desc": "", "info": "" },
      { "name": "Optdef", "kind": "Module", "desc": "", "info": "" },
      { "name": "Unsafe", "kind": "Module", "desc": "", "info": "" },
      { "name": "OPT", "kind": "Signature", "desc": "", "info": "" }
    ],
    "context": null
  }
]
# 0.05 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.05 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.05 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\nJs.\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.05 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.05 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.05 frontend - output
[ "return", true ]
# 0.05 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.05 frontend - output
[
  "return",
  [
    {
      "start": { "line": 13, "col": 0 },
      "end": { "line": 13, "col": 3 },
      "type": "type",
      "sub": [],
      "valid": true,
      "message": "Invalid module item"
    }
  ]
]
# 0.05 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.05 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.05 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.05 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.05 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.05 frontend - output
[ "return", true ]
# 0.05 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 13, "col": 21 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.05 frontend - output
[
  "return",
  [
    {
      "start": { "line": 13, "col": 4 },
      "end": { "line": 13, "col": 26 },
      "type": "'a",
      "tail": "no"
    }
  ]
]
# 0.06 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.06 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.06 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.06 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.06 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.06 frontend - output
[ "return", true ]
# 0.06 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.06 frontend - output
[ "return", [] ]
# 0.06 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.06 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.06 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.06 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.06 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.06 frontend - output
[ "return", true ]
# 0.06 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 13, "col": 4 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.06 track_definition - inspect_context
current node is: pattern ([13,354+4]..[13,354+26])
  Ppat_var "findNearestMerlinFile'/1416"

# 0.06 track_definition - from_string
already at origin, doing nothing
# 0.06 frontend - output
[ "return", "Already at definition point" ]
# 0.06 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.06 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.07 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.07 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.07 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.07 frontend - output
[ "return", true ]
# 0.07 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 13, "col": 16 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.07 frontend - output
[
  "return",
  [
    {
      "start": { "line": 13, "col": 4 },
      "end": { "line": 13, "col": 26 },
      "type": "'a",
      "tail": "no"
    }
  ]
]
# 0.07 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.07 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.07 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.07 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.07 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.07 frontend - output
[ "return", true ]
# 0.07 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 113, "col": 9 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.07 track_definition - from_string
looking for the source of 'Js.Unsafe' (prioritizing .ml files)
# 0.07 track_definition - lookup
lookup in value namespace
# 0.07 track_definition - lookup
lookup in constructor namespace
# 0.07 track_definition - lookup
lookup in module namespace
# 0.07 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'Js.Unsafe'
# 0.07 locate - Typedtrie.find
cursor is in a leaf, so we look only before the leaf
# 0.07 track_definition - locate
resolves to Js.Unsafe
# 0.07 track_definition - Fallback.setopt
None
# 0.07 track_definition - from_path '%s'
Js.Unsafe
# 0.07 track_definition - restore_loadpath
Restored load path
# 0.07 track_definition - from_path
failed to locate the cmt[i] of 'Js'
# 0.07 frontend - output
[
  "return",
  "Needed cmt file of module 'Js' to locate 'Js.Unsafe' but it is not present"
]
# 0.07 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.07 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.07 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.07 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.07 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.07 frontend - output
[ "return", true ]
# 0.07 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 113, "col": 12 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.07 frontend - output
[
  "return",
  [
    {
      "start": { "line": 113, "col": 6 },
      "end": { "line": 113, "col": 15 },
      "type":
        "{\n  type any;\n  external inject : 'a => any = \"%identity\";\n  external coerce : Js.t 'a => Js.t 'b = \"%identity\";\n  external get : 'a => 'b => 'c = \"caml_js_get\";\n  external set : 'a => 'b => 'c => unit = \"caml_js_set\";\n  external delete : 'a => 'b => unit = \"caml_js_delete\";\n  external call : 'a => 'b => array any => 'c = \"caml_js_call\";\n  external fun_call : 'a => array any => 'b = \"caml_js_fun_call\";\n  external meth_call : 'a => string => array any => 'b = \"caml_js_meth_call\";\n  external new_obj : 'a => array any => 'b = \"caml_js_new\";\n  external obj : array (string, any) => 'a = \"caml_js_object\";\n  external pure_expr : (unit => 'a) => 'a = \"caml_js_pure_expr\";\n  external eval_string : string => 'a = \"caml_js_eval_string\";\n  external js_expr : string => 'a = \"caml_js_expr\";\n  external pure_js_expr : string => 'a = \"caml_pure_js_expr\";\n  let global : Js.t < .. >;\n  external callback : ('a => 'b) => Js.meth_callback 'c 'a => 'b\n    = \"%identity\";\n  external meth_callback : ('b => 'a) => Js.meth_callback 'b 'a\n    = \"caml_js_wrap_meth_callback_unsafe\";\n  external variable : string => 'a = \"caml_js_var\";\n}",
      "tail": "no"
    },
    {
      "start": { "line": 113, "col": 6 },
      "end": { "line": 113, "col": 22 },
      "type": "Js.t Js.js_string => Js.Unsafe.any",
      "tail": "no"
    },
    {
      "start": { "line": 113, "col": 6 },
      "end": { "line": 113, "col": 47 },
      "type": "Js.Unsafe.any",
      "tail": "no"
    },
    {
      "start": { "line": 112, "col": 4 },
      "end": { "line": 117, "col": 6 },
      "type": "array Js.Unsafe.any",
      "tail": "no"
    },
    {
      "start": { "line": 110, "col": 2 },
      "end": { "line": 117, "col": 6 },
      "type": "'a",
      "tail": "call"
    },
    {
      "start": { "line": 109, "col": 81 },
      "end": { "line": 117, "col": 6 },
      "type": "dotMerlinPath::string => 'a",
      "tail": "position"
    },
    {
      "start": { "line": 109, "col": 56 },
      "end": { "line": 117, "col": 6 },
      "type": "merlinFlags::string => dotMerlinPath::string => 'a",
      "tail": "position"
    },
    {
      "start": { "line": 109, "col": 29 },
      "end": { "line": 117, "col": 6 },
      "type":
        "pathToMerlin::string => merlinFlags::string => dotMerlinPath::string => 'a",
      "tail": "no"
    }
  ]
]
# 0.07 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.07 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.07 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nlet startedMerlin: ref (option Js.Unsafe.any) = {contents: None};\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\n/* This and the subsequent big js blocks are copied over from Nuclide. More convenient for now. */\nlet findNearestMerlinFile' = Js.Unsafe.js_expr {|\n  function findNearestMerlinFile(beginAtFilePath) {\n    var path = require('path');\n    var fs = require('fs');\n    var fileDir = path.dirname(beginAtFilePath);\n    var currentPath = path.resolve(fileDir);\n    do {\n      var fileToFind = path.join(currentPath, '.merlin');\n      var hasFile = fs.existsSync(fileToFind);\n      if (hasFile) {\n        return path.dirname(currentPath);\n      }\n\n      if (path.dirname(currentPath) === currentPath) {\n        // Bail\n        return '.';\n      }\n      currentPath = path.dirname(currentPath);\n    } while (true);\n  }\n|};\n\nlet findNearestMerlinFile beginAtFilePath::path => {\n  let result = Js.Unsafe.fun_call findNearestMerlinFile' [|Js.Unsafe.inject (Js.string path)|];\n  Js.to_string result\n};\n\nlet createMerlinReaderFnOnce' = Js.Unsafe.js_expr {|\n  function(ocamlMerlinPath, ocamlMerlinFlags, dotMerlinDir, fixedEnv) {\n    var spawn = require('child_process').spawn;\n    // To split while stripping out any leading/trailing space, we match on all\n    // *non*-whitespace.\n    var items = ocamlMerlinFlags === '' ? [] : ocamlMerlinFlags.split(/\\s+/);\n    var merlinProcess = spawn(ocamlMerlinPath, items, {cwd: dotMerlinDir, env: fixedEnv});\n    merlinProcess.stderr.on('data', function(d) {\n      console.error('Ocamlmerlin: something wrong happened:');\n      console.error(d.toString());\n    });\n\n    merlinProcess.stdout.on('close', function(d) {\n      console.error('Ocamlmerlin: closed.');\n    });\n\n    var cmdQueue = [];\n    var hasStartedReading = false;\n\n    var readline = require('readline');\n    var reader = readline.createInterface({\n      input: merlinProcess.stdout,\n      terminal: false,\n    });\n\n    return function(cmd, resolve, reject) {\n      cmdQueue.push([resolve, reject]);\n\n      if (!hasStartedReading) {\n        hasStartedReading = true;\n        reader.on('line', function(line) {\n          var response;\n          try {\n            response = JSON.parse(line);\n          } catch (err) {\n            response = null;\n          }\n          var resolveReject = cmdQueue.shift();\n          var resolve = resolveReject[0];\n          var reject = resolveReject[1];\n\n          if (!response || !Array.isArray(response) || response.length !== 2) {\n            reject(new Error('Unexpected ocamlmerlin output format: ' + line));\n            return;\n          }\n\n          var status = response[0];\n          var content = response[1];\n\n          var errorResponses = {\n            'failure': true,\n            'error': true,\n            'exception': true,\n          };\n\n          if (errorResponses[status]) {\n            reject(new Error('Ocamlmerlin returned an error: ' + line));\n            return;\n          }\n\n          resolve(content);\n        });\n      }\n\n      merlinProcess.stdin.write(JSON.stringify(cmd));\n    };\n  }\n|};\n\nlet createMerlinReaderFnOnce pathToMerlin::pathToMerlin merlinFlags::merlinFlags dotMerlinPath::dotMerlinPath =>\n  Js.Unsafe.fun_call\n    createMerlinReaderFnOnce'\n    [|\n      Js.Unsafe.inject (Js.string pathToMerlin),\n      Js.Unsafe.inject (Js.string merlinFlags),\n      Js.Unsafe.inject (Js.string dotMerlinPath),\n      Js.Unsafe.inject fixedEnv\n    |];\n\nlet startMerlinProcess path::path =>\n  switch startedMerlin.contents {\n  | Some readerFn => ()\n  | None => {\n      let atomReasonPathToMerlin = Atom.Config.get \"AtomReason.pathToMerlin\";\n      let atomReasonMerlinFlags = Atom.Config.get \"AtomReason.merlinFlags\";\n      let atomReasonMerlinLogFile = Atom.Config.get \"AtomReason.merlinLogFile\";\n      switch atomReasonMerlinLogFile {\n      | JsonString \"\" => ()\n      | JsonString s => Atom.Env.setEnvVar \"MERLIN_LOG\" s\n      | _ => ()\n      };\n      let readerFn =\n        createMerlinReaderFnOnce\n          pathToMerlin::(Atom.JsonValue.unsafeExtractString atomReasonPathToMerlin)\n          merlinFlags::(Atom.JsonValue.unsafeExtractString atomReasonMerlinFlags)\n          dotMerlinPath::(findNearestMerlinFile beginAtFilePath::path);\n      startedMerlin.contents = Some readerFn\n    }\n  };\n\nlet readOneLine cmd::cmd resolve reject =>\n  switch startedMerlin.contents {\n  | None => raise Not_found\n  | Some readerFn =>\n      Js.Unsafe.fun_call\n        readerFn\n        [|\n          Js.Unsafe.inject cmd,\n          Js.Unsafe.inject (Js.wrap_callback resolve),\n          Js.Unsafe.inject (Js.wrap_callback reject)\n        |]\n  };\n\n/* contextify is important for avoiding different buffers calling the backing merlin at the same time. */\n/* https://github.com/the-lambda-church/merlin/blob/d98a08d318ca14d9c702bbd6eeadbb762d325ce7/doc/dev/PROTOCOL.md#contextual-commands */\nlet contextify query::query path::path => Js.Unsafe.obj [|\n  (\"query\", Js.Unsafe.inject query),\n  (\"context\", Js.Unsafe.inject (Js.array [|Js.string \"auto\", Js.string path|]))\n|];\n\nlet prepareCommand text::text path::path query::query resolve reject => {\n  startMerlinProcess path;\n  /* These two commands should be run before every main command. */\n  readOneLine\n    cmd::(\n      contextify\n        /* The protocol command tells Merlin which API version we want to use. (2 for us) */\n        query::(\n          Js.array [|\n            Js.Unsafe.inject (Js.string \"protocol\"),\n            Js.Unsafe.inject (Js.string \"version\"),\n            Js.Unsafe.inject (Js.number_of_float 2.)\n          |]\n        )\n        path::path\n    )\n    (\n      fun _ =>\n        readOneLine\n          cmd::(\n            contextify\n              /* The tell command allows us to synchronize our text with Merlin's internal buffer. */\n              query::(Js.array [|Js.string \"tell\", Js.string \"start\", Js.string \"end\", Js.string text|])\n              path::path\n          )\n          (fun _ => readOneLine cmd::(contextify query::query path::path) resolve reject)\n          reject\n    )\n    reject\n};\n\nlet positionToJsMerlinPosition (line, col) => Js.Unsafe.obj [|\n  /* lines (rows) are 1-based for merlin, not 0-based, like for Atom */\n  (\"line\", Js.Unsafe.inject (Js.number_of_float (float_of_int (line + 1)))),\n  (\"col\", Js.Unsafe.inject (Js.number_of_float (float_of_int col)))\n|];\n\n/* Actual merlin commands we'll use. */\nlet getTypeHint path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"type\"),\n        Js.Unsafe.inject (Js.string \"enclosing\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getAutoCompleteSuggestions path::path text::text position::position prefix::prefix resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"complete\"),\n        Js.Unsafe.inject (Js.string \"prefix\"),\n        Js.Unsafe.inject (Js.string prefix),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n\nlet getDiagnostics path::path text::text resolve reject =>\n  prepareCommand\n    text::text path::path query::(Js.array [|Js.Unsafe.inject (Js.string \"errors\")|]) resolve reject;\n\n/* TODO: put this logic into reason and somewhere else. */\nlet normalizeLocateCommandResult' = Js.Unsafe.js_expr {|\n  function(o, path) {\n    if (typeof o === \"string\") {\n      return o\n    }\n    if (o.file == null) {\n      return {\n        file: path,\n\n        pos: o.pos,\n      };\n    }\n    return o;\n  }\n|};\n\nlet normalizeLocateCommandResult o path =>\n  Js.Unsafe.fun_call normalizeLocateCommandResult' [|o, Js.Unsafe.inject (Js.string path)|];\n\nlet locate path::path text::text extension::extension position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"locate\"),\n        Js.Unsafe.inject (Js.string \"\"),\n        Js.Unsafe.inject (Js.string extension),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    (fun successResult => resolve (normalizeLocateCommandResult successResult path))\n    reject;\n\nlet getOccurrences path::path text::text position::position resolve reject =>\n  prepareCommand\n    text::text\n    path::path\n    query::(\n      Js.array [|\n        Js.Unsafe.inject (Js.string \"occurrences\"),\n        Js.Unsafe.inject (Js.string \"ident\"),\n        Js.Unsafe.inject (Js.string \"at\"),\n        Js.Unsafe.inject (positionToJsMerlinPosition position)\n      |]\n    )\n    resolve\n    reject;\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.08 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.08 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.08 frontend - output
[ "return", true ]
# 0.08 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 182, "col": 87 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re"
  ]
}
# 0.08 frontend - output
[
  "return",
  [
    {
      "start": { "line": 182, "col": 87 },
      "end": { "line": 182, "col": 89 },
      "type":
        "{\n  type opt +'a;\n  type optdef +'a;\n  let null : opt 'a;\n  let some : 'a => opt 'a;\n  let undefined : optdef 'a;\n  let def : 'a => optdef 'a;\n  module type OPT =\n    {\n      type t 'a;\n      let empty : t 'a;\n      let return : 'a => t 'a;\n      let map : t 'a => ('a => 'b) => t 'b;\n      let bind : t 'a => ('a => t 'b) => t 'b;\n      let test : t 'a => bool;\n      let iter : t 'a => ('a => unit) => unit;\n      let case : t 'a => (unit => 'b) => ('a => 'b) => 'b;\n      let get : t 'a => (unit => 'a) => 'a;\n      let option : option 'a => t 'a;\n      let to_option : t 'a => option 'a;\n    };\n  module Opt :\n    {\n      type t 'a = opt 'a;\n      let empty : t 'a;\n      let return : 'a => t 'a;\n      let map : t 'a => ('a => 'b) => t 'b;\n      let bind : t 'a => ('a => t 'b) => t 'b;\n      let test : t 'a => bool;\n      let iter : t 'a => ('a => unit) => unit;\n      let case : t 'a => (unit => 'b) => ('a => 'b) => 'b;\n      let get : t 'a => (unit => 'a) => 'a;\n      let option : option 'a => t 'a;\n      let to_option : t 'a => option 'a;\n    };\n  module Optdef :\n    {\n      type t 'a = optdef 'a;\n      let empty : t 'a;\n      let return : 'a => t 'a;\n      let map : t 'a => ('a => 'b) => t 'b;\n      let bind : t 'a => ('a => t 'b) => t 'b;\n      let test : t 'a => bool;\n      let iter : t 'a => ('a => unit) => unit;\n      let case : t 'a => (unit => 'b) => ('a => 'b) => 'b;\n      let get : t 'a => (unit => 'a) => 'a;\n      let option : option 'a => t 'a;\n      let to_option : t 'a => option 'a;\n    };\n  type t +'a;\n  type meth +'a;\n  type gen_prop +'a;\n  type readonly_prop 'a = gen_prop < get : 'a >;\n  type writeonly_prop 'a = gen_prop < set : 'a => unit >;\n  type prop 'a = gen_prop < get : 'a, set : 'a => unit >;\n  type optdef_prop 'a = gen_prop < get : optdef 'a, set : 'a => unit >;\n  type constr +'a;\n  type meth_callback -'a +'b;\n  type callback 'a = meth_callback unit 'a;\n  external wrap_callback : ('a => 'b) => meth_callback 'c 'a => 'b\n    = \"caml_js_wrap_callback\";\n  external wrap_meth_callback : ('b => 'a) => meth_callback 'b 'a\n    = \"caml_js_wrap_meth_callback\";\n  let _true : t bool;\n  let _false : t bool;\n  type match_result_handle;\n  type string_array;\n  class type js_string =\n    {\n      method _match : t regExp => meth (opt (t match_result_handle));\n      method charAt : int => meth (t js_string);\n      method charCodeAt : int => meth float;\n      method concat : t js_string => meth (t js_string);\n      method concat_2 : t js_string => t js_string => meth (t js_string);\n      method concat_3 :\n        t js_string => t js_string => t js_string => meth (t js_string);\n      method concat_4 :\n        t js_string =>\n        t js_string => t js_string => t js_string => meth (t js_string);\n      method indexOf : t js_string => meth int;\n      method indexOf_from : t js_string => int => meth int;\n      method lastIndexOf : t js_string => meth int;\n      method lastIndexOf_from : t js_string => int => meth int;\n      method length : readonly_prop int;\n      method localeCompare : t js_string => meth float;\n      method replace : t regExp => t js_string => meth (t js_string);\n      method replace_string :\n        t js_string => t js_string => meth (t js_string);\n      method search : t regExp => meth int;\n      method slice : int => int => meth (t js_string);\n      method slice_end : int => meth (t js_string);\n      method split : t js_string => meth (t string_array);\n      method split_limited : t js_string => int => meth (t string_array);\n      method split_regExp : t regExp => meth (t string_array);\n      method split_regExpLimited : t regExp => int => meth (t string_array);\n      method substring : int => int => meth (t js_string);\n      method substring_toEnd : int => meth (t js_string);\n      method toLocaleLowerCase : meth (t js_string);\n      method toLocaleUpperCase : meth (t js_string);\n      method toLowerCase : meth (t js_string);\n      method toString : meth (t js_string);\n      method toUpperCase : meth (t js_string);\n      method trim : meth (t js_string);\n      method valueOf : meth (t js_string)\n    }\n  and regExp =\n    {\n      method exec : t js_string => meth (opt (t match_result_handle));\n      method global : readonly_prop (t bool);\n      method ignoreCase : readonly_prop (t bool);\n      method lastIndex : prop int;\n      method multiline : readonly_prop (t bool);\n      method source : readonly_prop (t js_string);\n      method test : t js_string => meth (t bool);\n      method toString : meth (t js_string)\n    };\n  class type string_constr =\n    { method fromCharCode : int => meth (t js_string) };\n  let string_constr : t string_constr;\n  let regExp : constr t js_string => t regExp;\n  let regExp_withFlags : constr t js_string => t js_string => t regExp;\n  let regExp_copy : constr t regExp => t regExp;\n  class type js_array 'a =\n    {\n      method concat : t (js_array 'a) => meth (t (js_array 'a));\n      method every :\n        callback 'a => int => t (js_array 'a) => t bool => meth (t bool);\n      method filter :\n        callback 'a => int => t (js_array 'a) => t bool =>\n        meth (t (js_array 'a));\n      method forEach :\n        callback 'a => int => t (js_array 'a) => unit => meth unit;\n      method join : t js_string => meth (t js_string);\n      method length : prop int;\n      method map :\n        callback 'a => int => t (js_array 'a) => 'a => meth (t (js_array 'a));\n      method pop : meth (optdef 'a);\n      method push : 'a => meth int;\n      method push_2 : 'a => 'a => meth int;\n      method push_3 : 'a => 'a => 'a => meth int;\n      method push_4 : 'a => 'a => 'a => 'a => meth int;\n      method reduce :\n        callback 'a => 'a => int => t (js_array 'a) => 'a => meth 'a;\n      method reduceRight :\n        callback 'a => 'a => int => t (js_array 'a) => 'a => meth 'a;\n      method reduceRight_init :\n        callback 'b => 'a => int => t (js_array 'a) => 'b => 'b => meth 'b;\n      method reduce_init :\n        callback 'b => 'a => int => t (js_array 'a) => 'b => 'b => meth 'b;\n      method reverse : meth (t (js_array 'a));\n      method shift : meth (optdef 'a);\n      method slice : int => int => meth (t (js_array 'a));\n      method slice_end : int => meth (t (js_array 'a));\n      method some :\n        callback 'a => int => t (js_array 'a) => t bool => meth (t bool);\n      method sort : callback 'a => 'a => float => meth (t (js_array 'a));\n      method sort_asStrings : meth (t (js_array 'a));\n      method splice : int => int => meth (t (js_array 'a));\n      method splice_1 : int => int => 'a => meth (t (js_array 'a));\n      method splice_2 : int => int => 'a => 'a => meth (t (js_array 'a));\n      method splice_3 :\n        int => int => 'a => 'a => 'a => meth (t (js_array 'a));\n      method splice_4 :\n        int => int => 'a => 'a => 'a => 'a => meth (t (js_array 'a));\n      method toLocaleString : meth (t js_string);\n      method toString : meth (t js_string);\n      method unshift : 'a => meth int;\n      method unshift_2 : 'a => 'a => meth int;\n      method unshift_3 : 'a => 'a => 'a => meth int;\n      method unshift_4 : 'a => 'a => 'a => 'a => meth int\n    };\n  let array_empty : constr (t (js_array 'a));\n  let array_length : constr int => t (js_array 'a);\n  let array_get : t #js_array 'a => int => optdef 'a;\n  let array_set : t #js_array 'a => int => 'a => unit;\n  let array_map : ('a => 'b) => t #js_array 'a => t #js_array 'b;\n  let array_mapi : (int => 'a => 'b) => t #js_array 'a => t #js_array 'b;\n  class type match_result =\n    {\n      method concat :\n        t (js_array (t js_string)) => meth (t (js_array (t js_string)));\n      method every :\n        callback t js_string => int => t (js_array (t js_string)) => t bool =>\n        meth (t bool);\n      method filter :\n        callback t js_string => int => t (js_array (t js_string)) => t bool =>\n        meth (t (js_array (t js_string)));\n      method forEach :\n        callback t js_string => int => t (js_array (t js_string)) => unit =>\n        meth unit;\n      method index : readonly_prop int;\n      method input : readonly_prop (t js_string);\n      method join : t js_string => meth (t js_string);\n      method length : prop int;\n      method map :\n        callback\n        t js_string => int => t (js_array (t js_string)) => t js_string =>\n        meth (t (js_array (t js_string)));\n      method pop : meth (optdef (t js_string));\n      method push : t js_string => meth int;\n      method push_2 : t js_string => t js_string => meth int;\n      method push_3 : t js_string => t js_string => t js_string => meth int;\n      method push_4 :\n        t js_string => t js_string => t js_string => t js_string => meth int;\n      method reduce :\n        callback\n        t js_string =>\n        t js_string => int => t (js_array (t js_string)) => t js_string =>\n        meth (t js_string);\n      method reduceRight :\n        callback\n        t js_string =>\n        t js_string => int => t (js_array (t js_string)) => t js_string =>\n        meth (t js_string);\n      method reduceRight_init :\n        callback 'b => t js_string => int => t (js_array (t js_string)) => 'b =>\n        'b => meth 'b;\n      method reduce_init :\n        callback 'b => t js_string => int => t (js_array (t js_string)) => 'b =>\n        'b => meth 'b;\n      method reverse : meth (t (js_array (t js_string)));\n      method shift : meth (optdef (t js_string));\n      method slice : int => int => meth (t (js_array (t js_string)));\n      method slice_end : int => meth (t (js_array (t js_string)));\n      method some :\n        callback t js_string => int => t (js_array (t js_string)) => t bool =>\n        meth (t bool);\n      method sort :\n        callback t js_string => t js_string => float =>\n        meth (t (js_array (t js_string)));\n      method sort_asStrings : meth (t (js_array (t js_string)));\n      method splice : int => int => meth (t (js_array (t js_string)));\n      method splice_1 :\n        int => int => t js_string => meth (t (js_array (t js_string)));\n      method splice_2 :\n        int =>\n        int =>\n        t js_string => t js_string => meth (t (js_array (t js_string)));\n      method splice_3 :\n        int =>\n        int =>\n        t js_string =>\n        t js_string => t js_string => meth (t (js_array (t js_string)));\n      method splice_4 :\n        int =>\n        int =>\n        t js_string =>\n        t js_string =>\n        t js_string => t js_string => meth (t (js_array (t js_string)));\n      method toLocaleString : meth (t js_string);\n      method toString : meth (t js_string);\n      method unshift : t js_string => meth int;\n      method unshift_2 : t js_string => t js_string => meth int;\n      method unshift_3 :\n        t js_string => t js_string => t js_string => meth int;\n      method unshift_4 :\n        t js_string => t js_string => t js_string => t js_string => meth int\n    };\n  let str_array : t string_array => t (js_array (t js_string));\n  let match_result : t match_result_handle => t match_result;\n  class type number =\n    {\n      method toExponential : meth (t js_string);\n      method toExponential_digits : int => meth (t js_string);\n      method toFixed : int => meth (t js_string);\n      method toLocaleString : meth (t js_string);\n      method toPrecision : int => meth (t js_string);\n      method toString : meth (t js_string);\n      method toString_radix : int => meth (t js_string)\n    };\n  external number_of_float : float => t number = \"caml_js_from_float\";\n  external float_of_number : t number => float = \"caml_js_to_float\";\n  class type date =\n    {\n      method getDate : meth int;\n      method getDay : meth int;\n      method getFullYear : meth int;\n      method getHours : meth int;\n      method getMilliseconds : meth int;\n      method getMinutes : meth int;\n      method getMonth : meth int;\n      method getSeconds : meth int;\n      method getTime : meth float;\n      method getTimezoneOffset : meth int;\n      method getUTCDate : meth int;\n      method getUTCDay : meth int;\n      method getUTCFullYear : meth int;\n      method getUTCHours : meth int;\n      method getUTCMilliseconds : meth int;\n      method getUTCMinutes : meth int;\n      method getUTCMonth : meth int;\n      method getUTCSeconds : meth int;\n      method setDate : int => meth float;\n      method setDay : int => meth float;\n      method setFullYear : int => meth float;\n      method setHours : int => meth float;\n      method setMilliseconds : int => meth float;\n      method setMinutes : int => meth float;\n      method setMonth : int => meth float;\n      method setSeconds : int => meth float;\n      method setTime : float => meth float;\n      method setUTCDate : int => meth float;\n      method setUTCDay : int => meth float;\n      method setUTCFullYear : int => meth float;\n      method setUTCHours : int => meth float;\n      method setUTCMilliseconds : int => meth float;\n      method setUTCMinutes : int => meth float;\n      method setUTCMonth : int => meth float;\n      method setUTCSeconds : int => meth float;\n      method toDateString : meth (t js_string);\n      method toISOString : meth (t js_string);\n      method toJSON : 'a => meth (t js_string);\n      method toLocaleDateString : meth (t js_string);\n      method toLocaleString : meth (t js_string);\n      method toLocaleTimeString : meth (t js_string);\n      method toString : meth (t js_string);\n      method toTimeString : meth (t js_string);\n      method toUTCString : meth (t js_string);\n      method valueOf : meth float\n    };\n  let date_now : constr (t date);\n  let date_fromTimeValue : constr float => t date;\n  let date_month : constr int => int => t date;\n  let date_day : constr int => int => int => t date;\n  let date_hour : constr int => int => int => int => t date;\n  let date_min : constr int => int => int => int => int => t date;\n  let date_sec : constr int => int => int => int => int => int => t date;\n  let date_ms :\n    constr int => int => int => int => int => int => int => t date;\n  class type date_constr =\n    {\n      method _UTC_day : int => int => meth float;\n      method _UTC_hour : int => int => int => int => meth float;\n      method _UTC_min : int => int => int => int => int => meth float;\n      method _UTC_month : int => int => meth float;\n      method _UTC_ms :\n        int => int => int => int => int => int => int => meth float;\n      method _UTC_sec : int => int => int => int => int => int => meth float;\n      method parse : t js_string => meth float\n    };\n  let date : t date_constr;\n  class type math =\n    {\n      method _E : readonly_prop float;\n      method _LN10 : readonly_prop float;\n      method _LN2 : readonly_prop float;\n      method _LOG10E : readonly_prop float;\n      method _LOG2E : readonly_prop float;\n      method _PI : readonly_prop float;\n      method _SQRT1_2_ : readonly_prop float;\n      method _SQRT2 : readonly_prop float;\n      method abs : float => meth float;\n      method acos : float => meth float;\n      method asin : float => meth float;\n      method atan : float => meth float;\n      method atan2 : float => float => meth float;\n      method ceil : float => meth float;\n      method cos : float => meth float;\n      method exp : float => meth float;\n      method floor : float => meth float;\n      method log : float => meth float;\n      method max : float => float => meth float;\n      method max_3 : float => float => float => meth float;\n      method max_4 : float => float => float => float => meth float;\n      method min : float => float => meth float;\n      method min_3 : float => float => float => meth float;\n      method min_4 : float => float => float => float => meth float;\n      method pow : float => float => meth float;\n      method random : meth float;\n      method round : float => meth float;\n      method sin : float => meth float;\n      method sqrt : float => meth float;\n      method tan : float => meth float\n    };\n  let math : t math;\n  class type error =\n    {\n      method message : prop (t js_string);\n      method name : prop (t js_string);\n      method stack : prop (optdef (t js_string));\n      method toString : meth (t js_string)\n    };\n  let error_constr : constr t js_string => t error;\n  let string_of_error : t error => string;\n  let raise_js_error : t error => 'a;\n  exception Error of t error;\n  class type json =\n    {\n      method parse : t js_string => meth 'a;\n      method stringify : 'a => meth (t js_string)\n    };\n  let _JSON : t json;\n  let decodeURI : t js_string => t js_string;\n  let decodeURIComponent : t js_string => t js_string;\n  let encodeURI : t js_string => t js_string;\n  let encodeURIComponent : t js_string => t js_string;\n  let escape : t js_string => t js_string;\n  let unescape : t js_string => t js_string;\n  let isNaN : 'a => bool;\n  let parseInt : t js_string => int;\n  let parseFloat : t js_string => float;\n  external bool : bool => t bool = \"caml_js_from_bool\";\n  external to_bool : t bool => bool = \"caml_js_to_bool\";\n  external string : string => t js_string = \"caml_js_from_string\";\n  external to_string : t js_string => string = \"caml_js_to_string\";\n  external array : array 'a => t (js_array 'a) = \"caml_js_from_array\";\n  external to_array : t (js_array 'a) => array 'a = \"caml_js_to_array\";\n  external bytestring : string => t js_string = \"caml_bytes_of_string\";\n  external to_bytestring : t js_string => string = \"caml_js_to_byte_string\";\n  let coerce : 'a => ('a => Opt.t 'b) => ('a => 'b) => 'b;\n  let coerce_opt : Opt.t 'a => ('a => Opt.t 'b) => ('a => 'b) => 'b;\n  external typeof : t 'a => t js_string = \"caml_js_typeof\";\n  external instanceof : t 'a => constr 'b => bool = \"caml_js_instanceof\";\n  external debugger : unit => unit = \"debugger\";\n  module Unsafe :\n    {\n      type any;\n      external inject : 'a => any = \"%identity\";\n      external coerce : t 'a => t 'b = \"%identity\";\n      external get : 'a => 'b => 'c = \"caml_js_get\";\n      external set : 'a => 'b => 'c => unit = \"caml_js_set\";\n      external delete : 'a => 'b => unit = \"caml_js_delete\";\n      external call : 'a => 'b => array any => 'c = \"caml_js_call\";\n      external fun_call : 'a => array any => 'b = \"caml_js_fun_call\";\n      external meth_call : 'a => string => array any => 'b\n        = \"caml_js_meth_call\";\n      external new_obj : 'a => array any => 'b = \"caml_js_new\";\n      external obj : array (string, any) => 'a = \"caml_js_object\";\n      external pure_expr : (unit => 'a) => 'a = \"caml_js_pure_expr\";\n      external eval_string : string => 'a = \"caml_js_eval_string\";\n      external js_expr : string => 'a = \"caml_js_expr\";\n      external pure_js_expr : string => 'a = \"caml_pure_js_expr\";\n      let global : t < .. >;\n      external callback : ('a => 'b) => meth_callback 'c 'a => 'b\n        = \"%identity\";\n      external meth_callback : ('b => 'a) => meth_callback 'b 'a\n        = \"caml_js_wrap_meth_callback_unsafe\";\n      external variable : string => 'a = \"caml_js_var\";\n    };\n  external float : float => float = \"%identity\";\n  external to_float : float => float = \"%identity\";\n  type float_prop = prop float;\n}",
      "tail": "no"
    },
    {
      "start": { "line": 182, "col": 87 },
      "end": { "line": 182, "col": 96 },
      "type": "string => Js.t Js.js_string",
      "tail": "no"
    },
    {
      "start": { "line": 182, "col": 87 },
      "end": { "line": 182, "col": 101 },
      "type": "Js.t Js.js_string",
      "tail": "no"
    },
    {
      "start": { "line": 182, "col": 31 },
      "end": { "line": 182, "col": 103 },
      "type": "array (Js.t Js.js_string)",
      "tail": "no"
    },
    {
      "start": { "line": 182, "col": 21 },
      "end": { "line": 182, "col": 104 },
      "type": "Js.t (Js.js_array (Js.t Js.js_string))",
      "tail": "no"
    },
    {
      "start": { "line": 179, "col": 15 },
      "end": { "line": 184, "col": 11 },
      "type": "'_a",
      "tail": "no"
    },
    {
      "start": { "line": 178, "col": 8 },
      "end": { "line": 186, "col": 16 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 176, "col": 4 },
      "end": { "line": 187, "col": 5 },
      "type": "'_a => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 163, "col": 2 },
      "end": { "line": 188, "col": 10 },
      "type": "'a",
      "tail": "call"
    },
    {
      "start": { "line": 160, "col": 72 },
      "end": { "line": 189, "col": 1 },
      "type": "'a",
      "tail": "position"
    },
    {
      "start": { "line": 160, "col": 62 },
      "end": { "line": 189, "col": 1 },
      "type": "('a => 'b) => 'c",
      "tail": "position"
    },
    {
      "start": { "line": 160, "col": 54 },
      "end": { "line": 189, "col": 1 },
      "type": "('a => 'b) => ('c => 'd) => 'e",
      "tail": "position"
    },
    {
      "start": { "line": 160, "col": 41 },
      "end": { "line": 189, "col": 1 },
      "type": "query::'a => ('b => 'c) => ('d => 'e) => 'f",
      "tail": "position"
    },
    {
      "start": { "line": 160, "col": 30 },
      "end": { "line": 189, "col": 1 },
      "type": "path::string => query::'a => ('b => 'c) => ('d => 'e) => 'f",
      "tail": "position"
    },
    {
      "start": { "line": 160, "col": 19 },
      "end": { "line": 189, "col": 1 },
      "type":
        "text::string => path::string => query::'a => ('b => 'c) => ('d => 'e) => 'f",
      "tail": "no"
    }
  ]
]
# 0.08 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.08 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.08 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.08 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.08 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.08 frontend - output
[ "return", true ]
# 0.08 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.11 frontend - output
[ "return", [] ]
# 0.11 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.11 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.11 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.11 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.11 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.11 frontend - output
[ "return", true ]
# 0.11 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.11 frontend - output
[ "return", [] ]
# 0.12 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.12 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.12 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.12 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.12 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.12 frontend - output
[ "return", true ]
# 0.12 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 195, "col": 26 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.12 frontend - output
[
  "return",
  [
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 195, "col": 34 },
      "type":
        "path::string =>\ntext::string => position::(int, int) => ('a => 'b) => ('c => 'd) => 'e",
      "tail": "no"
    },
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 195, "col": 34 },
      "type":
        "path::string =>\ntext::string =>\nposition::(int, int) =>\n(Js.t (Js.js_array '_a) => unit) => ('_b => unit) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 194, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 193, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 191, "col": 22 },
      "end": { "line": 206, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 190, "col": 21 },
      "end": { "line": 207, "col": 5 },
      "type": "AtomReason.Atom.Editor.t => '_a",
      "tail": "no"
    },
    {
      "start": { "line": 189, "col": 2 },
      "end": { "line": 208, "col": 3 },
      "type": "Js.meth_callback '_a AtomReason.Atom.Editor.t => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 187, "col": 0 },
      "end": { "line": 208, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.12 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.12 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.12 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.12 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.12 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.12 frontend - output
[ "return", true ]
# 0.12 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 195, "col": 20 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.12 track_definition - from_string
looking for the source of 'SuperMerlin.getOccurrences' (prioritizing .ml files)
# 0.12 track_definition - lookup
lookup in value namespace
# 0.12 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.SuperMerlin.getOccurrences[val]'
# 0.12 typedtrie - ignored node
expression
# 0.12 typedtrie - ignored node
expression
# 0.12 typedtrie - ignored node
expression
# 0.12 typedtrie - ignored node
expression
# 0.12 typedtrie - ignored node
expression
# 0.12 typedtrie - ignored node
expression
# 0.12 typedtrie - ignored node
expression
# 0.12 typedtrie - ignored node
open_description
# 0.12 track_definition - locate
resolves to AtomReason.SuperMerlin.getOccurrences[val]
# 0.12 track_definition - Fallback.setopt
None
# 0.12 track_definition - from_path '%s'
AtomReason.SuperMerlin.getOccurrences[val]
# 0.12 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.12 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.12 track_definition - locate
resolves to M_AtomReason__SuperMerlin.getOccurrences[val]
# 0.12 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 62, characters 0-46
# 0.12 track_definition - from_path '%s'
M_AtomReason__SuperMerlin.getOccurrences[val]
# 0.12 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.12 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.12 track_definition - find_source
failed to find "." in source path (fallback = false)
# 0.12 track_definition - find_source
(for reference: fname = "")
# 0.12 track_definition - find_source
looking in '/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules'
# 0.12 frontend - output
[
  "return",
  "'SuperMerlin.getOccurrences' seems to originate from '.' whose ML file could not be found"
]
# 0.12 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.12 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.12 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.12 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.12 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.12 frontend - output
[ "return", true ]
# 0.12 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 194, "col": 35 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.13 frontend - output
[
  "return",
  [
    {
      "start": { "line": 194, "col": 19 },
      "end": { "line": 194, "col": 38 },
      "type": "AtomReason.Atom.Buffer.t => string",
      "tail": "no"
    },
    {
      "start": { "line": 194, "col": 19 },
      "end": { "line": 194, "col": 71 },
      "type": "string",
      "tail": "no"
    },
    {
      "start": { "line": 194, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 193, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 191, "col": 22 },
      "end": { "line": 206, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 190, "col": 21 },
      "end": { "line": 207, "col": 5 },
      "type": "AtomReason.Atom.Editor.t => '_a",
      "tail": "no"
    },
    {
      "start": { "line": 189, "col": 2 },
      "end": { "line": 208, "col": 3 },
      "type": "Js.meth_callback '_a AtomReason.Atom.Editor.t => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 187, "col": 0 },
      "end": { "line": 208, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.13 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.13 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.13 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\nL\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.13 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.13 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.13 frontend - output
[ "return", true ]
# 0.13 frontend - input
{
  "query": [ "complete", "prefix", "L", "at", { "line": 186, "col": 1 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.13 frontend - output
[
  "return",
  {
    "entries": [
      { "name": "LargeFile", "kind": "Module", "desc": "", "info": "" },
      { "name": "List", "kind": "Module", "desc": "", "info": "" },
      { "name": "ListLabels", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lexing", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lazy", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_unix", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_timeout", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_throttle", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_sys", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_switch", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_stream", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_ssl", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_sequence", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_react", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_process", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_preemptive", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_pqueue", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_pool", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_mvar", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_mutex", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_main", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log_rules", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log_core", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_list", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_io", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_gc", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_engine", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_daemon", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_condition", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_chan", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_bytes", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log_js", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_js_events", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_js", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lib_version", "kind": "Module", "desc": "", "info": "" }
    ],
    "context": null
  }
]
# 0.13 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.13 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.13 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\nL\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.13 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.13 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.13 frontend - output
[ "return", true ]
# 0.13 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.13 frontend - output
[
  "return",
  [
    {
      "start": { "line": 186, "col": 0 },
      "end": { "line": 186, "col": 1 },
      "type": "type",
      "sub": [],
      "valid": true,
      "message": "Error: Unbound constructor L"
    }
  ]
]
# 0.14 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.14 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.14 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.14 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.14 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.14 frontend - output
[ "return", true ]
# 0.14 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.14 frontend - output
[ "return", [] ]
# 0.14 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.14 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.14 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.14 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.14 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.14 frontend - output
[ "return", true ]
# 0.14 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 195, "col": 20 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.14 track_definition - from_string
looking for the source of 'SuperMerlin.getOccurrences' (prioritizing .ml files)
# 0.14 track_definition - lookup
lookup in value namespace
# 0.14 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.SuperMerlin.getOccurrences[val]'
# 0.14 typedtrie - ignored node
expression
# 0.14 typedtrie - ignored node
expression
# 0.14 typedtrie - ignored node
expression
# 0.14 typedtrie - ignored node
expression
# 0.14 typedtrie - ignored node
expression
# 0.14 typedtrie - ignored node
expression
# 0.14 typedtrie - ignored node
expression
# 0.14 typedtrie - ignored node
open_description
# 0.14 track_definition - locate
resolves to AtomReason.SuperMerlin.getOccurrences[val]
# 0.14 track_definition - Fallback.setopt
None
# 0.14 track_definition - from_path '%s'
AtomReason.SuperMerlin.getOccurrences[val]
# 0.14 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.14 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.14 track_definition - locate
resolves to M_AtomReason__SuperMerlin.getOccurrences[val]
# 0.14 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 62, characters 0-46
# 0.14 track_definition - from_path '%s'
M_AtomReason__SuperMerlin.getOccurrences[val]
# 0.14 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.14 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.14 track_definition - find_source
failed to find "." in source path (fallback = false)
# 0.14 track_definition - find_source
(for reference: fname = "")
# 0.14 track_definition - find_source
looking in '/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules'
# 0.14 frontend - output
[
  "return",
  "'SuperMerlin.getOccurrences' seems to originate from '.' whose ML file could not be found"
]
# 0.14 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.14 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.14 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.14 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.14 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.14 frontend - output
[ "return", true ]
# 0.14 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 195, "col": 23 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.14 frontend - output
[
  "return",
  [
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 195, "col": 34 },
      "type":
        "path::string =>\ntext::string => position::(int, int) => ('a => 'b) => ('c => 'd) => 'e",
      "tail": "no"
    },
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 195, "col": 34 },
      "type":
        "path::string =>\ntext::string =>\nposition::(int, int) =>\n(Js.t (Js.js_array '_a) => unit) => ('_b => unit) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 194, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 193, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 191, "col": 22 },
      "end": { "line": 206, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 190, "col": 21 },
      "end": { "line": 207, "col": 5 },
      "type": "AtomReason.Atom.Editor.t => '_a",
      "tail": "no"
    },
    {
      "start": { "line": 189, "col": 2 },
      "end": { "line": 208, "col": 3 },
      "type": "Js.meth_callback '_a AtomReason.Atom.Editor.t => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 187, "col": 0 },
      "end": { "line": 208, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.15 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.15 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.15 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\nL\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.15 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.15 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.15 frontend - output
[ "return", true ]
# 0.15 frontend - input
{
  "query": [ "complete", "prefix", "L", "at", { "line": 186, "col": 1 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.15 frontend - output
[
  "return",
  {
    "entries": [
      { "name": "LargeFile", "kind": "Module", "desc": "", "info": "" },
      { "name": "List", "kind": "Module", "desc": "", "info": "" },
      { "name": "ListLabels", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lexing", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lazy", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_unix", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_timeout", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_throttle", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_sys", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_switch", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_stream", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_ssl", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_sequence", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_react", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_process", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_preemptive", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_pqueue", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_pool", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_mvar", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_mutex", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_main", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log_rules", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log_core", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_list", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_io", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_gc", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_engine", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_daemon", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_condition", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_chan", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_bytes", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log_js", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_js_events", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_js", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lib_version", "kind": "Module", "desc": "", "info": "" }
    ],
    "context": null
  }
]
# 0.15 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.15 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.15 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\nLi\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.15 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.15 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.15 frontend - output
[ "return", true ]
# 0.15 frontend - input
{
  "query": [ "complete", "prefix", "Li", "at", { "line": 186, "col": 2 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.15 frontend - output
[
  "return",
  {
    "entries": [
      { "name": "List", "kind": "Module", "desc": "", "info": "" },
      { "name": "ListLabels", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lib_version", "kind": "Module", "desc": "", "info": "" }
    ],
    "context": null
  }
]
# 0.15 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.15 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.15 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\nList\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.15 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.15 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.15 frontend - output
[ "return", true ]
# 0.15 frontend - input
{
  "query": [ "complete", "prefix", "List", "at", { "line": 186, "col": 4 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.16 frontend - output
[
  "return",
  {
    "entries": [
      { "name": "List", "kind": "Module", "desc": "", "info": "" },
      { "name": "ListLabels", "kind": "Module", "desc": "", "info": "" }
    ],
    "context": null
  }
]
# 0.16 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.16 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.16 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\nList.\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.16 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.16 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.16 frontend - output
[ "return", true ]
# 0.16 frontend - input
{
  "query": [ "complete", "prefix", "List.", "at", { "line": 186, "col": 5 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.17 frontend - output
[
  "return",
  {
    "entries": [
      {
        "name": "append",
        "kind": "Value",
        "desc": "list 'a => list 'a => list 'a",
        "info": ""
      },
      {
        "name": "assoc",
        "kind": "Value",
        "desc": "'a => list ('a, 'b) => 'b",
        "info": ""
      },
      {
        "name": "assq",
        "kind": "Value",
        "desc": "'a => list ('a, 'b) => 'b",
        "info": ""
      },
      {
        "name": "combine",
        "kind": "Value",
        "desc": "list 'a => list 'b => list ('a, 'b)",
        "info": ""
      },
      {
        "name": "concat",
        "kind": "Value",
        "desc": "list (list 'a) => list 'a",
        "info": ""
      },
      {
        "name": "exists",
        "kind": "Value",
        "desc": "('a => bool) => list 'a => bool",
        "info": ""
      },
      {
        "name": "exists2",
        "kind": "Value",
        "desc": "('a => 'b => bool) => list 'a => list 'b => bool",
        "info": ""
      },
      {
        "name": "fast_sort",
        "kind": "Value",
        "desc": "('a => 'a => int) => list 'a => list 'a",
        "info": ""
      },
      {
        "name": "filter",
        "kind": "Value",
        "desc": "('a => bool) => list 'a => list 'a",
        "info": ""
      },
      {
        "name": "find",
        "kind": "Value",
        "desc": "('a => bool) => list 'a => 'a",
        "info": ""
      },
      {
        "name": "find_all",
        "kind": "Value",
        "desc": "('a => bool) => list 'a => list 'a",
        "info": ""
      },
      {
        "name": "flatten",
        "kind": "Value",
        "desc": "list (list 'a) => list 'a",
        "info": ""
      },
      {
        "name": "fold_left",
        "kind": "Value",
        "desc": "('a => 'b => 'a) => 'a => list 'b => 'a",
        "info": ""
      },
      {
        "name": "fold_left2",
        "kind": "Value",
        "desc": "('a => 'b => 'c => 'a) => 'a => list 'b => list 'c => 'a",
        "info": ""
      },
      {
        "name": "fold_right",
        "kind": "Value",
        "desc": "('a => 'b => 'b) => list 'a => 'b => 'b",
        "info": ""
      },
      {
        "name": "fold_right2",
        "kind": "Value",
        "desc": "('a => 'b => 'c => 'c) => list 'a => list 'b => 'c => 'c",
        "info": ""
      },
      {
        "name": "for_all",
        "kind": "Value",
        "desc": "('a => bool) => list 'a => bool",
        "info": ""
      },
      {
        "name": "for_all2",
        "kind": "Value",
        "desc": "('a => 'b => bool) => list 'a => list 'b => bool",
        "info": ""
      },
      { "name": "hd", "kind": "Value", "desc": "list 'a => 'a", "info": "" },
      {
        "name": "iter",
        "kind": "Value",
        "desc": "('a => unit) => list 'a => unit",
        "info": ""
      },
      {
        "name": "iter2",
        "kind": "Value",
        "desc": "('a => 'b => unit) => list 'a => list 'b => unit",
        "info": ""
      },
      {
        "name": "iteri",
        "kind": "Value",
        "desc": "(int => 'a => unit) => list 'a => unit",
        "info": ""
      },
      {
        "name": "length",
        "kind": "Value",
        "desc": "list 'a => int",
        "info": ""
      },
      {
        "name": "map",
        "kind": "Value",
        "desc": "('a => 'b) => list 'a => list 'b",
        "info": ""
      },
      {
        "name": "map2",
        "kind": "Value",
        "desc": "('a => 'b => 'c) => list 'a => list 'b => list 'c",
        "info": ""
      },
      {
        "name": "mapi",
        "kind": "Value",
        "desc": "(int => 'a => 'b) => list 'a => list 'b",
        "info": ""
      },
      {
        "name": "mem",
        "kind": "Value",
        "desc": "'a => list 'a => bool",
        "info": ""
      },
      {
        "name": "mem_assoc",
        "kind": "Value",
        "desc": "'a => list ('a, 'b) => bool",
        "info": ""
      },
      {
        "name": "mem_assq",
        "kind": "Value",
        "desc": "'a => list ('a, 'b) => bool",
        "info": ""
      },
      {
        "name": "memq",
        "kind": "Value",
        "desc": "'a => list 'a => bool",
        "info": ""
      },
      {
        "name": "merge",
        "kind": "Value",
        "desc": "('a => 'a => int) => list 'a => list 'a => list 'a",
        "info": ""
      },
      {
        "name": "nth",
        "kind": "Value",
        "desc": "list 'a => int => 'a",
        "info": ""
      },
      {
        "name": "partition",
        "kind": "Value",
        "desc": "('a => bool) => list 'a => (list 'a, list 'a)",
        "info": ""
      },
      {
        "name": "remove_assoc",
        "kind": "Value",
        "desc": "'a => list ('a, 'b) => list ('a, 'b)",
        "info": ""
      },
      {
        "name": "remove_assq",
        "kind": "Value",
        "desc": "'a => list ('a, 'b) => list ('a, 'b)",
        "info": ""
      },
      {
        "name": "rev",
        "kind": "Value",
        "desc": "list 'a => list 'a",
        "info": ""
      },
      {
        "name": "rev_append",
        "kind": "Value",
        "desc": "list 'a => list 'a => list 'a",
        "info": ""
      },
      {
        "name": "rev_map",
        "kind": "Value",
        "desc": "('a => 'b) => list 'a => list 'b",
        "info": ""
      },
      {
        "name": "rev_map2",
        "kind": "Value",
        "desc": "('a => 'b => 'c) => list 'a => list 'b => list 'c",
        "info": ""
      },
      {
        "name": "sort",
        "kind": "Value",
        "desc": "('a => 'a => int) => list 'a => list 'a",
        "info": ""
      },
      {
        "name": "sort_uniq",
        "kind": "Value",
        "desc": "('a => 'a => int) => list 'a => list 'a",
        "info": ""
      },
      {
        "name": "split",
        "kind": "Value",
        "desc": "list ('a, 'b) => (list 'a, list 'b)",
        "info": ""
      },
      {
        "name": "stable_sort",
        "kind": "Value",
        "desc": "('a => 'a => int) => list 'a => list 'a",
        "info": ""
      },
      {
        "name": "tl",
        "kind": "Value",
        "desc": "list 'a => list 'a",
        "info": ""
      }
    ],
    "context": null
  }
]
# 0.17 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.17 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.17 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\nList.\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.17 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.17 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.17 frontend - output
[ "return", true ]
# 0.17 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.17 frontend - output
[
  "return",
  [
    {
      "start": { "line": 186, "col": 0 },
      "end": { "line": 187, "col": 6 },
      "type": "type",
      "sub": [],
      "valid": true,
      "message": "Error: Unbound value List.export"
    }
  ]
]
# 0.17 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.17 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.17 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n  \nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.17 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.17 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.17 frontend - output
[ "return", true ]
# 0.17 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.17 frontend - output
[ "return", [] ]
# 0.18 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.18 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n  \nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.18 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.18 frontend - output
[ "return", true ]
# 0.18 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 195, "col": 20 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 track_definition - from_string
looking for the source of 'SuperMerlin.getOccurrences' (prioritizing .ml files)
# 0.18 track_definition - lookup
lookup in value namespace
# 0.18 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.SuperMerlin.getOccurrences[val]'
# 0.18 typedtrie - ignored node
expression
# 0.18 typedtrie - ignored node
expression
# 0.18 typedtrie - ignored node
expression
# 0.18 typedtrie - ignored node
expression
# 0.18 typedtrie - ignored node
expression
# 0.18 typedtrie - ignored node
expression
# 0.18 typedtrie - ignored node
expression
# 0.18 typedtrie - ignored node
open_description
# 0.18 track_definition - locate
resolves to AtomReason.SuperMerlin.getOccurrences[val]
# 0.18 track_definition - Fallback.setopt
None
# 0.18 track_definition - from_path '%s'
AtomReason.SuperMerlin.getOccurrences[val]
# 0.18 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.18 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.18 track_definition - locate
resolves to M_AtomReason__SuperMerlin.getOccurrences[val]
# 0.18 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 62, characters 0-46
# 0.18 track_definition - from_path '%s'
M_AtomReason__SuperMerlin.getOccurrences[val]
# 0.18 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.18 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.18 track_definition - find_source
failed to find "." in source path (fallback = false)
# 0.18 track_definition - find_source
(for reference: fname = "")
# 0.18 track_definition - find_source
looking in '/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules'
# 0.18 frontend - output
[
  "return",
  "'SuperMerlin.getOccurrences' seems to originate from '.' whose ML file could not be found"
]
# 0.18 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.18 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n  \nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.18 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.18 frontend - output
[ "return", true ]
# 0.18 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 195, "col": 25 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 frontend - output
[
  "return",
  [
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 195, "col": 34 },
      "type":
        "path::string =>\ntext::string => position::(int, int) => ('a => 'b) => ('c => 'd) => 'e",
      "tail": "no"
    },
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 195, "col": 34 },
      "type":
        "path::string =>\ntext::string =>\nposition::(int, int) =>\n(Js.t (Js.js_array '_a) => unit) => ('_b => unit) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 194, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 193, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 191, "col": 22 },
      "end": { "line": 206, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 190, "col": 21 },
      "end": { "line": 207, "col": 5 },
      "type": "AtomReason.Atom.Editor.t => '_a",
      "tail": "no"
    },
    {
      "start": { "line": 189, "col": 2 },
      "end": { "line": 208, "col": 3 },
      "type": "Js.meth_callback '_a AtomReason.Atom.Editor.t => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 187, "col": 0 },
      "end": { "line": 208, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.18 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.18 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n  \nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.18 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.18 frontend - output
[ "return", true ]
# 0.18 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 193, "col": 33 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 frontend - output
[
  "return",
  [
    {
      "start": { "line": 193, "col": 23 },
      "end": { "line": 193, "col": 34 },
      "type":
        "{\n  type t = M_AtomReason__Atom.Cursor.t;\n  let getBufferPosition : t => ('a, 'a);\n  let setBufferPosition :\n    position::AtomReason.Atom.Point.t => autoScroll::bool => t => ('a, 'a);\n  let fromJs : 'a => 'a;\n}",
      "tail": "no"
    },
    {
      "start": { "line": 193, "col": 23 },
      "end": { "line": 193, "col": 52 },
      "type": "AtomReason.Atom.Cursor.t => ('a, 'a)",
      "tail": "no"
    },
    {
      "start": { "line": 193, "col": 23 },
      "end": { "line": 193, "col": 94 },
      "type": "('a, 'a)",
      "tail": "no"
    },
    {
      "start": { "line": 193, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 191, "col": 22 },
      "end": { "line": 206, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 190, "col": 21 },
      "end": { "line": 207, "col": 5 },
      "type": "AtomReason.Atom.Editor.t => '_a",
      "tail": "no"
    },
    {
      "start": { "line": 189, "col": 2 },
      "end": { "line": 208, "col": 3 },
      "type": "Js.meth_callback '_a AtomReason.Atom.Editor.t => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 187, "col": 0 },
      "end": { "line": 208, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.18 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.18 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.18 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.18 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.18 frontend - output
[ "return", true ]
# 0.19 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.19 frontend - output
[ "return", [] ]
# 0.19 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.19 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.19 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* Only temporarily needed. */\nlet jsTrimTrailing = Js.Unsafe.js_expr \"function(s) {return s.split('\\\\n').map(function(ss) {return ss.trimRight()}).join('\\\\n');}\";\n\nlet atomGlobal = Js.Unsafe.js_expr \"atom\";\n\nlet atomRange = Js.Unsafe.js_expr \"require('atom').Range\";\n\nlet bufferedProcess = Js.Unsafe.js_expr \"require('atom').BufferedProcess\";\n\n/* Yes, this doesn't work across iframes. */\nlet _isString = Js.Unsafe.js_expr \"function(s) {return typeof s === 'string' || s instanceof String;}\";\n\nlet _isNumber = Js.Unsafe.js_expr \"function(n) {return typeof n === 'number';}\";\n\nlet _isUndefined = Js.Unsafe.js_expr \"function(n) {return typeof n === 'undefined';}\";\n\nlet _isNull = Js.Unsafe.js_expr \"function(n) {return n === null;}\";\n\nlet _isBool = Js.Unsafe.js_expr \"function(n) {return typeof n === 'boolean';}\";\n\nlet _arrayIsArray = Js.Unsafe.js_expr \"Array.isArray\";\n\nlet promise = Js.Unsafe.js_expr \"Promise\";\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\nlet emptyArgs = [||];\n\nlet trimTrailingWhiteSpace (s: string) => Js.to_string (\n  Js.Unsafe.fun_call jsTrimTrailing [|Js.Unsafe.inject (Js.string s)|]\n);\n\nlet module JsonType = {\n  type t =\n    | JsonString of string | JsonNum of float | JsonBool of bool | JsonArray of (array t) | JsonNull | Empty;\n};\n\ntype completionEntry = {desc: string, info: string, kind: string, name: string};\n\n/**\n * Api over Js values that are known to adhere to \"Json\" style constraints (no\n * functions), untyped, but predictable.\n */\nmodule type JsonValueSig = {\n  /* We never want to reveal that t is actually just an unsafe JS value.\n   * We want everyone to go through the Apis which provide type safety. */\n  type t;\n  let fromJs: Js.t Js.js_string => JsonType.t;\n  let toJs: JsonType.t => Js.Unsafe.any;\n  let unsafeExtractString: JsonType.t => string;\n};\n\nlet module JsonValue: JsonValueSig = {\n  open JsonType;\n  type t = Js.Unsafe.any;\n  let rec fromJs fieldVal =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject fieldVal|]) {\n      let jsArray = Array.map fromJs (Js.to_array (Js.Unsafe.coerce fieldVal));\n      JsonArray jsArray\n    } else if (\n      Js.Unsafe.fun_call _isString [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonString (Js.to_string fieldVal)\n    } else if (\n      Js.Unsafe.fun_call _isBool [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonBool (Js.to_bool (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNumber [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNum (Js.float_of_number (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNull [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNull\n    } else {\n      Empty\n    };\n  let rec toJs =\n    fun | JsonString str => Js.Unsafe.inject (Js.string str)\n        | JsonNum f => Js.Unsafe.inject (Js.float f)\n        | JsonBool b => Js.Unsafe.inject (Js.bool b)\n        | JsonArray a => Js.Unsafe.inject (Js.array (Array.map toJs a))\n        | JsonNull => Js.Unsafe.inject Js.null\n        | Empty => Js.Unsafe.inject Js.undefined;\n  let unsafeExtractString o =>\n    switch o {\n    | JsonType.JsonString s => s\n    | _ => raise (Invalid_argument \"unsafeExtractString: not a string\")\n    };\n};\n\nlet module Env = {\n  let setEnvVar envVar strVal => {\n    Js.Unsafe.set (Js.Unsafe.get (Js.Unsafe.get Js.Unsafe.global \"process\") \"env\") envVar (Js.string strVal);\n    Js.Unsafe.set fixedEnv envVar (Js.string strVal)\n  };\n};\n\nlet module Config = {\n  let get configKey :JsonType.t => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    JsonValue.fromJs (Js.Unsafe.meth_call config \"get\" [|Js.Unsafe.inject (Js.string configKey)|])\n  };\n  let set configKey (v: JsonType.t) :unit => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    let jsVal = JsonValue.toJs v;\n    Js.Unsafe.meth_call config \"set\" [|Js.Unsafe.inject (Js.string configKey), Js.Unsafe.inject jsVal|]\n  };\n};\n\nlet module Point = {\n  type t = (int, int);\n  let toJs (row, column) => Js.Unsafe.inject (Js.array [|Js.Unsafe.inject row, Js.Unsafe.inject column|]);\n  let fromJs jsP =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsP|]) {\n      let arr = Js.to_array jsP;\n      (arr.(0), arr.(1))\n    } else {\n      let row = Js.Unsafe.get jsP \"row\";\n      let col = Js.Unsafe.get jsP \"column\";\n      (row, col)\n    };\n};\n\nlet module Range = {\n  type row = int;\n  type column = int;\n  type rowColumn = (row, column);\n  type t = (rowColumn as 'start, rowColumn as 'endd);\n  let emptyRange = ((0, 0), (0, 0));\n  let toJs (startRowColumn, endRowColumn) =>\n    Js.Unsafe.new_obj atomRange [|Point.toJs startRowColumn, Point.toJs endRowColumn|];\n  let fromJs jsRange =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsRange|]) {\n      let arr = Js.to_array jsRange;\n      let startPoint = Js.to_array arr.(0);\n      let endPoint = Js.to_array arr.(1);\n      ((startPoint.(0), startPoint.(1)), (endPoint.(0), endPoint.(1)))\n    } else {\n      let startPoint = Js.Unsafe.get jsRange \"start\";\n      let endPoint = Js.Unsafe.get jsRange \"end\";\n      (Point.fromJs startPoint, Point.fromJs endPoint)\n    };\n};\n\nlet module Buffer = {\n  type t = Js.Unsafe.any;\n  let fromJs jsBuffer :t => jsBuffer;\n  let toJs (buffer: t) :Js.Unsafe.any => buffer;\n  let characterIndexForPosition (buffer: t) rowColumn =>\n    Js.Unsafe.meth_call buffer \"characterIndexForPosition\" [|Js.Unsafe.inject (Point.toJs rowColumn)|];\n  let getText (buffer: t) :string => Js.to_string (Js.Unsafe.meth_call buffer \"getText\" emptyArgs);\n  let getTextInRange (buffer: t) (range: Range.t) :string => Js.to_string (\n    Js.Unsafe.meth_call buffer \"getTextInRange\" [|Range.toJs range|]\n  );\n};\n\nlet module Cursor = {\n  /* Actually just the underlying JS value - TODO: obscure this using\n   * signature. */\n  type t;\n  let getBufferPosition (cursor: t) => Point.fromJs (\n    Js.Unsafe.meth_call cursor \"getBufferPosition\" emptyArgs\n  );\n  let setBufferPosition position::(pos: Point.t) autoScroll::(autoScroll: bool) (cursor: t) => {\n    let optionsObj = Js.Unsafe.obj [|(\"autoscroll\", Js.Unsafe.inject (Js.bool autoScroll))|];\n    let args = [|Point.toJs pos, optionsObj|];\n    Point.fromJs (Js.Unsafe.meth_call cursor \"setBufferPosition\" args)\n  };\n  let fromJs jsCursor => jsCursor;\n};\n\nlet module Editor = {\n  type t = Js.Unsafe.any;\n  let fromJs jsEditor :t => jsEditor;\n  let toJs (editor: t) :Js.Unsafe.any => editor;\n  let lineTextForBufferRow (editor: t) bufferRow => Js.to_string (\n    Js.Unsafe.meth_call editor \"lineTextForBufferRow\" [|bufferRow|]\n  );\n  let getBuffer editor :Buffer.t => Js.Unsafe.meth_call editor \"getBuffer\" emptyArgs;\n  let getPath editor => {\n    let path = Js.Unsafe.meth_call editor \"getPath\" emptyArgs;\n    Js.Opt.test path ? Some (Js.to_string path) : None\n  };\n  let getCursors editor => {\n    let arr = Array.map Cursor.fromJs (Js.to_array (Js.Unsafe.meth_call editor \"getCursors\" emptyArgs));\n    Array.to_list arr\n  };\n  let setSelectedBufferRanges editor bufferRanges => {\n    let arr = Array.map Range.toJs bufferRanges |> Js.array;\n    Js.Unsafe.meth_call editor \"setSelectedBufferRanges\" [|Js.Unsafe.inject arr|];\n  }\n};\n\n/**\n * Dirt simple promise wrapper, not implementing advanced features yet.\n */\nlet module Promise = {\n  /* This should be made abstract so it's essentially private. */\n  type underlyingJsPromise;\n  type t 'i 'o = {\n    underlyingJsPromise: underlyingJsPromise,\n    /* Try adding constraint where 'o = t 'ii 'oo for some 'ii 'oo */\n    /* Perhaps the higher ranked polymorphism feature would work here */\n    /* One promise's output is another promise's input. */\n    thn: 'nextO .('i => 'o) => t 'o 'nextO\n  };\n  let toJs p => p.underlyingJsPromise;\n  let create executor => {\n    let jsCurriedExecutor = Js.wrap_callback executor;\n    let underlyingJsPromise = Js.Unsafe.new_obj promise [|Js.Unsafe.inject jsCurriedExecutor|];\n    {\n      underlyingJsPromise,\n      thn: fun onResolve =>\n        Js.Unsafe.meth_call underlyingJsPromise \"then\" [|Js.Unsafe.inject (Js.wrap_callback onResolve)|]\n    }\n  };\n  let resolve v => create (fun jsResolveCb jsRejectCb => Js.Unsafe.fun_call jsResolveCb [|v|]);\n  /* For our current purposes, a promise (with no chaining abilities) is enough. */\n  let createFakePromise (executor: ('a => unit) => ('b => unit) => unit) =>\n    Js.Unsafe.new_obj promise [|Js.Unsafe.inject (Js.wrap_callback executor)|];\n};\n\nlet module Notification = {\n  type t;\n  let getType (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getType\" emptyArgs);\n  let getMessage (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getMessage\" emptyArgs);\n  let dismiss (n: t) => Js.Unsafe.meth_call n \"dismiss\" emptyArgs;\n};\n\nlet module NotificationManager = {\n  type options = {detail: string, dismissable: bool, icon: string};\n  let optionsToJs opts => Js.Unsafe.obj [|\n    (\"detail\", Js.Unsafe.inject (Js.string opts.detail)),\n    (\"dismissable\", Js.Unsafe.inject (Js.bool opts.dismissable)),\n    (\"icon\", Js.Unsafe.inject (Js.string opts.icon))\n  |];\n  let defaultOptions = {detail: \"MessageNotProvided\", dismissable: false, icon: \"flame\"};\n  let addError options::opts={...defaultOptions, icon: \"flame\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addError\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addWarning options::opts={...defaultOptions, icon: \"alert\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addWarning\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addInfo options::opts={...defaultOptions, icon: \"info\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addInfo\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addSuccess options::opts={...defaultOptions, icon: \"check\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addSuccess\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let getNotifications () => Array.to_list (\n    Js.to_array (Js.Unsafe.meth_call (Js.Unsafe.get atomGlobal \"notifications\") \"getNotifications\" emptyArgs)\n  );\n};\n\nlet module Process = {\n  type options = {cwd: string, env: Js.t unit, detached: bool};\n  let defaultOptions = {cwd: \".\", env: Js.Unsafe.obj [||], detached: false};\n};\n\nlet module ChildProcess = {\n  type t;\n  let writeStdin (process: t) str :unit =>\n    Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"write\" [|Js.Unsafe.inject (Js.string str)|];\n  let endStdin (process: t) => Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"end\" emptyArgs;\n};\n\nmodule type BufferedProcessSig = {\n  type t;\n  let create:\n    options::Process.options? =>\n    stdout::(string => unit)? =>\n    stderr::(string => unit)? =>\n    exit::(int => unit)? =>\n    args::list string =>\n    string =>\n    t;\n};\n\nlet module BufferedProcess = {\n  open Process;\n  type t;\n  let create options::opts=? stdout::stdOut=? stderr::stdErr=? exit::exit=? cmd args::args => {\n    let fields = [|\n      (\"command\", Js.Unsafe.inject (Js.string cmd)),\n      (\"args\", Js.Unsafe.inject (Js.array (Array.map Js.string (Array.of_list args))))\n    |];\n    let fields =\n      switch opts {\n      | None => fields\n      | Some opts => {\n          let jsOptions = Js.Unsafe.obj [|\n            (\"cwd\", Js.Unsafe.inject opts.cwd),\n            (\"env\", Js.Unsafe.inject opts.env),\n            (\"detached\", Js.Unsafe.inject (Js.bool opts.detached))\n          |];\n          Array.append fields [|(\"options\", jsOptions)|]\n        }\n      };\n    let fields =\n      switch stdOut {\n      | None => fields\n      | Some so => {\n          let cb jsStr => so (Js.to_string jsStr);\n          Array.append fields [|(\"stdout\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch stdErr {\n      | None => fields\n      | Some si => {\n          let cb jsStr => si (Js.to_string jsStr);\n          Array.append fields [|(\"stdin\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch exit {\n      | None => fields\n      | Some e => {\n          let cb eCode => e (Js.to_float eCode);\n          Array.append fields [|(\"exit\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    Js.Unsafe.new_obj bufferedProcess [|Js.Unsafe.obj fields|]\n  };\n  let onWillThrowError buffProcess fn :unit => {\n    let wrappedCb = Js.wrap_callback (\n      fun jsErrHandle => fn (Js.Unsafe.get jsErrHandle \"error\") (Js.Unsafe.get jsErrHandle \"handle\")\n    );\n    Js.Unsafe.meth_call buffProcess \"onWillThrowError\" [|Js.Unsafe.inject wrappedCb|]\n  };\n  let process (bufferedProcess: t) => Js.Unsafe.get bufferedProcess \"process\";\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.19 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.19 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.19 frontend - output
[ "return", true ]
# 0.19 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.20 frontend - output
[ "return", [] ]
# 0.20 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.20 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.20 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* Only temporarily needed. */\nlet jsTrimTrailing = Js.Unsafe.js_expr \"function(s) {return s.split('\\\\n').map(function(ss) {return ss.trimRight()}).join('\\\\n');}\";\n\nlet atomGlobal = Js.Unsafe.js_expr \"atom\";\n\nlet atomRange = Js.Unsafe.js_expr \"require('atom').Range\";\n\nlet bufferedProcess = Js.Unsafe.js_expr \"require('atom').BufferedProcess\";\n\n/* Yes, this doesn't work across iframes. */\nlet _isString = Js.Unsafe.js_expr \"function(s) {return typeof s === 'string' || s instanceof String;}\";\n\nlet _isNumber = Js.Unsafe.js_expr \"function(n) {return typeof n === 'number';}\";\n\nlet _isUndefined = Js.Unsafe.js_expr \"function(n) {return typeof n === 'undefined';}\";\n\nlet _isNull = Js.Unsafe.js_expr \"function(n) {return n === null;}\";\n\nlet _isBool = Js.Unsafe.js_expr \"function(n) {return typeof n === 'boolean';}\";\n\nlet _arrayIsArray = Js.Unsafe.js_expr \"Array.isArray\";\n\nlet promise = Js.Unsafe.js_expr \"Promise\";\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\nlet emptyArgs = [||];\n\nlet trimTrailingWhiteSpace (s: string) => Js.to_string (\n  Js.Unsafe.fun_call jsTrimTrailing [|Js.Unsafe.inject (Js.string s)|]\n);\n\nlet module JsonType = {\n  type t =\n    | JsonString of string | JsonNum of float | JsonBool of bool | JsonArray of (array t) | JsonNull | Empty;\n};\n\ntype completionEntry = {desc: string, info: string, kind: string, name: string};\n\n/**\n * Api over Js values that are known to adhere to \"Json\" style constraints (no\n * functions), untyped, but predictable.\n */\nmodule type JsonValueSig = {\n  /* We never want to reveal that t is actually just an unsafe JS value.\n   * We want everyone to go through the Apis which provide type safety. */\n  type t;\n  let fromJs: Js.t Js.js_string => JsonType.t;\n  let toJs: JsonType.t => Js.Unsafe.any;\n  let unsafeExtractString: JsonType.t => string;\n};\n\nlet module JsonValue: JsonValueSig = {\n  open JsonType;\n  type t = Js.Unsafe.any;\n  let rec fromJs fieldVal =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject fieldVal|]) {\n      let jsArray = Array.map fromJs (Js.to_array (Js.Unsafe.coerce fieldVal));\n      JsonArray jsArray\n    } else if (\n      Js.Unsafe.fun_call _isString [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonString (Js.to_string fieldVal)\n    } else if (\n      Js.Unsafe.fun_call _isBool [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonBool (Js.to_bool (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNumber [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNum (Js.float_of_number (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNull [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNull\n    } else {\n      Empty\n    };\n  let rec toJs =\n    fun | JsonString str => Js.Unsafe.inject (Js.string str)\n        | JsonNum f => Js.Unsafe.inject (Js.float f)\n        | JsonBool b => Js.Unsafe.inject (Js.bool b)\n        | JsonArray a => Js.Unsafe.inject (Js.array (Array.map toJs a))\n        | JsonNull => Js.Unsafe.inject Js.null\n        | Empty => Js.Unsafe.inject Js.undefined;\n  let unsafeExtractString o =>\n    switch o {\n    | JsonType.JsonString s => s\n    | _ => raise (Invalid_argument \"unsafeExtractString: not a string\")\n    };\n};\n\nlet module Env = {\n  let setEnvVar envVar strVal => {\n    Js.Unsafe.set (Js.Unsafe.get (Js.Unsafe.get Js.Unsafe.global \"process\") \"env\") envVar (Js.string strVal);\n    Js.Unsafe.set fixedEnv envVar (Js.string strVal)\n  };\n};\n\nlet module Config = {\n  let get configKey :JsonType.t => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    JsonValue.fromJs (Js.Unsafe.meth_call config \"get\" [|Js.Unsafe.inject (Js.string configKey)|])\n  };\n  let set configKey (v: JsonType.t) :unit => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    let jsVal = JsonValue.toJs v;\n    Js.Unsafe.meth_call config \"set\" [|Js.Unsafe.inject (Js.string configKey), Js.Unsafe.inject jsVal|]\n  };\n};\n\nlet module Point = {\n  type t = (int, int);\n  let toJs (row, column) => Js.Unsafe.inject (Js.array [|Js.Unsafe.inject row, Js.Unsafe.inject column|]);\n  let fromJs jsP =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsP|]) {\n      let arr = Js.to_array jsP;\n      (arr.(0), arr.(1))\n    } else {\n      let row = Js.Unsafe.get jsP \"row\";\n      let col = Js.Unsafe.get jsP \"column\";\n      (row, col)\n    };\n};\n\nlet module Range = {\n  type row = int;\n  type column = int;\n  type rowColumn = (row, column);\n  type t = (rowColumn as 'start, rowColumn as 'endd);\n  let emptyRange = ((0, 0), (0, 0));\n  let toJs (startRowColumn, endRowColumn) =>\n    Js.Unsafe.new_obj atomRange [|Point.toJs startRowColumn, Point.toJs endRowColumn|];\n  let fromJs jsRange =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsRange|]) {\n      let arr = Js.to_array jsRange;\n      let startPoint = Js.to_array arr.(0);\n      let endPoint = Js.to_array arr.(1);\n      ((startPoint.(0), startPoint.(1)), (endPoint.(0), endPoint.(1)))\n    } else {\n      let startPoint = Js.Unsafe.get jsRange \"start\";\n      let endPoint = Js.Unsafe.get jsRange \"end\";\n      (Point.fromJs startPoint, Point.fromJs endPoint)\n    };\n};\n\nlet module Buffer = {\n  type t = Js.Unsafe.any;\n  let fromJs jsBuffer :t => jsBuffer;\n  let toJs (buffer: t) :Js.Unsafe.any => buffer;\n  let characterIndexForPosition (buffer: t) rowColumn =>\n    Js.Unsafe.meth_call buffer \"characterIndexForPosition\" [|Js.Unsafe.inject (Point.toJs rowColumn)|];\n  let getText (buffer: t) :string => Js.to_string (Js.Unsafe.meth_call buffer \"getText\" emptyArgs);\n  let getTextInRange (buffer: t) (range: Range.t) :string => Js.to_string (\n    Js.Unsafe.meth_call buffer \"getTextInRange\" [|Range.toJs range|]\n  );\n};\n\nlet module Cursor = {\n  /* Actually just the underlying JS value - TODO: obscure this using\n   * signature. */\n  type t;\n  let getBufferPosition (cursor: t) => Point.fromJs (\n    Js.Unsafe.meth_call cursor \"getBufferPosition\" emptyArgs\n  );\n  let setBufferPosition position::(pos: Point.t) autoScroll::(autoScroll: bool) (cursor: t) => {\n    let optionsObj = Js.Unsafe.obj [|(\"autoscroll\", Js.Unsafe.inject (Js.bool autoScroll))|];\n    let args = [|Point.toJs pos, optionsObj|];\n    Point.fromJs (Js.Unsafe.meth_call cursor \"setBufferPosition\" args)\n  };\n  let fromJs jsCursor => jsCursor;\n};\n\nlet module Editor = {\n  type t = Js.Unsafe.any;\n  let fromJs jsEditor :t => jsEditor;\n  let toJs (editor: t) :Js.Unsafe.any => editor;\n  let lineTextForBufferRow (editor: t) bufferRow => Js.to_string (\n    Js.Unsafe.meth_call editor \"lineTextForBufferRow\" [|bufferRow|]\n  );\n  let getBuffer editor :Buffer.t => Js.Unsafe.meth_call editor \"getBuffer\" emptyArgs;\n  let getPath editor => {\n    let path = Js.Unsafe.meth_call editor \"getPath\" emptyArgs;\n    Js.Opt.test path ? Some (Js.to_string path) : None\n  };\n  let getCursors editor => {\n    let arr = Array.map Cursor.fromJs (Js.to_array (Js.Unsafe.meth_call editor \"getCursors\" emptyArgs));\n    Array.to_list arr\n  };\n  let setSelectedBufferRanges editor bufferRanges => {\n    let arr = Array.map Range.toJs bufferRanges |> Js.array;\n    Js.Unsafe.meth_call editor \"setSelectedBufferRanges\" [|Js.Unsafe.inject arr|];\n  }\n};\n\n/**\n * Dirt simple promise wrapper, not implementing advanced features yet.\n */\nlet module Promise = {\n  /* This should be made abstract so it's essentially private. */\n  type underlyingJsPromise;\n  type t 'i 'o = {\n    underlyingJsPromise: underlyingJsPromise,\n    /* Try adding constraint where 'o = t 'ii 'oo for some 'ii 'oo */\n    /* Perhaps the higher ranked polymorphism feature would work here */\n    /* One promise's output is another promise's input. */\n    thn: 'nextO .('i => 'o) => t 'o 'nextO\n  };\n  let toJs p => p.underlyingJsPromise;\n  let create executor => {\n    let jsCurriedExecutor = Js.wrap_callback executor;\n    let underlyingJsPromise = Js.Unsafe.new_obj promise [|Js.Unsafe.inject jsCurriedExecutor|];\n    {\n      underlyingJsPromise,\n      thn: fun onResolve =>\n        Js.Unsafe.meth_call underlyingJsPromise \"then\" [|Js.Unsafe.inject (Js.wrap_callback onResolve)|]\n    }\n  };\n  let resolve v => create (fun jsResolveCb jsRejectCb => Js.Unsafe.fun_call jsResolveCb [|v|]);\n  /* For our current purposes, a promise (with no chaining abilities) is enough. */\n  let createFakePromise (executor: ('a => unit) => ('b => unit) => unit) =>\n    Js.Unsafe.new_obj promise [|Js.Unsafe.inject (Js.wrap_callback executor)|];\n};\n\nlet module Notification = {\n  type t;\n  let getType (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getType\" emptyArgs);\n  let getMessage (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getMessage\" emptyArgs);\n  let dismiss (n: t) => Js.Unsafe.meth_call n \"dismiss\" emptyArgs;\n};\n\nlet module NotificationManager = {\n  type options = {detail: string, dismissable: bool, icon: string};\n  let optionsToJs opts => Js.Unsafe.obj [|\n    (\"detail\", Js.Unsafe.inject (Js.string opts.detail)),\n    (\"dismissable\", Js.Unsafe.inject (Js.bool opts.dismissable)),\n    (\"icon\", Js.Unsafe.inject (Js.string opts.icon))\n  |];\n  let defaultOptions = {detail: \"MessageNotProvided\", dismissable: false, icon: \"flame\"};\n  let addError options::opts={...defaultOptions, icon: \"flame\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addError\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addWarning options::opts={...defaultOptions, icon: \"alert\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addWarning\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addInfo options::opts={...defaultOptions, icon: \"info\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addInfo\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addSuccess options::opts={...defaultOptions, icon: \"check\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addSuccess\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let getNotifications () => Array.to_list (\n    Js.to_array (Js.Unsafe.meth_call (Js.Unsafe.get atomGlobal \"notifications\") \"getNotifications\" emptyArgs)\n  );\n};\n\nlet module Process = {\n  type options = {cwd: string, env: Js.t unit, detached: bool};\n  let defaultOptions = {cwd: \".\", env: Js.Unsafe.obj [||], detached: false};\n};\n\nlet module ChildProcess = {\n  type t;\n  let writeStdin (process: t) str :unit =>\n    Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"write\" [|Js.Unsafe.inject (Js.string str)|];\n  let endStdin (process: t) => Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"end\" emptyArgs;\n};\n\nmodule type BufferedProcessSig = {\n  type t;\n  let create:\n    options::Process.options? =>\n    stdout::(string => unit)? =>\n    stderr::(string => unit)? =>\n    exit::(int => unit)? =>\n    args::list string =>\n    string =>\n    t;\n};\n\nlet module BufferedProcess = {\n  open Process;\n  type t;\n  let create options::opts=? stdout::stdOut=? stderr::stdErr=? exit::exit=? cmd args::args => {\n    let fields = [|\n      (\"command\", Js.Unsafe.inject (Js.string cmd)),\n      (\"args\", Js.Unsafe.inject (Js.array (Array.map Js.string (Array.of_list args))))\n    |];\n    let fields =\n      switch opts {\n      | None => fields\n      | Some opts => {\n          let jsOptions = Js.Unsafe.obj [|\n            (\"cwd\", Js.Unsafe.inject opts.cwd),\n            (\"env\", Js.Unsafe.inject opts.env),\n            (\"detached\", Js.Unsafe.inject (Js.bool opts.detached))\n          |];\n          Array.append fields [|(\"options\", jsOptions)|]\n        }\n      };\n    let fields =\n      switch stdOut {\n      | None => fields\n      | Some so => {\n          let cb jsStr => so (Js.to_string jsStr);\n          Array.append fields [|(\"stdout\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch stdErr {\n      | None => fields\n      | Some si => {\n          let cb jsStr => si (Js.to_string jsStr);\n          Array.append fields [|(\"stdin\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch exit {\n      | None => fields\n      | Some e => {\n          let cb eCode => e (Js.to_float eCode);\n          Array.append fields [|(\"exit\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    Js.Unsafe.new_obj bufferedProcess [|Js.Unsafe.obj fields|]\n  };\n  let onWillThrowError buffProcess fn :unit => {\n    let wrappedCb = Js.wrap_callback (\n      fun jsErrHandle => fn (Js.Unsafe.get jsErrHandle \"error\") (Js.Unsafe.get jsErrHandle \"handle\")\n    );\n    Js.Unsafe.meth_call buffProcess \"onWillThrowError\" [|Js.Unsafe.inject wrappedCb|]\n  };\n  let process (bufferedProcess: t) => Js.Unsafe.get bufferedProcess \"process\";\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.20 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.20 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.20 frontend - output
[ "return", true ]
# 0.20 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.20 frontend - output
[ "return", [] ]
# 0.20 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.20 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.20 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* Only temporarily needed. */\nlet jsTrimTrailing = Js.Unsafe.js_expr \"function(s) {return s.split('\\\\n').map(function(ss) {return ss.trimRight()}).join('\\\\n');}\";\n\nlet atomGlobal = Js.Unsafe.js_expr \"atom\";\n\nlet atomRange = Js.Unsafe.js_expr \"require('atom').Range\";\n\nlet bufferedProcess = Js.Unsafe.js_expr \"require('atom').BufferedProcess\";\n\n/* Yes, this doesn't work across iframes. */\nlet _isString = Js.Unsafe.js_expr \"function(s) {return typeof s === 'string' || s instanceof String;}\";\n\nlet _isNumber = Js.Unsafe.js_expr \"function(n) {return typeof n === 'number';}\";\n\nlet _isUndefined = Js.Unsafe.js_expr \"function(n) {return typeof n === 'undefined';}\";\n\nlet _isNull = Js.Unsafe.js_expr \"function(n) {return n === null;}\";\n\nlet _isBool = Js.Unsafe.js_expr \"function(n) {return typeof n === 'boolean';}\";\n\nlet _arrayIsArray = Js.Unsafe.js_expr \"Array.isArray\";\n\nlet promise = Js.Unsafe.js_expr \"Promise\";\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\nlet emptyArgs = [||];\n\nlet trimTrailingWhiteSpace (s: string) => Js.to_string (\n  Js.Unsafe.fun_call jsTrimTrailing [|Js.Unsafe.inject (Js.string s)|]\n);\n\nlet module JsonType = {\n  type t =\n    | JsonString of string | JsonNum of float | JsonBool of bool | JsonArray of (array t) | JsonNull | Empty;\n};\n\ntype completionEntry = {desc: string, info: string, kind: string, name: string};\n\n/**\n * Api over Js values that are known to adhere to \"Json\" style constraints (no\n * functions), untyped, but predictable.\n */\nmodule type JsonValueSig = {\n  /* We never want to reveal that t is actually just an unsafe JS value.\n   * We want everyone to go through the Apis which provide type safety. */\n  type t;\n  let fromJs: Js.t Js.js_string => JsonType.t;\n  let toJs: JsonType.t => Js.Unsafe.any;\n  let unsafeExtractString: JsonType.t => string;\n};\n\nlet module JsonValue: JsonValueSig = {\n  open JsonType;\n  type t = Js.Unsafe.any;\n  let rec fromJs fieldVal =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject fieldVal|]) {\n      let jsArray = Array.map fromJs (Js.to_array (Js.Unsafe.coerce fieldVal));\n      JsonArray jsArray\n    } else if (\n      Js.Unsafe.fun_call _isString [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonString (Js.to_string fieldVal)\n    } else if (\n      Js.Unsafe.fun_call _isBool [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonBool (Js.to_bool (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNumber [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNum (Js.float_of_number (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNull [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNull\n    } else {\n      Empty\n    };\n  let rec toJs =\n    fun | JsonString str => Js.Unsafe.inject (Js.string str)\n        | JsonNum f => Js.Unsafe.inject (Js.float f)\n        | JsonBool b => Js.Unsafe.inject (Js.bool b)\n        | JsonArray a => Js.Unsafe.inject (Js.array (Array.map toJs a))\n        | JsonNull => Js.Unsafe.inject Js.null\n        | Empty => Js.Unsafe.inject Js.undefined;\n  let unsafeExtractString o =>\n    switch o {\n    | JsonType.JsonString s => s\n    | _ => raise (Invalid_argument \"unsafeExtractString: not a string\")\n    };\n};\n\nlet module Env = {\n  let setEnvVar envVar strVal => {\n    Js.Unsafe.set (Js.Unsafe.get (Js.Unsafe.get Js.Unsafe.global \"process\") \"env\") envVar (Js.string strVal);\n    Js.Unsafe.set fixedEnv envVar (Js.string strVal)\n  };\n};\n\nlet module Config = {\n  let get configKey :JsonType.t => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    JsonValue.fromJs (Js.Unsafe.meth_call config \"get\" [|Js.Unsafe.inject (Js.string configKey)|])\n  };\n  let set configKey (v: JsonType.t) :unit => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    let jsVal = JsonValue.toJs v;\n    Js.Unsafe.meth_call config \"set\" [|Js.Unsafe.inject (Js.string configKey), Js.Unsafe.inject jsVal|]\n  };\n};\n\nlet module Point = {\n  type t = (int, int);\n  let toJs (row, column) => Js.Unsafe.inject (Js.array [|Js.Unsafe.inject row, Js.Unsafe.inject column|]);\n  let fromJs jsP =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsP|]) {\n      let arr = Js.to_array jsP;\n      (arr.(0), arr.(1))\n    } else {\n      let row = Js.Unsafe.get jsP \"row\";\n      let col = Js.Unsafe.get jsP \"column\";\n      (row, col)\n    };\n};\n\nlet module Range = {\n  type row = int;\n  type column = int;\n  type rowColumn = (row, column);\n  type t = (rowColumn as 'start, rowColumn as 'endd);\n  let emptyRange = ((0, 0), (0, 0));\n  let toJs (startRowColumn, endRowColumn) =>\n    Js.Unsafe.new_obj atomRange [|Point.toJs startRowColumn, Point.toJs endRowColumn|];\n  let fromJs jsRange =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsRange|]) {\n      let arr = Js.to_array jsRange;\n      let startPoint = Js.to_array arr.(0);\n      let endPoint = Js.to_array arr.(1);\n      ((startPoint.(0), startPoint.(1)), (endPoint.(0), endPoint.(1)))\n    } else {\n      let startPoint = Js.Unsafe.get jsRange \"start\";\n      let endPoint = Js.Unsafe.get jsRange \"end\";\n      (Point.fromJs startPoint, Point.fromJs endPoint)\n    };\n};\n\nlet module Buffer = {\n  type t = Js.Unsafe.any;\n  let fromJs jsBuffer :t => jsBuffer;\n  let toJs (buffer: t) :Js.Unsafe.any => buffer;\n  let characterIndexForPosition (buffer: t) rowColumn =>\n    Js.Unsafe.meth_call buffer \"characterIndexForPosition\" [|Js.Unsafe.inject (Point.toJs rowColumn)|];\n  let getText (buffer: t) :string => Js.to_string (Js.Unsafe.meth_call buffer \"getText\" emptyArgs);\n  let getTextInRange (buffer: t) (range: Range.t) :string => Js.to_string (\n    Js.Unsafe.meth_call buffer \"getTextInRange\" [|Range.toJs range|]\n  );\n};\n\nlet module Cursor = {\n  /* Actually just the underlying JS value - TODO: obscure this using\n   * signature. */\n  type t;\n  let getBufferPosition (cursor: t) => Point.fromJs (\n    Js.Unsafe.meth_call cursor \"getBufferPosition\" emptyArgs\n  );\n  let setBufferPosition position::(pos: Point.t) autoScroll::(autoScroll: bool) (cursor: t) => {\n    let optionsObj = Js.Unsafe.obj [|(\"autoscroll\", Js.Unsafe.inject (Js.bool autoScroll))|];\n    let args = [|Point.toJs pos, optionsObj|];\n    Point.fromJs (Js.Unsafe.meth_call cursor \"setBufferPosition\" args)\n  };\n  let fromJs jsCursor => jsCursor;\n};\n\nlet module Editor = {\n  type t = Js.Unsafe.any;\n  let fromJs jsEditor :t => jsEditor;\n  let toJs (editor: t) :Js.Unsafe.any => editor;\n  let lineTextForBufferRow (editor: t) bufferRow => Js.to_string (\n    Js.Unsafe.meth_call editor \"lineTextForBufferRow\" [|bufferRow|]\n  );\n  let getBuffer editor :Buffer.t => Js.Unsafe.meth_call editor \"getBuffer\" emptyArgs;\n  let getPath editor => {\n    let path = Js.Unsafe.meth_call editor \"getPath\" emptyArgs;\n    Js.Opt.test path ? Some (Js.to_string path) : None\n  };\n  let getCursors editor => {\n    let arr = Array.map Cursor.fromJs (Js.to_array (Js.Unsafe.meth_call editor \"getCursors\" emptyArgs));\n    Array.to_list arr\n  };\n  let setSelectedBufferRanges editor bufferRanges => {\n    let arr = Array.map Range.toJs bufferRanges |> Js.array;\n    Js.Unsafe.meth_call editor \"setSelectedBufferRanges\" [|Js.Unsafe.inject arr|];\n  }\n};\n\n/**\n * Dirt simple promise wrapper, not implementing advanced features yet.\n */\nlet module Promise = {\n  /* This should be made abstract so it's essentially private. */\n  type underlyingJsPromise;\n  type t 'i 'o = {\n    underlyingJsPromise: underlyingJsPromise,\n    /* Try adding constraint where 'o = t 'ii 'oo for some 'ii 'oo */\n    /* Perhaps the higher ranked polymorphism feature would work here */\n    /* One promise's output is another promise's input. */\n    thn: 'nextO .('i => 'o) => t 'o 'nextO\n  };\n  let toJs p => p.underlyingJsPromise;\n  let create executor => {\n    let jsCurriedExecutor = Js.wrap_callback executor;\n    let underlyingJsPromise = Js.Unsafe.new_obj promise [|Js.Unsafe.inject jsCurriedExecutor|];\n    {\n      underlyingJsPromise,\n      thn: fun onResolve =>\n        Js.Unsafe.meth_call underlyingJsPromise \"then\" [|Js.Unsafe.inject (Js.wrap_callback onResolve)|]\n    }\n  };\n  let resolve v => create (fun jsResolveCb jsRejectCb => Js.Unsafe.fun_call jsResolveCb [|v|]);\n  /* For our current purposes, a promise (with no chaining abilities) is enough. */\n  let createFakePromise (executor: ('a => unit) => ('b => unit) => unit) =>\n    Js.Unsafe.new_obj promise [|Js.Unsafe.inject (Js.wrap_callback executor)|];\n};\n\nlet module Notification = {\n  type t;\n  let getType (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getType\" emptyArgs);\n  let getMessage (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getMessage\" emptyArgs);\n  let dismiss (n: t) => Js.Unsafe.meth_call n \"dismiss\" emptyArgs;\n};\n\nlet module NotificationManager = {\n  type options = {detail: string, dismissable: bool, icon: string};\n  let optionsToJs opts => Js.Unsafe.obj [|\n    (\"detail\", Js.Unsafe.inject (Js.string opts.detail)),\n    (\"dismissable\", Js.Unsafe.inject (Js.bool opts.dismissable)),\n    (\"icon\", Js.Unsafe.inject (Js.string opts.icon))\n  |];\n  let defaultOptions = {detail: \"MessageNotProvided\", dismissable: false, icon: \"flame\"};\n  let addError options::opts={...defaultOptions, icon: \"flame\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addError\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addWarning options::opts={...defaultOptions, icon: \"alert\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addWarning\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addInfo options::opts={...defaultOptions, icon: \"info\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addInfo\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addSuccess options::opts={...defaultOptions, icon: \"check\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addSuccess\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let getNotifications () => Array.to_list (\n    Js.to_array (Js.Unsafe.meth_call (Js.Unsafe.get atomGlobal \"notifications\") \"getNotifications\" emptyArgs)\n  );\n};\n\nlet module Process = {\n  type options = {cwd: string, env: Js.t unit, detached: bool};\n  let defaultOptions = {cwd: \".\", env: Js.Unsafe.obj [||], detached: false};\n};\n\nlet module ChildProcess = {\n  type t;\n  let writeStdin (process: t) str :unit =>\n    Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"write\" [|Js.Unsafe.inject (Js.string str)|];\n  let endStdin (process: t) => Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"end\" emptyArgs;\n};\n\nmodule type BufferedProcessSig = {\n  type t;\n  let create:\n    options::Process.options? =>\n    stdout::(string => unit)? =>\n    stderr::(string => unit)? =>\n    exit::(int => unit)? =>\n    args::list string =>\n    string =>\n    t;\n};\n\nlet module BufferedProcess = {\n  open Process;\n  type t;\n  let create options::opts=? stdout::stdOut=? stderr::stdErr=? exit::exit=? cmd args::args => {\n    let fields = [|\n      (\"command\", Js.Unsafe.inject (Js.string cmd)),\n      (\"args\", Js.Unsafe.inject (Js.array (Array.map Js.string (Array.of_list args))))\n    |];\n    let fields =\n      switch opts {\n      | None => fields\n      | Some opts => {\n          let jsOptions = Js.Unsafe.obj [|\n            (\"cwd\", Js.Unsafe.inject opts.cwd),\n            (\"env\", Js.Unsafe.inject opts.env),\n            (\"detached\", Js.Unsafe.inject (Js.bool opts.detached))\n          |];\n          Array.append fields [|(\"options\", jsOptions)|]\n        }\n      };\n    let fields =\n      switch stdOut {\n      | None => fields\n      | Some so => {\n          let cb jsStr => so (Js.to_string jsStr);\n          Array.append fields [|(\"stdout\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch stdErr {\n      | None => fields\n      | Some si => {\n          let cb jsStr => si (Js.to_string jsStr);\n          Array.append fields [|(\"stdin\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch exit {\n      | None => fields\n      | Some e => {\n          let cb eCode => e (Js.to_float eCode);\n          Array.append fields [|(\"exit\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    Js.Unsafe.new_obj bufferedProcess [|Js.Unsafe.obj fields|]\n  };\n  let onWillThrowError buffProcess fn :unit => {\n    let wrappedCb = Js.wrap_callback (\n      fun jsErrHandle => fn (Js.Unsafe.get jsErrHandle \"error\") (Js.Unsafe.get jsErrHandle \"handle\")\n    );\n    Js.Unsafe.meth_call buffProcess \"onWillThrowError\" [|Js.Unsafe.inject wrappedCb|]\n  };\n  let process (bufferedProcess: t) => Js.Unsafe.get bufferedProcess \"process\";\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.20 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.20 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.20 frontend - output
[ "return", true ]
# 0.20 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 20, "col": 37 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.20 frontend - output
[
  "return",
  [
    {
      "start": { "line": 20, "col": 34 },
      "end": { "line": 20, "col": 79 },
      "type": "string",
      "tail": "no"
    },
    {
      "start": { "line": 20, "col": 16 },
      "end": { "line": 20, "col": 79 },
      "type": "'a",
      "tail": "no"
    }
  ]
]
# 0.20 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.20 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.20 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* Only temporarily needed. */\nlet jsTrimTrailing = Js.Unsafe.js_expr \"function(s) {return s.split('\\\\n').map(function(ss) {return ss.trimRight()}).join('\\\\n');}\";\n\nlet atomGlobal = Js.Unsafe.js_expr \"atom\";\n\n\nlet atomRange = Js.Unsafe.js_expr \"require('atom').Range\";\n\nlet bufferedProcess = Js.Unsafe.js_expr \"require('atom').BufferedProcess\";\n\n/* Yes, this doesn't work across iframes. */\nlet _isString = Js.Unsafe.js_expr \"function(s) {return typeof s === 'string' || s instanceof String;}\";\n\nlet _isNumber = Js.Unsafe.js_expr \"function(n) {return typeof n === 'number';}\";\n\nlet _isUndefined = Js.Unsafe.js_expr \"function(n) {return typeof n === 'undefined';}\";\n\nlet _isNull = Js.Unsafe.js_expr \"function(n) {return n === null;}\";\n\nlet _isBool = Js.Unsafe.js_expr \"function(n) {return typeof n === 'boolean';}\";\n\nlet _arrayIsArray = Js.Unsafe.js_expr \"Array.isArray\";\n\nlet promise = Js.Unsafe.js_expr \"Promise\";\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\nlet emptyArgs = [||];\n\nlet trimTrailingWhiteSpace (s: string) => Js.to_string (\n  Js.Unsafe.fun_call jsTrimTrailing [|Js.Unsafe.inject (Js.string s)|]\n);\n\nlet module JsonType = {\n  type t =\n    | JsonString of string | JsonNum of float | JsonBool of bool | JsonArray of (array t) | JsonNull | Empty;\n};\n\ntype completionEntry = {desc: string, info: string, kind: string, name: string};\n\n/**\n * Api over Js values that are known to adhere to \"Json\" style constraints (no\n * functions), untyped, but predictable.\n */\nmodule type JsonValueSig = {\n  /* We never want to reveal that t is actually just an unsafe JS value.\n   * We want everyone to go through the Apis which provide type safety. */\n  type t;\n  let fromJs: Js.t Js.js_string => JsonType.t;\n  let toJs: JsonType.t => Js.Unsafe.any;\n  let unsafeExtractString: JsonType.t => string;\n};\n\nlet module JsonValue: JsonValueSig = {\n  open JsonType;\n  type t = Js.Unsafe.any;\n  let rec fromJs fieldVal =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject fieldVal|]) {\n      let jsArray = Array.map fromJs (Js.to_array (Js.Unsafe.coerce fieldVal));\n      JsonArray jsArray\n    } else if (\n      Js.Unsafe.fun_call _isString [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonString (Js.to_string fieldVal)\n    } else if (\n      Js.Unsafe.fun_call _isBool [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonBool (Js.to_bool (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNumber [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNum (Js.float_of_number (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNull [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNull\n    } else {\n      Empty\n    };\n  let rec toJs =\n    fun | JsonString str => Js.Unsafe.inject (Js.string str)\n        | JsonNum f => Js.Unsafe.inject (Js.float f)\n        | JsonBool b => Js.Unsafe.inject (Js.bool b)\n        | JsonArray a => Js.Unsafe.inject (Js.array (Array.map toJs a))\n        | JsonNull => Js.Unsafe.inject Js.null\n        | Empty => Js.Unsafe.inject Js.undefined;\n  let unsafeExtractString o =>\n    switch o {\n    | JsonType.JsonString s => s\n    | _ => raise (Invalid_argument \"unsafeExtractString: not a string\")\n    };\n};\n\nlet module Env = {\n  let setEnvVar envVar strVal => {\n    Js.Unsafe.set (Js.Unsafe.get (Js.Unsafe.get Js.Unsafe.global \"process\") \"env\") envVar (Js.string strVal);\n    Js.Unsafe.set fixedEnv envVar (Js.string strVal)\n  };\n};\n\nlet module Config = {\n  let get configKey :JsonType.t => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    JsonValue.fromJs (Js.Unsafe.meth_call config \"get\" [|Js.Unsafe.inject (Js.string configKey)|])\n  };\n  let set configKey (v: JsonType.t) :unit => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    let jsVal = JsonValue.toJs v;\n    Js.Unsafe.meth_call config \"set\" [|Js.Unsafe.inject (Js.string configKey), Js.Unsafe.inject jsVal|]\n  };\n};\n\nlet module Point = {\n  type t = (int, int);\n  let toJs (row, column) => Js.Unsafe.inject (Js.array [|Js.Unsafe.inject row, Js.Unsafe.inject column|]);\n  let fromJs jsP =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsP|]) {\n      let arr = Js.to_array jsP;\n      (arr.(0), arr.(1))\n    } else {\n      let row = Js.Unsafe.get jsP \"row\";\n      let col = Js.Unsafe.get jsP \"column\";\n      (row, col)\n    };\n};\n\nlet module Range = {\n  type row = int;\n  type column = int;\n  type rowColumn = (row, column);\n  type t = (rowColumn as 'start, rowColumn as 'endd);\n  let emptyRange = ((0, 0), (0, 0));\n  let toJs (startRowColumn, endRowColumn) =>\n    Js.Unsafe.new_obj atomRange [|Point.toJs startRowColumn, Point.toJs endRowColumn|];\n  let fromJs jsRange =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsRange|]) {\n      let arr = Js.to_array jsRange;\n      let startPoint = Js.to_array arr.(0);\n      let endPoint = Js.to_array arr.(1);\n      ((startPoint.(0), startPoint.(1)), (endPoint.(0), endPoint.(1)))\n    } else {\n      let startPoint = Js.Unsafe.get jsRange \"start\";\n      let endPoint = Js.Unsafe.get jsRange \"end\";\n      (Point.fromJs startPoint, Point.fromJs endPoint)\n    };\n};\n\nlet module Buffer = {\n  type t = Js.Unsafe.any;\n  let fromJs jsBuffer :t => jsBuffer;\n  let toJs (buffer: t) :Js.Unsafe.any => buffer;\n  let characterIndexForPosition (buffer: t) rowColumn =>\n    Js.Unsafe.meth_call buffer \"characterIndexForPosition\" [|Js.Unsafe.inject (Point.toJs rowColumn)|];\n  let getText (buffer: t) :string => Js.to_string (Js.Unsafe.meth_call buffer \"getText\" emptyArgs);\n  let getTextInRange (buffer: t) (range: Range.t) :string => Js.to_string (\n    Js.Unsafe.meth_call buffer \"getTextInRange\" [|Range.toJs range|]\n  );\n};\n\nlet module Cursor = {\n  /* Actually just the underlying JS value - TODO: obscure this using\n   * signature. */\n  type t;\n  let getBufferPosition (cursor: t) => Point.fromJs (\n    Js.Unsafe.meth_call cursor \"getBufferPosition\" emptyArgs\n  );\n  let setBufferPosition position::(pos: Point.t) autoScroll::(autoScroll: bool) (cursor: t) => {\n    let optionsObj = Js.Unsafe.obj [|(\"autoscroll\", Js.Unsafe.inject (Js.bool autoScroll))|];\n    let args = [|Point.toJs pos, optionsObj|];\n    Point.fromJs (Js.Unsafe.meth_call cursor \"setBufferPosition\" args)\n  };\n  let fromJs jsCursor => jsCursor;\n};\n\nlet module Editor = {\n  type t = Js.Unsafe.any;\n  let fromJs jsEditor :t => jsEditor;\n  let toJs (editor: t) :Js.Unsafe.any => editor;\n  let lineTextForBufferRow (editor: t) bufferRow => Js.to_string (\n    Js.Unsafe.meth_call editor \"lineTextForBufferRow\" [|bufferRow|]\n  );\n  let getBuffer editor :Buffer.t => Js.Unsafe.meth_call editor \"getBuffer\" emptyArgs;\n  let getPath editor => {\n    let path = Js.Unsafe.meth_call editor \"getPath\" emptyArgs;\n    Js.Opt.test path ? Some (Js.to_string path) : None\n  };\n  let getCursors editor => {\n    let arr = Array.map Cursor.fromJs (Js.to_array (Js.Unsafe.meth_call editor \"getCursors\" emptyArgs));\n    Array.to_list arr\n  };\n  let setSelectedBufferRanges editor bufferRanges => {\n    let arr = Array.map Range.toJs bufferRanges |> Js.array;\n    Js.Unsafe.meth_call editor \"setSelectedBufferRanges\" [|Js.Unsafe.inject arr|];\n  }\n};\n\n/**\n * Dirt simple promise wrapper, not implementing advanced features yet.\n */\nlet module Promise = {\n  /* This should be made abstract so it's essentially private. */\n  type underlyingJsPromise;\n  type t 'i 'o = {\n    underlyingJsPromise: underlyingJsPromise,\n    /* Try adding constraint where 'o = t 'ii 'oo for some 'ii 'oo */\n    /* Perhaps the higher ranked polymorphism feature would work here */\n    /* One promise's output is another promise's input. */\n    thn: 'nextO .('i => 'o) => t 'o 'nextO\n  };\n  let toJs p => p.underlyingJsPromise;\n  let create executor => {\n    let jsCurriedExecutor = Js.wrap_callback executor;\n    let underlyingJsPromise = Js.Unsafe.new_obj promise [|Js.Unsafe.inject jsCurriedExecutor|];\n    {\n      underlyingJsPromise,\n      thn: fun onResolve =>\n        Js.Unsafe.meth_call underlyingJsPromise \"then\" [|Js.Unsafe.inject (Js.wrap_callback onResolve)|]\n    }\n  };\n  let resolve v => create (fun jsResolveCb jsRejectCb => Js.Unsafe.fun_call jsResolveCb [|v|]);\n  /* For our current purposes, a promise (with no chaining abilities) is enough. */\n  let createFakePromise (executor: ('a => unit) => ('b => unit) => unit) =>\n    Js.Unsafe.new_obj promise [|Js.Unsafe.inject (Js.wrap_callback executor)|];\n};\n\nlet module Notification = {\n  type t;\n  let getType (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getType\" emptyArgs);\n  let getMessage (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getMessage\" emptyArgs);\n  let dismiss (n: t) => Js.Unsafe.meth_call n \"dismiss\" emptyArgs;\n};\n\nlet module NotificationManager = {\n  type options = {detail: string, dismissable: bool, icon: string};\n  let optionsToJs opts => Js.Unsafe.obj [|\n    (\"detail\", Js.Unsafe.inject (Js.string opts.detail)),\n    (\"dismissable\", Js.Unsafe.inject (Js.bool opts.dismissable)),\n    (\"icon\", Js.Unsafe.inject (Js.string opts.icon))\n  |];\n  let defaultOptions = {detail: \"MessageNotProvided\", dismissable: false, icon: \"flame\"};\n  let addError options::opts={...defaultOptions, icon: \"flame\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addError\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addWarning options::opts={...defaultOptions, icon: \"alert\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addWarning\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addInfo options::opts={...defaultOptions, icon: \"info\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addInfo\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addSuccess options::opts={...defaultOptions, icon: \"check\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addSuccess\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let getNotifications () => Array.to_list (\n    Js.to_array (Js.Unsafe.meth_call (Js.Unsafe.get atomGlobal \"notifications\") \"getNotifications\" emptyArgs)\n  );\n};\n\nlet module Process = {\n  type options = {cwd: string, env: Js.t unit, detached: bool};\n  let defaultOptions = {cwd: \".\", env: Js.Unsafe.obj [||], detached: false};\n};\n\nlet module ChildProcess = {\n  type t;\n  let writeStdin (process: t) str :unit =>\n    Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"write\" [|Js.Unsafe.inject (Js.string str)|];\n  let endStdin (process: t) => Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"end\" emptyArgs;\n};\n\nmodule type BufferedProcessSig = {\n  type t;\n  let create:\n    options::Process.options? =>\n    stdout::(string => unit)? =>\n    stderr::(string => unit)? =>\n    exit::(int => unit)? =>\n    args::list string =>\n    string =>\n    t;\n};\n\nlet module BufferedProcess = {\n  open Process;\n  type t;\n  let create options::opts=? stdout::stdOut=? stderr::stdErr=? exit::exit=? cmd args::args => {\n    let fields = [|\n      (\"command\", Js.Unsafe.inject (Js.string cmd)),\n      (\"args\", Js.Unsafe.inject (Js.array (Array.map Js.string (Array.of_list args))))\n    |];\n    let fields =\n      switch opts {\n      | None => fields\n      | Some opts => {\n          let jsOptions = Js.Unsafe.obj [|\n            (\"cwd\", Js.Unsafe.inject opts.cwd),\n            (\"env\", Js.Unsafe.inject opts.env),\n            (\"detached\", Js.Unsafe.inject (Js.bool opts.detached))\n          |];\n          Array.append fields [|(\"options\", jsOptions)|]\n        }\n      };\n    let fields =\n      switch stdOut {\n      | None => fields\n      | Some so => {\n          let cb jsStr => so (Js.to_string jsStr);\n          Array.append fields [|(\"stdout\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch stdErr {\n      | None => fields\n      | Some si => {\n          let cb jsStr => si (Js.to_string jsStr);\n          Array.append fields [|(\"stdin\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch exit {\n      | None => fields\n      | Some e => {\n          let cb eCode => e (Js.to_float eCode);\n          Array.append fields [|(\"exit\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    Js.Unsafe.new_obj bufferedProcess [|Js.Unsafe.obj fields|]\n  };\n  let onWillThrowError buffProcess fn :unit => {\n    let wrappedCb = Js.wrap_callback (\n      fun jsErrHandle => fn (Js.Unsafe.get jsErrHandle \"error\") (Js.Unsafe.get jsErrHandle \"handle\")\n    );\n    Js.Unsafe.meth_call buffProcess \"onWillThrowError\" [|Js.Unsafe.inject wrappedCb|]\n  };\n  let process (bufferedProcess: t) => Js.Unsafe.get bufferedProcess \"process\";\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.20 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.20 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.20 frontend - output
[ "return", true ]
# 0.20 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.21 frontend - output
[ "return", [] ]
# 0.21 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.21 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.21 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* Only temporarily needed. */\nlet jsTrimTrailing = Js.Unsafe.js_expr \"function(s) {return s.split('\\\\n').map(function(ss) {return ss.trimRight()}).join('\\\\n');}\";\n\nlet atomGlobal = Js.Unsafe.js_expr \"atom\";\nL\n\nlet atomRange = Js.Unsafe.js_expr \"require('atom').Range\";\n\nlet bufferedProcess = Js.Unsafe.js_expr \"require('atom').BufferedProcess\";\n\n/* Yes, this doesn't work across iframes. */\nlet _isString = Js.Unsafe.js_expr \"function(s) {return typeof s === 'string' || s instanceof String;}\";\n\nlet _isNumber = Js.Unsafe.js_expr \"function(n) {return typeof n === 'number';}\";\n\nlet _isUndefined = Js.Unsafe.js_expr \"function(n) {return typeof n === 'undefined';}\";\n\nlet _isNull = Js.Unsafe.js_expr \"function(n) {return n === null;}\";\n\nlet _isBool = Js.Unsafe.js_expr \"function(n) {return typeof n === 'boolean';}\";\n\nlet _arrayIsArray = Js.Unsafe.js_expr \"Array.isArray\";\n\nlet promise = Js.Unsafe.js_expr \"Promise\";\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\nlet emptyArgs = [||];\n\nlet trimTrailingWhiteSpace (s: string) => Js.to_string (\n  Js.Unsafe.fun_call jsTrimTrailing [|Js.Unsafe.inject (Js.string s)|]\n);\n\nlet module JsonType = {\n  type t =\n    | JsonString of string | JsonNum of float | JsonBool of bool | JsonArray of (array t) | JsonNull | Empty;\n};\n\ntype completionEntry = {desc: string, info: string, kind: string, name: string};\n\n/**\n * Api over Js values that are known to adhere to \"Json\" style constraints (no\n * functions), untyped, but predictable.\n */\nmodule type JsonValueSig = {\n  /* We never want to reveal that t is actually just an unsafe JS value.\n   * We want everyone to go through the Apis which provide type safety. */\n  type t;\n  let fromJs: Js.t Js.js_string => JsonType.t;\n  let toJs: JsonType.t => Js.Unsafe.any;\n  let unsafeExtractString: JsonType.t => string;\n};\n\nlet module JsonValue: JsonValueSig = {\n  open JsonType;\n  type t = Js.Unsafe.any;\n  let rec fromJs fieldVal =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject fieldVal|]) {\n      let jsArray = Array.map fromJs (Js.to_array (Js.Unsafe.coerce fieldVal));\n      JsonArray jsArray\n    } else if (\n      Js.Unsafe.fun_call _isString [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonString (Js.to_string fieldVal)\n    } else if (\n      Js.Unsafe.fun_call _isBool [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonBool (Js.to_bool (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNumber [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNum (Js.float_of_number (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNull [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNull\n    } else {\n      Empty\n    };\n  let rec toJs =\n    fun | JsonString str => Js.Unsafe.inject (Js.string str)\n        | JsonNum f => Js.Unsafe.inject (Js.float f)\n        | JsonBool b => Js.Unsafe.inject (Js.bool b)\n        | JsonArray a => Js.Unsafe.inject (Js.array (Array.map toJs a))\n        | JsonNull => Js.Unsafe.inject Js.null\n        | Empty => Js.Unsafe.inject Js.undefined;\n  let unsafeExtractString o =>\n    switch o {\n    | JsonType.JsonString s => s\n    | _ => raise (Invalid_argument \"unsafeExtractString: not a string\")\n    };\n};\n\nlet module Env = {\n  let setEnvVar envVar strVal => {\n    Js.Unsafe.set (Js.Unsafe.get (Js.Unsafe.get Js.Unsafe.global \"process\") \"env\") envVar (Js.string strVal);\n    Js.Unsafe.set fixedEnv envVar (Js.string strVal)\n  };\n};\n\nlet module Config = {\n  let get configKey :JsonType.t => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    JsonValue.fromJs (Js.Unsafe.meth_call config \"get\" [|Js.Unsafe.inject (Js.string configKey)|])\n  };\n  let set configKey (v: JsonType.t) :unit => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    let jsVal = JsonValue.toJs v;\n    Js.Unsafe.meth_call config \"set\" [|Js.Unsafe.inject (Js.string configKey), Js.Unsafe.inject jsVal|]\n  };\n};\n\nlet module Point = {\n  type t = (int, int);\n  let toJs (row, column) => Js.Unsafe.inject (Js.array [|Js.Unsafe.inject row, Js.Unsafe.inject column|]);\n  let fromJs jsP =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsP|]) {\n      let arr = Js.to_array jsP;\n      (arr.(0), arr.(1))\n    } else {\n      let row = Js.Unsafe.get jsP \"row\";\n      let col = Js.Unsafe.get jsP \"column\";\n      (row, col)\n    };\n};\n\nlet module Range = {\n  type row = int;\n  type column = int;\n  type rowColumn = (row, column);\n  type t = (rowColumn as 'start, rowColumn as 'endd);\n  let emptyRange = ((0, 0), (0, 0));\n  let toJs (startRowColumn, endRowColumn) =>\n    Js.Unsafe.new_obj atomRange [|Point.toJs startRowColumn, Point.toJs endRowColumn|];\n  let fromJs jsRange =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsRange|]) {\n      let arr = Js.to_array jsRange;\n      let startPoint = Js.to_array arr.(0);\n      let endPoint = Js.to_array arr.(1);\n      ((startPoint.(0), startPoint.(1)), (endPoint.(0), endPoint.(1)))\n    } else {\n      let startPoint = Js.Unsafe.get jsRange \"start\";\n      let endPoint = Js.Unsafe.get jsRange \"end\";\n      (Point.fromJs startPoint, Point.fromJs endPoint)\n    };\n};\n\nlet module Buffer = {\n  type t = Js.Unsafe.any;\n  let fromJs jsBuffer :t => jsBuffer;\n  let toJs (buffer: t) :Js.Unsafe.any => buffer;\n  let characterIndexForPosition (buffer: t) rowColumn =>\n    Js.Unsafe.meth_call buffer \"characterIndexForPosition\" [|Js.Unsafe.inject (Point.toJs rowColumn)|];\n  let getText (buffer: t) :string => Js.to_string (Js.Unsafe.meth_call buffer \"getText\" emptyArgs);\n  let getTextInRange (buffer: t) (range: Range.t) :string => Js.to_string (\n    Js.Unsafe.meth_call buffer \"getTextInRange\" [|Range.toJs range|]\n  );\n};\n\nlet module Cursor = {\n  /* Actually just the underlying JS value - TODO: obscure this using\n   * signature. */\n  type t;\n  let getBufferPosition (cursor: t) => Point.fromJs (\n    Js.Unsafe.meth_call cursor \"getBufferPosition\" emptyArgs\n  );\n  let setBufferPosition position::(pos: Point.t) autoScroll::(autoScroll: bool) (cursor: t) => {\n    let optionsObj = Js.Unsafe.obj [|(\"autoscroll\", Js.Unsafe.inject (Js.bool autoScroll))|];\n    let args = [|Point.toJs pos, optionsObj|];\n    Point.fromJs (Js.Unsafe.meth_call cursor \"setBufferPosition\" args)\n  };\n  let fromJs jsCursor => jsCursor;\n};\n\nlet module Editor = {\n  type t = Js.Unsafe.any;\n  let fromJs jsEditor :t => jsEditor;\n  let toJs (editor: t) :Js.Unsafe.any => editor;\n  let lineTextForBufferRow (editor: t) bufferRow => Js.to_string (\n    Js.Unsafe.meth_call editor \"lineTextForBufferRow\" [|bufferRow|]\n  );\n  let getBuffer editor :Buffer.t => Js.Unsafe.meth_call editor \"getBuffer\" emptyArgs;\n  let getPath editor => {\n    let path = Js.Unsafe.meth_call editor \"getPath\" emptyArgs;\n    Js.Opt.test path ? Some (Js.to_string path) : None\n  };\n  let getCursors editor => {\n    let arr = Array.map Cursor.fromJs (Js.to_array (Js.Unsafe.meth_call editor \"getCursors\" emptyArgs));\n    Array.to_list arr\n  };\n  let setSelectedBufferRanges editor bufferRanges => {\n    let arr = Array.map Range.toJs bufferRanges |> Js.array;\n    Js.Unsafe.meth_call editor \"setSelectedBufferRanges\" [|Js.Unsafe.inject arr|];\n  }\n};\n\n/**\n * Dirt simple promise wrapper, not implementing advanced features yet.\n */\nlet module Promise = {\n  /* This should be made abstract so it's essentially private. */\n  type underlyingJsPromise;\n  type t 'i 'o = {\n    underlyingJsPromise: underlyingJsPromise,\n    /* Try adding constraint where 'o = t 'ii 'oo for some 'ii 'oo */\n    /* Perhaps the higher ranked polymorphism feature would work here */\n    /* One promise's output is another promise's input. */\n    thn: 'nextO .('i => 'o) => t 'o 'nextO\n  };\n  let toJs p => p.underlyingJsPromise;\n  let create executor => {\n    let jsCurriedExecutor = Js.wrap_callback executor;\n    let underlyingJsPromise = Js.Unsafe.new_obj promise [|Js.Unsafe.inject jsCurriedExecutor|];\n    {\n      underlyingJsPromise,\n      thn: fun onResolve =>\n        Js.Unsafe.meth_call underlyingJsPromise \"then\" [|Js.Unsafe.inject (Js.wrap_callback onResolve)|]\n    }\n  };\n  let resolve v => create (fun jsResolveCb jsRejectCb => Js.Unsafe.fun_call jsResolveCb [|v|]);\n  /* For our current purposes, a promise (with no chaining abilities) is enough. */\n  let createFakePromise (executor: ('a => unit) => ('b => unit) => unit) =>\n    Js.Unsafe.new_obj promise [|Js.Unsafe.inject (Js.wrap_callback executor)|];\n};\n\nlet module Notification = {\n  type t;\n  let getType (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getType\" emptyArgs);\n  let getMessage (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getMessage\" emptyArgs);\n  let dismiss (n: t) => Js.Unsafe.meth_call n \"dismiss\" emptyArgs;\n};\n\nlet module NotificationManager = {\n  type options = {detail: string, dismissable: bool, icon: string};\n  let optionsToJs opts => Js.Unsafe.obj [|\n    (\"detail\", Js.Unsafe.inject (Js.string opts.detail)),\n    (\"dismissable\", Js.Unsafe.inject (Js.bool opts.dismissable)),\n    (\"icon\", Js.Unsafe.inject (Js.string opts.icon))\n  |];\n  let defaultOptions = {detail: \"MessageNotProvided\", dismissable: false, icon: \"flame\"};\n  let addError options::opts={...defaultOptions, icon: \"flame\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addError\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addWarning options::opts={...defaultOptions, icon: \"alert\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addWarning\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addInfo options::opts={...defaultOptions, icon: \"info\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addInfo\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addSuccess options::opts={...defaultOptions, icon: \"check\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addSuccess\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let getNotifications () => Array.to_list (\n    Js.to_array (Js.Unsafe.meth_call (Js.Unsafe.get atomGlobal \"notifications\") \"getNotifications\" emptyArgs)\n  );\n};\n\nlet module Process = {\n  type options = {cwd: string, env: Js.t unit, detached: bool};\n  let defaultOptions = {cwd: \".\", env: Js.Unsafe.obj [||], detached: false};\n};\n\nlet module ChildProcess = {\n  type t;\n  let writeStdin (process: t) str :unit =>\n    Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"write\" [|Js.Unsafe.inject (Js.string str)|];\n  let endStdin (process: t) => Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"end\" emptyArgs;\n};\n\nmodule type BufferedProcessSig = {\n  type t;\n  let create:\n    options::Process.options? =>\n    stdout::(string => unit)? =>\n    stderr::(string => unit)? =>\n    exit::(int => unit)? =>\n    args::list string =>\n    string =>\n    t;\n};\n\nlet module BufferedProcess = {\n  open Process;\n  type t;\n  let create options::opts=? stdout::stdOut=? stderr::stdErr=? exit::exit=? cmd args::args => {\n    let fields = [|\n      (\"command\", Js.Unsafe.inject (Js.string cmd)),\n      (\"args\", Js.Unsafe.inject (Js.array (Array.map Js.string (Array.of_list args))))\n    |];\n    let fields =\n      switch opts {\n      | None => fields\n      | Some opts => {\n          let jsOptions = Js.Unsafe.obj [|\n            (\"cwd\", Js.Unsafe.inject opts.cwd),\n            (\"env\", Js.Unsafe.inject opts.env),\n            (\"detached\", Js.Unsafe.inject (Js.bool opts.detached))\n          |];\n          Array.append fields [|(\"options\", jsOptions)|]\n        }\n      };\n    let fields =\n      switch stdOut {\n      | None => fields\n      | Some so => {\n          let cb jsStr => so (Js.to_string jsStr);\n          Array.append fields [|(\"stdout\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch stdErr {\n      | None => fields\n      | Some si => {\n          let cb jsStr => si (Js.to_string jsStr);\n          Array.append fields [|(\"stdin\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch exit {\n      | None => fields\n      | Some e => {\n          let cb eCode => e (Js.to_float eCode);\n          Array.append fields [|(\"exit\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    Js.Unsafe.new_obj bufferedProcess [|Js.Unsafe.obj fields|]\n  };\n  let onWillThrowError buffProcess fn :unit => {\n    let wrappedCb = Js.wrap_callback (\n      fun jsErrHandle => fn (Js.Unsafe.get jsErrHandle \"error\") (Js.Unsafe.get jsErrHandle \"handle\")\n    );\n    Js.Unsafe.meth_call buffProcess \"onWillThrowError\" [|Js.Unsafe.inject wrappedCb|]\n  };\n  let process (bufferedProcess: t) => Js.Unsafe.get bufferedProcess \"process\";\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.21 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.21 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.21 frontend - output
[ "return", true ]
# 0.21 frontend - input
{
  "query": [ "complete", "prefix", "L", "at", { "line": 12, "col": 1 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.21 frontend - output
[
  "return",
  {
    "entries": [
      { "name": "LargeFile", "kind": "Module", "desc": "", "info": "" },
      { "name": "ListLabels", "kind": "Module", "desc": "", "info": "" },
      { "name": "List", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lexing", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lazy", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_unix", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_timeout", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_throttle", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_sys", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_switch", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_stream", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_ssl", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_sequence", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_react", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_process", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_preemptive", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_pqueue", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_pool", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_mvar", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_mutex", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_main", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log_rules", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log_core", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_list", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_io", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_gc", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_engine", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_daemon", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_condition", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_chan", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_bytes", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_log_js", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_js_events", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lwt_js", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lib_version", "kind": "Module", "desc": "", "info": "" }
    ],
    "context": null
  }
]
# 0.22 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.22 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.22 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* Only temporarily needed. */\nlet jsTrimTrailing = Js.Unsafe.js_expr \"function(s) {return s.split('\\\\n').map(function(ss) {return ss.trimRight()}).join('\\\\n');}\";\n\nlet atomGlobal = Js.Unsafe.js_expr \"atom\";\nLi\n\nlet atomRange = Js.Unsafe.js_expr \"require('atom').Range\";\n\nlet bufferedProcess = Js.Unsafe.js_expr \"require('atom').BufferedProcess\";\n\n/* Yes, this doesn't work across iframes. */\nlet _isString = Js.Unsafe.js_expr \"function(s) {return typeof s === 'string' || s instanceof String;}\";\n\nlet _isNumber = Js.Unsafe.js_expr \"function(n) {return typeof n === 'number';}\";\n\nlet _isUndefined = Js.Unsafe.js_expr \"function(n) {return typeof n === 'undefined';}\";\n\nlet _isNull = Js.Unsafe.js_expr \"function(n) {return n === null;}\";\n\nlet _isBool = Js.Unsafe.js_expr \"function(n) {return typeof n === 'boolean';}\";\n\nlet _arrayIsArray = Js.Unsafe.js_expr \"Array.isArray\";\n\nlet promise = Js.Unsafe.js_expr \"Promise\";\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\nlet emptyArgs = [||];\n\nlet trimTrailingWhiteSpace (s: string) => Js.to_string (\n  Js.Unsafe.fun_call jsTrimTrailing [|Js.Unsafe.inject (Js.string s)|]\n);\n\nlet module JsonType = {\n  type t =\n    | JsonString of string | JsonNum of float | JsonBool of bool | JsonArray of (array t) | JsonNull | Empty;\n};\n\ntype completionEntry = {desc: string, info: string, kind: string, name: string};\n\n/**\n * Api over Js values that are known to adhere to \"Json\" style constraints (no\n * functions), untyped, but predictable.\n */\nmodule type JsonValueSig = {\n  /* We never want to reveal that t is actually just an unsafe JS value.\n   * We want everyone to go through the Apis which provide type safety. */\n  type t;\n  let fromJs: Js.t Js.js_string => JsonType.t;\n  let toJs: JsonType.t => Js.Unsafe.any;\n  let unsafeExtractString: JsonType.t => string;\n};\n\nlet module JsonValue: JsonValueSig = {\n  open JsonType;\n  type t = Js.Unsafe.any;\n  let rec fromJs fieldVal =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject fieldVal|]) {\n      let jsArray = Array.map fromJs (Js.to_array (Js.Unsafe.coerce fieldVal));\n      JsonArray jsArray\n    } else if (\n      Js.Unsafe.fun_call _isString [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonString (Js.to_string fieldVal)\n    } else if (\n      Js.Unsafe.fun_call _isBool [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonBool (Js.to_bool (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNumber [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNum (Js.float_of_number (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNull [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNull\n    } else {\n      Empty\n    };\n  let rec toJs =\n    fun | JsonString str => Js.Unsafe.inject (Js.string str)\n        | JsonNum f => Js.Unsafe.inject (Js.float f)\n        | JsonBool b => Js.Unsafe.inject (Js.bool b)\n        | JsonArray a => Js.Unsafe.inject (Js.array (Array.map toJs a))\n        | JsonNull => Js.Unsafe.inject Js.null\n        | Empty => Js.Unsafe.inject Js.undefined;\n  let unsafeExtractString o =>\n    switch o {\n    | JsonType.JsonString s => s\n    | _ => raise (Invalid_argument \"unsafeExtractString: not a string\")\n    };\n};\n\nlet module Env = {\n  let setEnvVar envVar strVal => {\n    Js.Unsafe.set (Js.Unsafe.get (Js.Unsafe.get Js.Unsafe.global \"process\") \"env\") envVar (Js.string strVal);\n    Js.Unsafe.set fixedEnv envVar (Js.string strVal)\n  };\n};\n\nlet module Config = {\n  let get configKey :JsonType.t => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    JsonValue.fromJs (Js.Unsafe.meth_call config \"get\" [|Js.Unsafe.inject (Js.string configKey)|])\n  };\n  let set configKey (v: JsonType.t) :unit => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    let jsVal = JsonValue.toJs v;\n    Js.Unsafe.meth_call config \"set\" [|Js.Unsafe.inject (Js.string configKey), Js.Unsafe.inject jsVal|]\n  };\n};\n\nlet module Point = {\n  type t = (int, int);\n  let toJs (row, column) => Js.Unsafe.inject (Js.array [|Js.Unsafe.inject row, Js.Unsafe.inject column|]);\n  let fromJs jsP =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsP|]) {\n      let arr = Js.to_array jsP;\n      (arr.(0), arr.(1))\n    } else {\n      let row = Js.Unsafe.get jsP \"row\";\n      let col = Js.Unsafe.get jsP \"column\";\n      (row, col)\n    };\n};\n\nlet module Range = {\n  type row = int;\n  type column = int;\n  type rowColumn = (row, column);\n  type t = (rowColumn as 'start, rowColumn as 'endd);\n  let emptyRange = ((0, 0), (0, 0));\n  let toJs (startRowColumn, endRowColumn) =>\n    Js.Unsafe.new_obj atomRange [|Point.toJs startRowColumn, Point.toJs endRowColumn|];\n  let fromJs jsRange =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsRange|]) {\n      let arr = Js.to_array jsRange;\n      let startPoint = Js.to_array arr.(0);\n      let endPoint = Js.to_array arr.(1);\n      ((startPoint.(0), startPoint.(1)), (endPoint.(0), endPoint.(1)))\n    } else {\n      let startPoint = Js.Unsafe.get jsRange \"start\";\n      let endPoint = Js.Unsafe.get jsRange \"end\";\n      (Point.fromJs startPoint, Point.fromJs endPoint)\n    };\n};\n\nlet module Buffer = {\n  type t = Js.Unsafe.any;\n  let fromJs jsBuffer :t => jsBuffer;\n  let toJs (buffer: t) :Js.Unsafe.any => buffer;\n  let characterIndexForPosition (buffer: t) rowColumn =>\n    Js.Unsafe.meth_call buffer \"characterIndexForPosition\" [|Js.Unsafe.inject (Point.toJs rowColumn)|];\n  let getText (buffer: t) :string => Js.to_string (Js.Unsafe.meth_call buffer \"getText\" emptyArgs);\n  let getTextInRange (buffer: t) (range: Range.t) :string => Js.to_string (\n    Js.Unsafe.meth_call buffer \"getTextInRange\" [|Range.toJs range|]\n  );\n};\n\nlet module Cursor = {\n  /* Actually just the underlying JS value - TODO: obscure this using\n   * signature. */\n  type t;\n  let getBufferPosition (cursor: t) => Point.fromJs (\n    Js.Unsafe.meth_call cursor \"getBufferPosition\" emptyArgs\n  );\n  let setBufferPosition position::(pos: Point.t) autoScroll::(autoScroll: bool) (cursor: t) => {\n    let optionsObj = Js.Unsafe.obj [|(\"autoscroll\", Js.Unsafe.inject (Js.bool autoScroll))|];\n    let args = [|Point.toJs pos, optionsObj|];\n    Point.fromJs (Js.Unsafe.meth_call cursor \"setBufferPosition\" args)\n  };\n  let fromJs jsCursor => jsCursor;\n};\n\nlet module Editor = {\n  type t = Js.Unsafe.any;\n  let fromJs jsEditor :t => jsEditor;\n  let toJs (editor: t) :Js.Unsafe.any => editor;\n  let lineTextForBufferRow (editor: t) bufferRow => Js.to_string (\n    Js.Unsafe.meth_call editor \"lineTextForBufferRow\" [|bufferRow|]\n  );\n  let getBuffer editor :Buffer.t => Js.Unsafe.meth_call editor \"getBuffer\" emptyArgs;\n  let getPath editor => {\n    let path = Js.Unsafe.meth_call editor \"getPath\" emptyArgs;\n    Js.Opt.test path ? Some (Js.to_string path) : None\n  };\n  let getCursors editor => {\n    let arr = Array.map Cursor.fromJs (Js.to_array (Js.Unsafe.meth_call editor \"getCursors\" emptyArgs));\n    Array.to_list arr\n  };\n  let setSelectedBufferRanges editor bufferRanges => {\n    let arr = Array.map Range.toJs bufferRanges |> Js.array;\n    Js.Unsafe.meth_call editor \"setSelectedBufferRanges\" [|Js.Unsafe.inject arr|];\n  }\n};\n\n/**\n * Dirt simple promise wrapper, not implementing advanced features yet.\n */\nlet module Promise = {\n  /* This should be made abstract so it's essentially private. */\n  type underlyingJsPromise;\n  type t 'i 'o = {\n    underlyingJsPromise: underlyingJsPromise,\n    /* Try adding constraint where 'o = t 'ii 'oo for some 'ii 'oo */\n    /* Perhaps the higher ranked polymorphism feature would work here */\n    /* One promise's output is another promise's input. */\n    thn: 'nextO .('i => 'o) => t 'o 'nextO\n  };\n  let toJs p => p.underlyingJsPromise;\n  let create executor => {\n    let jsCurriedExecutor = Js.wrap_callback executor;\n    let underlyingJsPromise = Js.Unsafe.new_obj promise [|Js.Unsafe.inject jsCurriedExecutor|];\n    {\n      underlyingJsPromise,\n      thn: fun onResolve =>\n        Js.Unsafe.meth_call underlyingJsPromise \"then\" [|Js.Unsafe.inject (Js.wrap_callback onResolve)|]\n    }\n  };\n  let resolve v => create (fun jsResolveCb jsRejectCb => Js.Unsafe.fun_call jsResolveCb [|v|]);\n  /* For our current purposes, a promise (with no chaining abilities) is enough. */\n  let createFakePromise (executor: ('a => unit) => ('b => unit) => unit) =>\n    Js.Unsafe.new_obj promise [|Js.Unsafe.inject (Js.wrap_callback executor)|];\n};\n\nlet module Notification = {\n  type t;\n  let getType (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getType\" emptyArgs);\n  let getMessage (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getMessage\" emptyArgs);\n  let dismiss (n: t) => Js.Unsafe.meth_call n \"dismiss\" emptyArgs;\n};\n\nlet module NotificationManager = {\n  type options = {detail: string, dismissable: bool, icon: string};\n  let optionsToJs opts => Js.Unsafe.obj [|\n    (\"detail\", Js.Unsafe.inject (Js.string opts.detail)),\n    (\"dismissable\", Js.Unsafe.inject (Js.bool opts.dismissable)),\n    (\"icon\", Js.Unsafe.inject (Js.string opts.icon))\n  |];\n  let defaultOptions = {detail: \"MessageNotProvided\", dismissable: false, icon: \"flame\"};\n  let addError options::opts={...defaultOptions, icon: \"flame\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addError\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addWarning options::opts={...defaultOptions, icon: \"alert\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addWarning\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addInfo options::opts={...defaultOptions, icon: \"info\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addInfo\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addSuccess options::opts={...defaultOptions, icon: \"check\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addSuccess\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let getNotifications () => Array.to_list (\n    Js.to_array (Js.Unsafe.meth_call (Js.Unsafe.get atomGlobal \"notifications\") \"getNotifications\" emptyArgs)\n  );\n};\n\nlet module Process = {\n  type options = {cwd: string, env: Js.t unit, detached: bool};\n  let defaultOptions = {cwd: \".\", env: Js.Unsafe.obj [||], detached: false};\n};\n\nlet module ChildProcess = {\n  type t;\n  let writeStdin (process: t) str :unit =>\n    Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"write\" [|Js.Unsafe.inject (Js.string str)|];\n  let endStdin (process: t) => Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"end\" emptyArgs;\n};\n\nmodule type BufferedProcessSig = {\n  type t;\n  let create:\n    options::Process.options? =>\n    stdout::(string => unit)? =>\n    stderr::(string => unit)? =>\n    exit::(int => unit)? =>\n    args::list string =>\n    string =>\n    t;\n};\n\nlet module BufferedProcess = {\n  open Process;\n  type t;\n  let create options::opts=? stdout::stdOut=? stderr::stdErr=? exit::exit=? cmd args::args => {\n    let fields = [|\n      (\"command\", Js.Unsafe.inject (Js.string cmd)),\n      (\"args\", Js.Unsafe.inject (Js.array (Array.map Js.string (Array.of_list args))))\n    |];\n    let fields =\n      switch opts {\n      | None => fields\n      | Some opts => {\n          let jsOptions = Js.Unsafe.obj [|\n            (\"cwd\", Js.Unsafe.inject opts.cwd),\n            (\"env\", Js.Unsafe.inject opts.env),\n            (\"detached\", Js.Unsafe.inject (Js.bool opts.detached))\n          |];\n          Array.append fields [|(\"options\", jsOptions)|]\n        }\n      };\n    let fields =\n      switch stdOut {\n      | None => fields\n      | Some so => {\n          let cb jsStr => so (Js.to_string jsStr);\n          Array.append fields [|(\"stdout\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch stdErr {\n      | None => fields\n      | Some si => {\n          let cb jsStr => si (Js.to_string jsStr);\n          Array.append fields [|(\"stdin\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch exit {\n      | None => fields\n      | Some e => {\n          let cb eCode => e (Js.to_float eCode);\n          Array.append fields [|(\"exit\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    Js.Unsafe.new_obj bufferedProcess [|Js.Unsafe.obj fields|]\n  };\n  let onWillThrowError buffProcess fn :unit => {\n    let wrappedCb = Js.wrap_callback (\n      fun jsErrHandle => fn (Js.Unsafe.get jsErrHandle \"error\") (Js.Unsafe.get jsErrHandle \"handle\")\n    );\n    Js.Unsafe.meth_call buffProcess \"onWillThrowError\" [|Js.Unsafe.inject wrappedCb|]\n  };\n  let process (bufferedProcess: t) => Js.Unsafe.get bufferedProcess \"process\";\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.22 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.22 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.22 frontend - output
[ "return", true ]
# 0.22 frontend - input
{
  "query": [ "complete", "prefix", "Li", "at", { "line": 12, "col": 2 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.22 frontend - output
[
  "return",
  {
    "entries": [
      { "name": "ListLabels", "kind": "Module", "desc": "", "info": "" },
      { "name": "List", "kind": "Module", "desc": "", "info": "" },
      { "name": "Lib_version", "kind": "Module", "desc": "", "info": "" }
    ],
    "context": null
  }
]
# 0.22 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.22 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.22 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* Only temporarily needed. */\nlet jsTrimTrailing = Js.Unsafe.js_expr \"function(s) {return s.split('\\\\n').map(function(ss) {return ss.trimRight()}).join('\\\\n');}\";\n\nlet atomGlobal = Js.Unsafe.js_expr \"atom\";\nLi\n\nlet atomRange = Js.Unsafe.js_expr \"require('atom').Range\";\n\nlet bufferedProcess = Js.Unsafe.js_expr \"require('atom').BufferedProcess\";\n\n/* Yes, this doesn't work across iframes. */\nlet _isString = Js.Unsafe.js_expr \"function(s) {return typeof s === 'string' || s instanceof String;}\";\n\nlet _isNumber = Js.Unsafe.js_expr \"function(n) {return typeof n === 'number';}\";\n\nlet _isUndefined = Js.Unsafe.js_expr \"function(n) {return typeof n === 'undefined';}\";\n\nlet _isNull = Js.Unsafe.js_expr \"function(n) {return n === null;}\";\n\nlet _isBool = Js.Unsafe.js_expr \"function(n) {return typeof n === 'boolean';}\";\n\nlet _arrayIsArray = Js.Unsafe.js_expr \"Array.isArray\";\n\nlet promise = Js.Unsafe.js_expr \"Promise\";\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\nlet emptyArgs = [||];\n\nlet trimTrailingWhiteSpace (s: string) => Js.to_string (\n  Js.Unsafe.fun_call jsTrimTrailing [|Js.Unsafe.inject (Js.string s)|]\n);\n\nlet module JsonType = {\n  type t =\n    | JsonString of string | JsonNum of float | JsonBool of bool | JsonArray of (array t) | JsonNull | Empty;\n};\n\ntype completionEntry = {desc: string, info: string, kind: string, name: string};\n\n/**\n * Api over Js values that are known to adhere to \"Json\" style constraints (no\n * functions), untyped, but predictable.\n */\nmodule type JsonValueSig = {\n  /* We never want to reveal that t is actually just an unsafe JS value.\n   * We want everyone to go through the Apis which provide type safety. */\n  type t;\n  let fromJs: Js.t Js.js_string => JsonType.t;\n  let toJs: JsonType.t => Js.Unsafe.any;\n  let unsafeExtractString: JsonType.t => string;\n};\n\nlet module JsonValue: JsonValueSig = {\n  open JsonType;\n  type t = Js.Unsafe.any;\n  let rec fromJs fieldVal =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject fieldVal|]) {\n      let jsArray = Array.map fromJs (Js.to_array (Js.Unsafe.coerce fieldVal));\n      JsonArray jsArray\n    } else if (\n      Js.Unsafe.fun_call _isString [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonString (Js.to_string fieldVal)\n    } else if (\n      Js.Unsafe.fun_call _isBool [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonBool (Js.to_bool (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNumber [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNum (Js.float_of_number (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNull [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNull\n    } else {\n      Empty\n    };\n  let rec toJs =\n    fun | JsonString str => Js.Unsafe.inject (Js.string str)\n        | JsonNum f => Js.Unsafe.inject (Js.float f)\n        | JsonBool b => Js.Unsafe.inject (Js.bool b)\n        | JsonArray a => Js.Unsafe.inject (Js.array (Array.map toJs a))\n        | JsonNull => Js.Unsafe.inject Js.null\n        | Empty => Js.Unsafe.inject Js.undefined;\n  let unsafeExtractString o =>\n    switch o {\n    | JsonType.JsonString s => s\n    | _ => raise (Invalid_argument \"unsafeExtractString: not a string\")\n    };\n};\n\nlet module Env = {\n  let setEnvVar envVar strVal => {\n    Js.Unsafe.set (Js.Unsafe.get (Js.Unsafe.get Js.Unsafe.global \"process\") \"env\") envVar (Js.string strVal);\n    Js.Unsafe.set fixedEnv envVar (Js.string strVal)\n  };\n};\n\nlet module Config = {\n  let get configKey :JsonType.t => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    JsonValue.fromJs (Js.Unsafe.meth_call config \"get\" [|Js.Unsafe.inject (Js.string configKey)|])\n  };\n  let set configKey (v: JsonType.t) :unit => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    let jsVal = JsonValue.toJs v;\n    Js.Unsafe.meth_call config \"set\" [|Js.Unsafe.inject (Js.string configKey), Js.Unsafe.inject jsVal|]\n  };\n};\n\nlet module Point = {\n  type t = (int, int);\n  let toJs (row, column) => Js.Unsafe.inject (Js.array [|Js.Unsafe.inject row, Js.Unsafe.inject column|]);\n  let fromJs jsP =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsP|]) {\n      let arr = Js.to_array jsP;\n      (arr.(0), arr.(1))\n    } else {\n      let row = Js.Unsafe.get jsP \"row\";\n      let col = Js.Unsafe.get jsP \"column\";\n      (row, col)\n    };\n};\n\nlet module Range = {\n  type row = int;\n  type column = int;\n  type rowColumn = (row, column);\n  type t = (rowColumn as 'start, rowColumn as 'endd);\n  let emptyRange = ((0, 0), (0, 0));\n  let toJs (startRowColumn, endRowColumn) =>\n    Js.Unsafe.new_obj atomRange [|Point.toJs startRowColumn, Point.toJs endRowColumn|];\n  let fromJs jsRange =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsRange|]) {\n      let arr = Js.to_array jsRange;\n      let startPoint = Js.to_array arr.(0);\n      let endPoint = Js.to_array arr.(1);\n      ((startPoint.(0), startPoint.(1)), (endPoint.(0), endPoint.(1)))\n    } else {\n      let startPoint = Js.Unsafe.get jsRange \"start\";\n      let endPoint = Js.Unsafe.get jsRange \"end\";\n      (Point.fromJs startPoint, Point.fromJs endPoint)\n    };\n};\n\nlet module Buffer = {\n  type t = Js.Unsafe.any;\n  let fromJs jsBuffer :t => jsBuffer;\n  let toJs (buffer: t) :Js.Unsafe.any => buffer;\n  let characterIndexForPosition (buffer: t) rowColumn =>\n    Js.Unsafe.meth_call buffer \"characterIndexForPosition\" [|Js.Unsafe.inject (Point.toJs rowColumn)|];\n  let getText (buffer: t) :string => Js.to_string (Js.Unsafe.meth_call buffer \"getText\" emptyArgs);\n  let getTextInRange (buffer: t) (range: Range.t) :string => Js.to_string (\n    Js.Unsafe.meth_call buffer \"getTextInRange\" [|Range.toJs range|]\n  );\n};\n\nlet module Cursor = {\n  /* Actually just the underlying JS value - TODO: obscure this using\n   * signature. */\n  type t;\n  let getBufferPosition (cursor: t) => Point.fromJs (\n    Js.Unsafe.meth_call cursor \"getBufferPosition\" emptyArgs\n  );\n  let setBufferPosition position::(pos: Point.t) autoScroll::(autoScroll: bool) (cursor: t) => {\n    let optionsObj = Js.Unsafe.obj [|(\"autoscroll\", Js.Unsafe.inject (Js.bool autoScroll))|];\n    let args = [|Point.toJs pos, optionsObj|];\n    Point.fromJs (Js.Unsafe.meth_call cursor \"setBufferPosition\" args)\n  };\n  let fromJs jsCursor => jsCursor;\n};\n\nlet module Editor = {\n  type t = Js.Unsafe.any;\n  let fromJs jsEditor :t => jsEditor;\n  let toJs (editor: t) :Js.Unsafe.any => editor;\n  let lineTextForBufferRow (editor: t) bufferRow => Js.to_string (\n    Js.Unsafe.meth_call editor \"lineTextForBufferRow\" [|bufferRow|]\n  );\n  let getBuffer editor :Buffer.t => Js.Unsafe.meth_call editor \"getBuffer\" emptyArgs;\n  let getPath editor => {\n    let path = Js.Unsafe.meth_call editor \"getPath\" emptyArgs;\n    Js.Opt.test path ? Some (Js.to_string path) : None\n  };\n  let getCursors editor => {\n    let arr = Array.map Cursor.fromJs (Js.to_array (Js.Unsafe.meth_call editor \"getCursors\" emptyArgs));\n    Array.to_list arr\n  };\n  let setSelectedBufferRanges editor bufferRanges => {\n    let arr = Array.map Range.toJs bufferRanges |> Js.array;\n    Js.Unsafe.meth_call editor \"setSelectedBufferRanges\" [|Js.Unsafe.inject arr|];\n  }\n};\n\n/**\n * Dirt simple promise wrapper, not implementing advanced features yet.\n */\nlet module Promise = {\n  /* This should be made abstract so it's essentially private. */\n  type underlyingJsPromise;\n  type t 'i 'o = {\n    underlyingJsPromise: underlyingJsPromise,\n    /* Try adding constraint where 'o = t 'ii 'oo for some 'ii 'oo */\n    /* Perhaps the higher ranked polymorphism feature would work here */\n    /* One promise's output is another promise's input. */\n    thn: 'nextO .('i => 'o) => t 'o 'nextO\n  };\n  let toJs p => p.underlyingJsPromise;\n  let create executor => {\n    let jsCurriedExecutor = Js.wrap_callback executor;\n    let underlyingJsPromise = Js.Unsafe.new_obj promise [|Js.Unsafe.inject jsCurriedExecutor|];\n    {\n      underlyingJsPromise,\n      thn: fun onResolve =>\n        Js.Unsafe.meth_call underlyingJsPromise \"then\" [|Js.Unsafe.inject (Js.wrap_callback onResolve)|]\n    }\n  };\n  let resolve v => create (fun jsResolveCb jsRejectCb => Js.Unsafe.fun_call jsResolveCb [|v|]);\n  /* For our current purposes, a promise (with no chaining abilities) is enough. */\n  let createFakePromise (executor: ('a => unit) => ('b => unit) => unit) =>\n    Js.Unsafe.new_obj promise [|Js.Unsafe.inject (Js.wrap_callback executor)|];\n};\n\nlet module Notification = {\n  type t;\n  let getType (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getType\" emptyArgs);\n  let getMessage (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getMessage\" emptyArgs);\n  let dismiss (n: t) => Js.Unsafe.meth_call n \"dismiss\" emptyArgs;\n};\n\nlet module NotificationManager = {\n  type options = {detail: string, dismissable: bool, icon: string};\n  let optionsToJs opts => Js.Unsafe.obj [|\n    (\"detail\", Js.Unsafe.inject (Js.string opts.detail)),\n    (\"dismissable\", Js.Unsafe.inject (Js.bool opts.dismissable)),\n    (\"icon\", Js.Unsafe.inject (Js.string opts.icon))\n  |];\n  let defaultOptions = {detail: \"MessageNotProvided\", dismissable: false, icon: \"flame\"};\n  let addError options::opts={...defaultOptions, icon: \"flame\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addError\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addWarning options::opts={...defaultOptions, icon: \"alert\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addWarning\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addInfo options::opts={...defaultOptions, icon: \"info\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addInfo\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addSuccess options::opts={...defaultOptions, icon: \"check\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addSuccess\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let getNotifications () => Array.to_list (\n    Js.to_array (Js.Unsafe.meth_call (Js.Unsafe.get atomGlobal \"notifications\") \"getNotifications\" emptyArgs)\n  );\n};\n\nlet module Process = {\n  type options = {cwd: string, env: Js.t unit, detached: bool};\n  let defaultOptions = {cwd: \".\", env: Js.Unsafe.obj [||], detached: false};\n};\n\nlet module ChildProcess = {\n  type t;\n  let writeStdin (process: t) str :unit =>\n    Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"write\" [|Js.Unsafe.inject (Js.string str)|];\n  let endStdin (process: t) => Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"end\" emptyArgs;\n};\n\nmodule type BufferedProcessSig = {\n  type t;\n  let create:\n    options::Process.options? =>\n    stdout::(string => unit)? =>\n    stderr::(string => unit)? =>\n    exit::(int => unit)? =>\n    args::list string =>\n    string =>\n    t;\n};\n\nlet module BufferedProcess = {\n  open Process;\n  type t;\n  let create options::opts=? stdout::stdOut=? stderr::stdErr=? exit::exit=? cmd args::args => {\n    let fields = [|\n      (\"command\", Js.Unsafe.inject (Js.string cmd)),\n      (\"args\", Js.Unsafe.inject (Js.array (Array.map Js.string (Array.of_list args))))\n    |];\n    let fields =\n      switch opts {\n      | None => fields\n      | Some opts => {\n          let jsOptions = Js.Unsafe.obj [|\n            (\"cwd\", Js.Unsafe.inject opts.cwd),\n            (\"env\", Js.Unsafe.inject opts.env),\n            (\"detached\", Js.Unsafe.inject (Js.bool opts.detached))\n          |];\n          Array.append fields [|(\"options\", jsOptions)|]\n        }\n      };\n    let fields =\n      switch stdOut {\n      | None => fields\n      | Some so => {\n          let cb jsStr => so (Js.to_string jsStr);\n          Array.append fields [|(\"stdout\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch stdErr {\n      | None => fields\n      | Some si => {\n          let cb jsStr => si (Js.to_string jsStr);\n          Array.append fields [|(\"stdin\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch exit {\n      | None => fields\n      | Some e => {\n          let cb eCode => e (Js.to_float eCode);\n          Array.append fields [|(\"exit\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    Js.Unsafe.new_obj bufferedProcess [|Js.Unsafe.obj fields|]\n  };\n  let onWillThrowError buffProcess fn :unit => {\n    let wrappedCb = Js.wrap_callback (\n      fun jsErrHandle => fn (Js.Unsafe.get jsErrHandle \"error\") (Js.Unsafe.get jsErrHandle \"handle\")\n    );\n    Js.Unsafe.meth_call buffProcess \"onWillThrowError\" [|Js.Unsafe.inject wrappedCb|]\n  };\n  let process (bufferedProcess: t) => Js.Unsafe.get bufferedProcess \"process\";\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.22 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.22 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.22 frontend - output
[ "return", true ]
# 0.22 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.23 frontend - output
[
  "return",
  [
    {
      "start": { "line": 14, "col": 0 },
      "end": { "line": 14, "col": 3 },
      "type": "type",
      "sub": [],
      "valid": true,
      "message": "Invalid module item"
    }
  ]
]
# 0.23 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.23 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.23 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* Only temporarily needed. */\nlet jsTrimTrailing = Js.Unsafe.js_expr \"function(s) {return s.split('\\\\n').map(function(ss) {return ss.trimRight()}).join('\\\\n');}\";\n\nlet atomGlobal = Js.Unsafe.js_expr \"atom\";\n\n\nlet atomRange = Js.Unsafe.js_expr \"require('atom').Range\";\n\nlet bufferedProcess = Js.Unsafe.js_expr \"require('atom').BufferedProcess\";\n\n/* Yes, this doesn't work across iframes. */\nlet _isString = Js.Unsafe.js_expr \"function(s) {return typeof s === 'string' || s instanceof String;}\";\n\nlet _isNumber = Js.Unsafe.js_expr \"function(n) {return typeof n === 'number';}\";\n\nlet _isUndefined = Js.Unsafe.js_expr \"function(n) {return typeof n === 'undefined';}\";\n\nlet _isNull = Js.Unsafe.js_expr \"function(n) {return n === null;}\";\n\nlet _isBool = Js.Unsafe.js_expr \"function(n) {return typeof n === 'boolean';}\";\n\nlet _arrayIsArray = Js.Unsafe.js_expr \"Array.isArray\";\n\nlet promise = Js.Unsafe.js_expr \"Promise\";\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\nlet emptyArgs = [||];\n\nlet trimTrailingWhiteSpace (s: string) => Js.to_string (\n  Js.Unsafe.fun_call jsTrimTrailing [|Js.Unsafe.inject (Js.string s)|]\n);\n\nlet module JsonType = {\n  type t =\n    | JsonString of string | JsonNum of float | JsonBool of bool | JsonArray of (array t) | JsonNull | Empty;\n};\n\ntype completionEntry = {desc: string, info: string, kind: string, name: string};\n\n/**\n * Api over Js values that are known to adhere to \"Json\" style constraints (no\n * functions), untyped, but predictable.\n */\nmodule type JsonValueSig = {\n  /* We never want to reveal that t is actually just an unsafe JS value.\n   * We want everyone to go through the Apis which provide type safety. */\n  type t;\n  let fromJs: Js.t Js.js_string => JsonType.t;\n  let toJs: JsonType.t => Js.Unsafe.any;\n  let unsafeExtractString: JsonType.t => string;\n};\n\nlet module JsonValue: JsonValueSig = {\n  open JsonType;\n  type t = Js.Unsafe.any;\n  let rec fromJs fieldVal =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject fieldVal|]) {\n      let jsArray = Array.map fromJs (Js.to_array (Js.Unsafe.coerce fieldVal));\n      JsonArray jsArray\n    } else if (\n      Js.Unsafe.fun_call _isString [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonString (Js.to_string fieldVal)\n    } else if (\n      Js.Unsafe.fun_call _isBool [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonBool (Js.to_bool (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNumber [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNum (Js.float_of_number (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNull [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNull\n    } else {\n      Empty\n    };\n  let rec toJs =\n    fun | JsonString str => Js.Unsafe.inject (Js.string str)\n        | JsonNum f => Js.Unsafe.inject (Js.float f)\n        | JsonBool b => Js.Unsafe.inject (Js.bool b)\n        | JsonArray a => Js.Unsafe.inject (Js.array (Array.map toJs a))\n        | JsonNull => Js.Unsafe.inject Js.null\n        | Empty => Js.Unsafe.inject Js.undefined;\n  let unsafeExtractString o =>\n    switch o {\n    | JsonType.JsonString s => s\n    | _ => raise (Invalid_argument \"unsafeExtractString: not a string\")\n    };\n};\n\nlet module Env = {\n  let setEnvVar envVar strVal => {\n    Js.Unsafe.set (Js.Unsafe.get (Js.Unsafe.get Js.Unsafe.global \"process\") \"env\") envVar (Js.string strVal);\n    Js.Unsafe.set fixedEnv envVar (Js.string strVal)\n  };\n};\n\nlet module Config = {\n  let get configKey :JsonType.t => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    JsonValue.fromJs (Js.Unsafe.meth_call config \"get\" [|Js.Unsafe.inject (Js.string configKey)|])\n  };\n  let set configKey (v: JsonType.t) :unit => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    let jsVal = JsonValue.toJs v;\n    Js.Unsafe.meth_call config \"set\" [|Js.Unsafe.inject (Js.string configKey), Js.Unsafe.inject jsVal|]\n  };\n};\n\nlet module Point = {\n  type t = (int, int);\n  let toJs (row, column) => Js.Unsafe.inject (Js.array [|Js.Unsafe.inject row, Js.Unsafe.inject column|]);\n  let fromJs jsP =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsP|]) {\n      let arr = Js.to_array jsP;\n      (arr.(0), arr.(1))\n    } else {\n      let row = Js.Unsafe.get jsP \"row\";\n      let col = Js.Unsafe.get jsP \"column\";\n      (row, col)\n    };\n};\n\nlet module Range = {\n  type row = int;\n  type column = int;\n  type rowColumn = (row, column);\n  type t = (rowColumn as 'start, rowColumn as 'endd);\n  let emptyRange = ((0, 0), (0, 0));\n  let toJs (startRowColumn, endRowColumn) =>\n    Js.Unsafe.new_obj atomRange [|Point.toJs startRowColumn, Point.toJs endRowColumn|];\n  let fromJs jsRange =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsRange|]) {\n      let arr = Js.to_array jsRange;\n      let startPoint = Js.to_array arr.(0);\n      let endPoint = Js.to_array arr.(1);\n      ((startPoint.(0), startPoint.(1)), (endPoint.(0), endPoint.(1)))\n    } else {\n      let startPoint = Js.Unsafe.get jsRange \"start\";\n      let endPoint = Js.Unsafe.get jsRange \"end\";\n      (Point.fromJs startPoint, Point.fromJs endPoint)\n    };\n};\n\nlet module Buffer = {\n  type t = Js.Unsafe.any;\n  let fromJs jsBuffer :t => jsBuffer;\n  let toJs (buffer: t) :Js.Unsafe.any => buffer;\n  let characterIndexForPosition (buffer: t) rowColumn =>\n    Js.Unsafe.meth_call buffer \"characterIndexForPosition\" [|Js.Unsafe.inject (Point.toJs rowColumn)|];\n  let getText (buffer: t) :string => Js.to_string (Js.Unsafe.meth_call buffer \"getText\" emptyArgs);\n  let getTextInRange (buffer: t) (range: Range.t) :string => Js.to_string (\n    Js.Unsafe.meth_call buffer \"getTextInRange\" [|Range.toJs range|]\n  );\n};\n\nlet module Cursor = {\n  /* Actually just the underlying JS value - TODO: obscure this using\n   * signature. */\n  type t;\n  let getBufferPosition (cursor: t) => Point.fromJs (\n    Js.Unsafe.meth_call cursor \"getBufferPosition\" emptyArgs\n  );\n  let setBufferPosition position::(pos: Point.t) autoScroll::(autoScroll: bool) (cursor: t) => {\n    let optionsObj = Js.Unsafe.obj [|(\"autoscroll\", Js.Unsafe.inject (Js.bool autoScroll))|];\n    let args = [|Point.toJs pos, optionsObj|];\n    Point.fromJs (Js.Unsafe.meth_call cursor \"setBufferPosition\" args)\n  };\n  let fromJs jsCursor => jsCursor;\n};\n\nlet module Editor = {\n  type t = Js.Unsafe.any;\n  let fromJs jsEditor :t => jsEditor;\n  let toJs (editor: t) :Js.Unsafe.any => editor;\n  let lineTextForBufferRow (editor: t) bufferRow => Js.to_string (\n    Js.Unsafe.meth_call editor \"lineTextForBufferRow\" [|bufferRow|]\n  );\n  let getBuffer editor :Buffer.t => Js.Unsafe.meth_call editor \"getBuffer\" emptyArgs;\n  let getPath editor => {\n    let path = Js.Unsafe.meth_call editor \"getPath\" emptyArgs;\n    Js.Opt.test path ? Some (Js.to_string path) : None\n  };\n  let getCursors editor => {\n    let arr = Array.map Cursor.fromJs (Js.to_array (Js.Unsafe.meth_call editor \"getCursors\" emptyArgs));\n    Array.to_list arr\n  };\n  let setSelectedBufferRanges editor bufferRanges => {\n    let arr = Array.map Range.toJs bufferRanges |> Js.array;\n    Js.Unsafe.meth_call editor \"setSelectedBufferRanges\" [|Js.Unsafe.inject arr|];\n  }\n};\n\n/**\n * Dirt simple promise wrapper, not implementing advanced features yet.\n */\nlet module Promise = {\n  /* This should be made abstract so it's essentially private. */\n  type underlyingJsPromise;\n  type t 'i 'o = {\n    underlyingJsPromise: underlyingJsPromise,\n    /* Try adding constraint where 'o = t 'ii 'oo for some 'ii 'oo */\n    /* Perhaps the higher ranked polymorphism feature would work here */\n    /* One promise's output is another promise's input. */\n    thn: 'nextO .('i => 'o) => t 'o 'nextO\n  };\n  let toJs p => p.underlyingJsPromise;\n  let create executor => {\n    let jsCurriedExecutor = Js.wrap_callback executor;\n    let underlyingJsPromise = Js.Unsafe.new_obj promise [|Js.Unsafe.inject jsCurriedExecutor|];\n    {\n      underlyingJsPromise,\n      thn: fun onResolve =>\n        Js.Unsafe.meth_call underlyingJsPromise \"then\" [|Js.Unsafe.inject (Js.wrap_callback onResolve)|]\n    }\n  };\n  let resolve v => create (fun jsResolveCb jsRejectCb => Js.Unsafe.fun_call jsResolveCb [|v|]);\n  /* For our current purposes, a promise (with no chaining abilities) is enough. */\n  let createFakePromise (executor: ('a => unit) => ('b => unit) => unit) =>\n    Js.Unsafe.new_obj promise [|Js.Unsafe.inject (Js.wrap_callback executor)|];\n};\n\nlet module Notification = {\n  type t;\n  let getType (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getType\" emptyArgs);\n  let getMessage (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getMessage\" emptyArgs);\n  let dismiss (n: t) => Js.Unsafe.meth_call n \"dismiss\" emptyArgs;\n};\n\nlet module NotificationManager = {\n  type options = {detail: string, dismissable: bool, icon: string};\n  let optionsToJs opts => Js.Unsafe.obj [|\n    (\"detail\", Js.Unsafe.inject (Js.string opts.detail)),\n    (\"dismissable\", Js.Unsafe.inject (Js.bool opts.dismissable)),\n    (\"icon\", Js.Unsafe.inject (Js.string opts.icon))\n  |];\n  let defaultOptions = {detail: \"MessageNotProvided\", dismissable: false, icon: \"flame\"};\n  let addError options::opts={...defaultOptions, icon: \"flame\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addError\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addWarning options::opts={...defaultOptions, icon: \"alert\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addWarning\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addInfo options::opts={...defaultOptions, icon: \"info\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addInfo\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addSuccess options::opts={...defaultOptions, icon: \"check\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addSuccess\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let getNotifications () => Array.to_list (\n    Js.to_array (Js.Unsafe.meth_call (Js.Unsafe.get atomGlobal \"notifications\") \"getNotifications\" emptyArgs)\n  );\n};\n\nlet module Process = {\n  type options = {cwd: string, env: Js.t unit, detached: bool};\n  let defaultOptions = {cwd: \".\", env: Js.Unsafe.obj [||], detached: false};\n};\n\nlet module ChildProcess = {\n  type t;\n  let writeStdin (process: t) str :unit =>\n    Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"write\" [|Js.Unsafe.inject (Js.string str)|];\n  let endStdin (process: t) => Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"end\" emptyArgs;\n};\n\nmodule type BufferedProcessSig = {\n  type t;\n  let create:\n    options::Process.options? =>\n    stdout::(string => unit)? =>\n    stderr::(string => unit)? =>\n    exit::(int => unit)? =>\n    args::list string =>\n    string =>\n    t;\n};\n\nlet module BufferedProcess = {\n  open Process;\n  type t;\n  let create options::opts=? stdout::stdOut=? stderr::stdErr=? exit::exit=? cmd args::args => {\n    let fields = [|\n      (\"command\", Js.Unsafe.inject (Js.string cmd)),\n      (\"args\", Js.Unsafe.inject (Js.array (Array.map Js.string (Array.of_list args))))\n    |];\n    let fields =\n      switch opts {\n      | None => fields\n      | Some opts => {\n          let jsOptions = Js.Unsafe.obj [|\n            (\"cwd\", Js.Unsafe.inject opts.cwd),\n            (\"env\", Js.Unsafe.inject opts.env),\n            (\"detached\", Js.Unsafe.inject (Js.bool opts.detached))\n          |];\n          Array.append fields [|(\"options\", jsOptions)|]\n        }\n      };\n    let fields =\n      switch stdOut {\n      | None => fields\n      | Some so => {\n          let cb jsStr => so (Js.to_string jsStr);\n          Array.append fields [|(\"stdout\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch stdErr {\n      | None => fields\n      | Some si => {\n          let cb jsStr => si (Js.to_string jsStr);\n          Array.append fields [|(\"stdin\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch exit {\n      | None => fields\n      | Some e => {\n          let cb eCode => e (Js.to_float eCode);\n          Array.append fields [|(\"exit\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    Js.Unsafe.new_obj bufferedProcess [|Js.Unsafe.obj fields|]\n  };\n  let onWillThrowError buffProcess fn :unit => {\n    let wrappedCb = Js.wrap_callback (\n      fun jsErrHandle => fn (Js.Unsafe.get jsErrHandle \"error\") (Js.Unsafe.get jsErrHandle \"handle\")\n    );\n    Js.Unsafe.meth_call buffProcess \"onWillThrowError\" [|Js.Unsafe.inject wrappedCb|]\n  };\n  let process (bufferedProcess: t) => Js.Unsafe.get bufferedProcess \"process\";\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.23 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.23 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.23 frontend - output
[ "return", true ]
# 0.23 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.24 frontend - output
[ "return", [] ]
# 0.24 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.24 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.24 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* Only temporarily needed. */\nlet jsTrimTrailing = Js.Unsafe.js_expr \"function(s) {return s.split('\\\\n').map(function(ss) {return ss.trimRight()}).join('\\\\n');}\";\n\nlet atomGlobal = Js.Unsafe.js_expr \"atom\";\n\nlet atomRange = Js.Unsafe.js_expr \"require('atom').Range\";\n\nlet bufferedProcess = Js.Unsafe.js_expr \"require('atom').BufferedProcess\";\n\n/* Yes, this doesn't work across iframes. */\nlet _isString = Js.Unsafe.js_expr \"function(s) {return typeof s === 'string' || s instanceof String;}\";\n\nlet _isNumber = Js.Unsafe.js_expr \"function(n) {return typeof n === 'number';}\";\n\nlet _isUndefined = Js.Unsafe.js_expr \"function(n) {return typeof n === 'undefined';}\";\n\nlet _isNull = Js.Unsafe.js_expr \"function(n) {return n === null;}\";\n\nlet _isBool = Js.Unsafe.js_expr \"function(n) {return typeof n === 'boolean';}\";\n\nlet _arrayIsArray = Js.Unsafe.js_expr \"Array.isArray\";\n\nlet promise = Js.Unsafe.js_expr \"Promise\";\n\nlet fixedEnv = Js.Unsafe.js_expr \"require('../lib/fixedEnv')\";\n\nlet emptyArgs = [||];\n\nlet trimTrailingWhiteSpace (s: string) => Js.to_string (\n  Js.Unsafe.fun_call jsTrimTrailing [|Js.Unsafe.inject (Js.string s)|]\n);\n\nlet module JsonType = {\n  type t =\n    | JsonString of string | JsonNum of float | JsonBool of bool | JsonArray of (array t) | JsonNull | Empty;\n};\n\ntype completionEntry = {desc: string, info: string, kind: string, name: string};\n\n/**\n * Api over Js values that are known to adhere to \"Json\" style constraints (no\n * functions), untyped, but predictable.\n */\nmodule type JsonValueSig = {\n  /* We never want to reveal that t is actually just an unsafe JS value.\n   * We want everyone to go through the Apis which provide type safety. */\n  type t;\n  let fromJs: Js.t Js.js_string => JsonType.t;\n  let toJs: JsonType.t => Js.Unsafe.any;\n  let unsafeExtractString: JsonType.t => string;\n};\n\nlet module JsonValue: JsonValueSig = {\n  open JsonType;\n  type t = Js.Unsafe.any;\n  let rec fromJs fieldVal =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject fieldVal|]) {\n      let jsArray = Array.map fromJs (Js.to_array (Js.Unsafe.coerce fieldVal));\n      JsonArray jsArray\n    } else if (\n      Js.Unsafe.fun_call _isString [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonString (Js.to_string fieldVal)\n    } else if (\n      Js.Unsafe.fun_call _isBool [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonBool (Js.to_bool (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNumber [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNum (Js.float_of_number (Js.Unsafe.coerce fieldVal))\n    } else if (\n      Js.Unsafe.fun_call _isNull [|Js.Unsafe.inject fieldVal|]\n    ) {\n      JsonNull\n    } else {\n      Empty\n    };\n  let rec toJs =\n    fun | JsonString str => Js.Unsafe.inject (Js.string str)\n        | JsonNum f => Js.Unsafe.inject (Js.float f)\n        | JsonBool b => Js.Unsafe.inject (Js.bool b)\n        | JsonArray a => Js.Unsafe.inject (Js.array (Array.map toJs a))\n        | JsonNull => Js.Unsafe.inject Js.null\n        | Empty => Js.Unsafe.inject Js.undefined;\n  let unsafeExtractString o =>\n    switch o {\n    | JsonType.JsonString s => s\n    | _ => raise (Invalid_argument \"unsafeExtractString: not a string\")\n    };\n};\n\nlet module Env = {\n  let setEnvVar envVar strVal => {\n    Js.Unsafe.set (Js.Unsafe.get (Js.Unsafe.get Js.Unsafe.global \"process\") \"env\") envVar (Js.string strVal);\n    Js.Unsafe.set fixedEnv envVar (Js.string strVal)\n  };\n};\n\nlet module Config = {\n  let get configKey :JsonType.t => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    JsonValue.fromJs (Js.Unsafe.meth_call config \"get\" [|Js.Unsafe.inject (Js.string configKey)|])\n  };\n  let set configKey (v: JsonType.t) :unit => {\n    let config = Js.Unsafe.get atomGlobal \"config\";\n    let jsVal = JsonValue.toJs v;\n    Js.Unsafe.meth_call config \"set\" [|Js.Unsafe.inject (Js.string configKey), Js.Unsafe.inject jsVal|]\n  };\n};\n\nlet module Point = {\n  type t = (int, int);\n  let toJs (row, column) => Js.Unsafe.inject (Js.array [|Js.Unsafe.inject row, Js.Unsafe.inject column|]);\n  let fromJs jsP =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsP|]) {\n      let arr = Js.to_array jsP;\n      (arr.(0), arr.(1))\n    } else {\n      let row = Js.Unsafe.get jsP \"row\";\n      let col = Js.Unsafe.get jsP \"column\";\n      (row, col)\n    };\n};\n\nlet module Range = {\n  type row = int;\n  type column = int;\n  type rowColumn = (row, column);\n  type t = (rowColumn as 'start, rowColumn as 'endd);\n  let emptyRange = ((0, 0), (0, 0));\n  let toJs (startRowColumn, endRowColumn) =>\n    Js.Unsafe.new_obj atomRange [|Point.toJs startRowColumn, Point.toJs endRowColumn|];\n  let fromJs jsRange =>\n    if (Js.Unsafe.fun_call _arrayIsArray [|Js.Unsafe.inject jsRange|]) {\n      let arr = Js.to_array jsRange;\n      let startPoint = Js.to_array arr.(0);\n      let endPoint = Js.to_array arr.(1);\n      ((startPoint.(0), startPoint.(1)), (endPoint.(0), endPoint.(1)))\n    } else {\n      let startPoint = Js.Unsafe.get jsRange \"start\";\n      let endPoint = Js.Unsafe.get jsRange \"end\";\n      (Point.fromJs startPoint, Point.fromJs endPoint)\n    };\n};\n\nlet module Buffer = {\n  type t = Js.Unsafe.any;\n  let fromJs jsBuffer :t => jsBuffer;\n  let toJs (buffer: t) :Js.Unsafe.any => buffer;\n  let characterIndexForPosition (buffer: t) rowColumn =>\n    Js.Unsafe.meth_call buffer \"characterIndexForPosition\" [|Js.Unsafe.inject (Point.toJs rowColumn)|];\n  let getText (buffer: t) :string => Js.to_string (Js.Unsafe.meth_call buffer \"getText\" emptyArgs);\n  let getTextInRange (buffer: t) (range: Range.t) :string => Js.to_string (\n    Js.Unsafe.meth_call buffer \"getTextInRange\" [|Range.toJs range|]\n  );\n};\n\nlet module Cursor = {\n  /* Actually just the underlying JS value - TODO: obscure this using\n   * signature. */\n  type t;\n  let getBufferPosition (cursor: t) => Point.fromJs (\n    Js.Unsafe.meth_call cursor \"getBufferPosition\" emptyArgs\n  );\n  let setBufferPosition position::(pos: Point.t) autoScroll::(autoScroll: bool) (cursor: t) => {\n    let optionsObj = Js.Unsafe.obj [|(\"autoscroll\", Js.Unsafe.inject (Js.bool autoScroll))|];\n    let args = [|Point.toJs pos, optionsObj|];\n    Point.fromJs (Js.Unsafe.meth_call cursor \"setBufferPosition\" args)\n  };\n  let fromJs jsCursor => jsCursor;\n};\n\nlet module Editor = {\n  type t = Js.Unsafe.any;\n  let fromJs jsEditor :t => jsEditor;\n  let toJs (editor: t) :Js.Unsafe.any => editor;\n  let lineTextForBufferRow (editor: t) bufferRow => Js.to_string (\n    Js.Unsafe.meth_call editor \"lineTextForBufferRow\" [|bufferRow|]\n  );\n  let getBuffer editor :Buffer.t => Js.Unsafe.meth_call editor \"getBuffer\" emptyArgs;\n  let getPath editor => {\n    let path = Js.Unsafe.meth_call editor \"getPath\" emptyArgs;\n    Js.Opt.test path ? Some (Js.to_string path) : None\n  };\n  let getCursors editor => {\n    let arr = Array.map Cursor.fromJs (Js.to_array (Js.Unsafe.meth_call editor \"getCursors\" emptyArgs));\n    Array.to_list arr\n  };\n  let setSelectedBufferRanges editor bufferRanges => {\n    let arr = Array.map Range.toJs bufferRanges |> Js.array;\n    Js.Unsafe.meth_call editor \"setSelectedBufferRanges\" [|Js.Unsafe.inject arr|];\n  }\n};\n\n/**\n * Dirt simple promise wrapper, not implementing advanced features yet.\n */\nlet module Promise = {\n  /* This should be made abstract so it's essentially private. */\n  type underlyingJsPromise;\n  type t 'i 'o = {\n    underlyingJsPromise: underlyingJsPromise,\n    /* Try adding constraint where 'o = t 'ii 'oo for some 'ii 'oo */\n    /* Perhaps the higher ranked polymorphism feature would work here */\n    /* One promise's output is another promise's input. */\n    thn: 'nextO .('i => 'o) => t 'o 'nextO\n  };\n  let toJs p => p.underlyingJsPromise;\n  let create executor => {\n    let jsCurriedExecutor = Js.wrap_callback executor;\n    let underlyingJsPromise = Js.Unsafe.new_obj promise [|Js.Unsafe.inject jsCurriedExecutor|];\n    {\n      underlyingJsPromise,\n      thn: fun onResolve =>\n        Js.Unsafe.meth_call underlyingJsPromise \"then\" [|Js.Unsafe.inject (Js.wrap_callback onResolve)|]\n    }\n  };\n  let resolve v => create (fun jsResolveCb jsRejectCb => Js.Unsafe.fun_call jsResolveCb [|v|]);\n  /* For our current purposes, a promise (with no chaining abilities) is enough. */\n  let createFakePromise (executor: ('a => unit) => ('b => unit) => unit) =>\n    Js.Unsafe.new_obj promise [|Js.Unsafe.inject (Js.wrap_callback executor)|];\n};\n\nlet module Notification = {\n  type t;\n  let getType (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getType\" emptyArgs);\n  let getMessage (n: t) => Js.to_string (Js.Unsafe.meth_call n \"getMessage\" emptyArgs);\n  let dismiss (n: t) => Js.Unsafe.meth_call n \"dismiss\" emptyArgs;\n};\n\nlet module NotificationManager = {\n  type options = {detail: string, dismissable: bool, icon: string};\n  let optionsToJs opts => Js.Unsafe.obj [|\n    (\"detail\", Js.Unsafe.inject (Js.string opts.detail)),\n    (\"dismissable\", Js.Unsafe.inject (Js.bool opts.dismissable)),\n    (\"icon\", Js.Unsafe.inject (Js.string opts.icon))\n  |];\n  let defaultOptions = {detail: \"MessageNotProvided\", dismissable: false, icon: \"flame\"};\n  let addError options::opts={...defaultOptions, icon: \"flame\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addError\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addWarning options::opts={...defaultOptions, icon: \"alert\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addWarning\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addInfo options::opts={...defaultOptions, icon: \"info\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addInfo\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let addSuccess options::opts={...defaultOptions, icon: \"check\"} title :unit =>\n    Js.Unsafe.meth_call\n      (Js.Unsafe.get atomGlobal \"notifications\")\n      \"addSuccess\"\n      [|Js.Unsafe.inject (Js.string title), optionsToJs opts|];\n  let getNotifications () => Array.to_list (\n    Js.to_array (Js.Unsafe.meth_call (Js.Unsafe.get atomGlobal \"notifications\") \"getNotifications\" emptyArgs)\n  );\n};\n\nlet module Process = {\n  type options = {cwd: string, env: Js.t unit, detached: bool};\n  let defaultOptions = {cwd: \".\", env: Js.Unsafe.obj [||], detached: false};\n};\n\nlet module ChildProcess = {\n  type t;\n  let writeStdin (process: t) str :unit =>\n    Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"write\" [|Js.Unsafe.inject (Js.string str)|];\n  let endStdin (process: t) => Js.Unsafe.meth_call (Js.Unsafe.get process \"stdin\") \"end\" emptyArgs;\n};\n\nmodule type BufferedProcessSig = {\n  type t;\n  let create:\n    options::Process.options? =>\n    stdout::(string => unit)? =>\n    stderr::(string => unit)? =>\n    exit::(int => unit)? =>\n    args::list string =>\n    string =>\n    t;\n};\n\nlet module BufferedProcess = {\n  open Process;\n  type t;\n  let create options::opts=? stdout::stdOut=? stderr::stdErr=? exit::exit=? cmd args::args => {\n    let fields = [|\n      (\"command\", Js.Unsafe.inject (Js.string cmd)),\n      (\"args\", Js.Unsafe.inject (Js.array (Array.map Js.string (Array.of_list args))))\n    |];\n    let fields =\n      switch opts {\n      | None => fields\n      | Some opts => {\n          let jsOptions = Js.Unsafe.obj [|\n            (\"cwd\", Js.Unsafe.inject opts.cwd),\n            (\"env\", Js.Unsafe.inject opts.env),\n            (\"detached\", Js.Unsafe.inject (Js.bool opts.detached))\n          |];\n          Array.append fields [|(\"options\", jsOptions)|]\n        }\n      };\n    let fields =\n      switch stdOut {\n      | None => fields\n      | Some so => {\n          let cb jsStr => so (Js.to_string jsStr);\n          Array.append fields [|(\"stdout\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch stdErr {\n      | None => fields\n      | Some si => {\n          let cb jsStr => si (Js.to_string jsStr);\n          Array.append fields [|(\"stdin\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    let fields =\n      switch exit {\n      | None => fields\n      | Some e => {\n          let cb eCode => e (Js.to_float eCode);\n          Array.append fields [|(\"exit\", Js.Unsafe.inject (Js.wrap_callback cb))|]\n        }\n      };\n    Js.Unsafe.new_obj bufferedProcess [|Js.Unsafe.obj fields|]\n  };\n  let onWillThrowError buffProcess fn :unit => {\n    let wrappedCb = Js.wrap_callback (\n      fun jsErrHandle => fn (Js.Unsafe.get jsErrHandle \"error\") (Js.Unsafe.get jsErrHandle \"handle\")\n    );\n    Js.Unsafe.meth_call buffProcess \"onWillThrowError\" [|Js.Unsafe.inject wrappedCb|]\n  };\n  let process (bufferedProcess: t) => Js.Unsafe.get bufferedProcess \"process\";\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.24 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.24 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.24 frontend - output
[ "return", true ]
# 0.24 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re"
  ]
}
# 0.24 frontend - output
[ "return", [] ]
# 0.25 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.25 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.25 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.25 frontend - output
[ "return", true ]
# 0.25 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 195, "col": 20 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 track_definition - from_string
looking for the source of 'SuperMerlin.getOccurrences' (prioritizing .ml files)
# 0.25 track_definition - lookup
lookup in value namespace
# 0.25 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.SuperMerlin.getOccurrences[val]'
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
open_description
# 0.25 track_definition - locate
resolves to AtomReason.SuperMerlin.getOccurrences[val]
# 0.25 track_definition - Fallback.setopt
None
# 0.25 track_definition - from_path '%s'
AtomReason.SuperMerlin.getOccurrences[val]
# 0.25 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.25 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.25 track_definition - locate
resolves to M_AtomReason__SuperMerlin.getOccurrences[val]
# 0.25 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 62, characters 0-46
# 0.25 track_definition - from_path '%s'
M_AtomReason__SuperMerlin.getOccurrences[val]
# 0.25 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.25 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.25 track_definition - find_source
failed to find "." in source path (fallback = false)
# 0.25 track_definition - find_source
(for reference: fname = "")
# 0.25 track_definition - find_source
looking in '/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules'
# 0.25 frontend - output
[
  "return",
  "'SuperMerlin.getOccurrences' seems to originate from '.' whose ML file could not be found"
]
# 0.25 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.25 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.25 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.25 frontend - output
[ "return", true ]
# 0.25 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 195, "col": 23 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 frontend - output
[
  "return",
  [
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 195, "col": 34 },
      "type":
        "path::string =>\ntext::string => position::(int, int) => ('a => 'b) => ('c => 'd) => 'e",
      "tail": "no"
    },
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 195, "col": 34 },
      "type":
        "path::string =>\ntext::string =>\nposition::(int, int) =>\n(Js.t (Js.js_array '_a) => unit) => ('_b => unit) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 195, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 194, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 193, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 191, "col": 22 },
      "end": { "line": 206, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 190, "col": 21 },
      "end": { "line": 207, "col": 5 },
      "type": "AtomReason.Atom.Editor.t => '_a",
      "tail": "no"
    },
    {
      "start": { "line": 189, "col": 2 },
      "end": { "line": 208, "col": 3 },
      "type": "Js.meth_callback '_a AtomReason.Atom.Editor.t => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 187, "col": 0 },
      "end": { "line": 208, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.25 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.25 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.25 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.25 frontend - output
[ "return", true ]
# 0.25 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 179, "col": 29 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 track_definition - from_string
looking for the source of 'AtomReasonLocate.getMerlinLocation' (prioritizing .ml files)
# 0.25 track_definition - lookup
lookup in value namespace
# 0.25 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.AtomReasonLocate.getMerlinLocation[val]'
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
expression
# 0.25 typedtrie - ignored node
open_description
# 0.25 track_definition - locate
resolves to AtomReason.AtomReasonLocate.getMerlinLocation[val]
# 0.25 track_definition - Fallback.setopt
None
# 0.25 track_definition - from_path '%s'
AtomReason.AtomReasonLocate.getMerlinLocation[val]
# 0.25 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.25 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.25 track_definition - locate
resolves to M_AtomReason__AtomReasonLocate.getMerlinLocation[val]
# 0.25 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 80, characters 0-56
# 0.25 track_definition - from_path '%s'
M_AtomReason__AtomReasonLocate.getMerlinLocation[val]
# 0.25 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__AtomReasonLocate.cmt
# 0.25 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__AtomReasonLocate.cmt
# 0.25 track_definition - find_source
failed to find "." in source path (fallback = false)
# 0.25 track_definition - find_source
(for reference: fname = "")
# 0.25 track_definition - find_source
looking in '/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules'
# 0.25 frontend - output
[
  "return",
  "'AtomReasonLocate.getMerlinLocation' seems to originate from '.' whose ML file could not be found"
]
# 0.25 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.25 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.25 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.25 frontend - output
[ "return", true ]
# 0.25 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 179, "col": 33 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.25 frontend - output
[
  "return",
  [
    {
      "start": { "line": 179, "col": 12 },
      "end": { "line": 179, "col": 46 },
      "type":
        "editor::AtomReason.Atom.Buffer.t => range::(((int, int)), 'a) => 'b",
      "tail": "no"
    },
    {
      "start": { "line": 179, "col": 12 },
      "end": { "line": 179, "col": 46 },
      "type":
        "editor::AtomReason.Atom.Buffer.t => range::(((int, int)), ((int, int))) => 'a",
      "tail": "no"
    },
    {
      "start": { "line": 179, "col": 12 },
      "end": { "line": 180, "col": 84 },
      "type": "'a",
      "tail": "call"
    },
    {
      "start": { "line": 177, "col": 40 },
      "end": { "line": 181, "col": 9 },
      "type": "unit => 'a",
      "tail": "no"
    },
    {
      "start": { "line": 177, "col": 23 },
      "end": { "line": 181, "col": 9 },
      "type": "Js.meth_callback '_a unit => 'b",
      "tail": "no"
    },
    {
      "start": { "line": 176, "col": 30 },
      "end": { "line": 183, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 176, "col": 21 },
      "end": { "line": 183, "col": 7 },
      "type": "Js.t (Js.js_array (Js.t (Js.js_array int))) => '_a",
      "tail": "position"
    },
    {
      "start": { "line": 176, "col": 19 },
      "end": { "line": 183, "col": 7 },
      "type": "'_a => Js.t (Js.js_array (Js.t (Js.js_array int))) => '_b",
      "tail": "position"
    },
    {
      "start": { "line": 175, "col": 21 },
      "end": { "line": 184, "col": 5 },
      "type":
        "AtomReason.Atom.Editor.t =>\n'_a => Js.t (Js.js_array (Js.t (Js.js_array int))) => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 174, "col": 2 },
      "end": { "line": 185, "col": 3 },
      "type":
        "Js.meth_callback\n'_a\n AtomReason.Atom.Editor.t =>\n '_b => Js.t (Js.js_array (Js.t (Js.js_array int))) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 172, "col": 0 },
      "end": { "line": 185, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.26 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.26 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.26 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.26 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.26 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.26 frontend - output
[ "return", true ]
# 0.26 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 165, "col": 38 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.26 frontend - output
[
  "return",
  [
    {
      "start": { "line": 165, "col": 38 },
      "end": { "line": 165, "col": 58 },
      "type": "(module M_AtomReason__MerlinServiceConvert)",
      "tail": "no"
    },
    {
      "start": { "line": 165, "col": 38 },
      "end": { "line": 165, "col": 89 },
      "type": "'_a => Js.optdef '_b",
      "tail": "no"
    },
    {
      "start": { "line": 165, "col": 37 },
      "end": { "line": 165, "col": 97 },
      "type": "Js.optdef '_a",
      "tail": "no"
    },
    {
      "start": { "line": 165, "col": 29 },
      "end": { "line": 165, "col": 97 },
      "type": "unit",
      "tail": "call"
    },
    {
      "start": { "line": 165, "col": 14 },
      "end": { "line": 165, "col": 98 },
      "type": "'_a => unit",
      "tail": "no"
    },
    {
      "start": { "line": 161, "col": 12 },
      "end": { "line": 166, "col": 65 },
      "type": "unit",
      "tail": "call"
    },
    {
      "start": { "line": 160, "col": 22 },
      "end": { "line": 166, "col": 65 },
      "type": "(Js.t Js.js_string => unit) => unit",
      "tail": "position"
    },
    {
      "start": { "line": 159, "col": 39 },
      "end": { "line": 167, "col": 9 },
      "type":
        "(Js.optdef '_a => unit) => (Js.t Js.js_string => unit) => unit",
      "tail": "no"
    },
    {
      "start": { "line": 159, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 158, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 31 },
      "end": { "line": 168, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 19 },
      "end": { "line": 168, "col": 7 },
      "type": "Js.t (Js.js_array int) => '_a",
      "tail": "position"
    },
    {
      "start": { "line": 152, "col": 21 },
      "end": { "line": 169, "col": 5 },
      "type": "'_a => Js.t (Js.js_array int) => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 151, "col": 2 },
      "end": { "line": 170, "col": 3 },
      "type": "Js.meth_callback '_a '_b => Js.t (Js.js_array int) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 149, "col": 0 },
      "end": { "line": 170, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.26 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.26 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.26 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.26 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.26 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.26 frontend - output
[ "return", true ]
# 0.26 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 159, "col": 13 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.26 track_definition - from_string
looking for the source of 'Atom.Promise' (prioritizing .ml files)
# 0.26 track_definition - lookup
lookup in value namespace
# 0.26 track_definition - lookup
lookup in constructor namespace
# 0.26 track_definition - lookup
lookup in module namespace
# 0.26 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.Atom.Promise'
# 0.26 typedtrie - ignored node
expression
# 0.26 typedtrie - ignored node
expression
# 0.26 typedtrie - ignored node
expression
# 0.26 typedtrie - ignored node
expression
# 0.26 typedtrie - ignored node
expression
# 0.26 typedtrie - ignored node
expression
# 0.26 typedtrie - ignored node
expression
# 0.26 typedtrie - ignored node
open_description
# 0.26 track_definition - locate
resolves to AtomReason.Atom.Promise
# 0.26 track_definition - Fallback.setopt
None
# 0.26 track_definition - from_path '%s'
AtomReason.Atom.Promise
# 0.26 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.26 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.26 track_definition - locate
resolves to M_AtomReason__Atom.Promise
# 0.26 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 8, characters 0-32
# 0.26 track_definition - from_path '%s'
M_AtomReason__Atom.Promise
# 0.26 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__Atom.cmt
# 0.26 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__Atom.cmt
# 0.26 typedtrie - ignored node
open_description
# 0.26 typedtrie - ignored node
open_description
# 0.26 track_definition - find_source
multiple files named Atom exist in the source path...
# 0.26 track_definition - find_source
... trying to use source digest to find the right one
# 0.26 track_definition - find_source
Source digest: 86f91dae6212d7654a314004f53a2549
# 0.26 track_definition - find_source
  /Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re (86f91dae6212d7654a314004f53a2549)
# 0.26 track_definition - Locate
/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re
# 0.26 frontend - output
[
  "return",
  {
    "file":
      "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re",
    "pos": { "line": 206, "col": 0 }
  }
]
# 0.27 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.27 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.27 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.27 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.27 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.27 frontend - output
[ "return", true ]
# 0.27 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 161, "col": 24 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.27 track_definition - from_string
looking for the source of 'SuperMerlin.getTypeHint' (prioritizing .ml files)
# 0.27 track_definition - lookup
lookup in value namespace
# 0.27 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.SuperMerlin.getTypeHint[val]'
# 0.27 typedtrie - ignored node
expression
# 0.27 typedtrie - ignored node
expression
# 0.27 typedtrie - ignored node
expression
# 0.27 typedtrie - ignored node
expression
# 0.27 typedtrie - ignored node
expression
# 0.27 typedtrie - ignored node
expression
# 0.27 typedtrie - ignored node
expression
# 0.27 typedtrie - ignored node
open_description
# 0.27 track_definition - locate
resolves to AtomReason.SuperMerlin.getTypeHint[val]
# 0.27 track_definition - Fallback.setopt
None
# 0.27 track_definition - from_path '%s'
AtomReason.SuperMerlin.getTypeHint[val]
# 0.27 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.27 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.27 track_definition - locate
resolves to M_AtomReason__SuperMerlin.getTypeHint[val]
# 0.27 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 62, characters 0-46
# 0.27 track_definition - from_path '%s'
M_AtomReason__SuperMerlin.getTypeHint[val]
# 0.27 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.27 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.27 track_definition - find_source
failed to find "." in source path (fallback = false)
# 0.27 track_definition - find_source
(for reference: fname = "")
# 0.27 track_definition - find_source
looking in '/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules'
# 0.27 frontend - output
[
  "return",
  "'SuperMerlin.getTypeHint' seems to originate from '.' whose ML file could not be found"
]
# 0.27 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.27 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.27 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.27 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.27 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.27 frontend - output
[ "return", true ]
# 0.27 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 161, "col": 26 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.27 frontend - output
[
  "return",
  [
    {
      "start": { "line": 161, "col": 12 },
      "end": { "line": 161, "col": 35 },
      "type":
        "path::string =>\ntext::string => position::(int, int) => ('a => 'b) => ('c => 'd) => 'e",
      "tail": "no"
    },
    {
      "start": { "line": 161, "col": 12 },
      "end": { "line": 161, "col": 35 },
      "type":
        "path::string =>\ntext::string =>\nposition::(int, int) => ('_a => unit) => (string => unit) => unit",
      "tail": "no"
    },
    {
      "start": { "line": 161, "col": 12 },
      "end": { "line": 166, "col": 65 },
      "type": "unit",
      "tail": "call"
    },
    {
      "start": { "line": 160, "col": 22 },
      "end": { "line": 166, "col": 65 },
      "type": "(Js.t Js.js_string => unit) => unit",
      "tail": "position"
    },
    {
      "start": { "line": 159, "col": 39 },
      "end": { "line": 167, "col": 9 },
      "type":
        "(Js.optdef '_a => unit) => (Js.t Js.js_string => unit) => unit",
      "tail": "no"
    },
    {
      "start": { "line": 159, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 158, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 31 },
      "end": { "line": 168, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 19 },
      "end": { "line": 168, "col": 7 },
      "type": "Js.t (Js.js_array int) => '_a",
      "tail": "position"
    },
    {
      "start": { "line": 152, "col": 21 },
      "end": { "line": 169, "col": 5 },
      "type": "'_a => Js.t (Js.js_array int) => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 151, "col": 2 },
      "end": { "line": 170, "col": 3 },
      "type": "Js.meth_callback '_a '_b => Js.t (Js.js_array int) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 149, "col": 0 },
      "end": { "line": 170, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.27 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.27 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.27 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.27 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.27 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.27 frontend - output
[ "return", true ]
# 0.27 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 160, "col": 24 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.27 frontend - output
[
  "return",
  [
    {
      "start": { "line": 160, "col": 22 },
      "end": { "line": 160, "col": 28 },
      "type": "Js.t Js.js_string => unit",
      "tail": "no"
    },
    {
      "start": { "line": 160, "col": 22 },
      "end": { "line": 166, "col": 65 },
      "type": "(Js.t Js.js_string => unit) => unit",
      "tail": "position"
    },
    {
      "start": { "line": 159, "col": 39 },
      "end": { "line": 167, "col": 9 },
      "type":
        "(Js.optdef '_a => unit) => (Js.t Js.js_string => unit) => unit",
      "tail": "no"
    },
    {
      "start": { "line": 159, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 158, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 31 },
      "end": { "line": 168, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 19 },
      "end": { "line": 168, "col": 7 },
      "type": "Js.t (Js.js_array int) => '_a",
      "tail": "position"
    },
    {
      "start": { "line": 152, "col": 21 },
      "end": { "line": 169, "col": 5 },
      "type": "'_a => Js.t (Js.js_array int) => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 151, "col": 2 },
      "end": { "line": 170, "col": 3 },
      "type": "Js.meth_callback '_a '_b => Js.t (Js.js_array int) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 149, "col": 0 },
      "end": { "line": 170, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.28 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.28 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.28 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.28 frontend - output
[ "return", true ]
# 0.28 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 159, "col": 26 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 frontend - output
[
  "return",
  [
    {
      "start": { "line": 159, "col": 8 },
      "end": { "line": 159, "col": 38 },
      "type": "(('a => unit) => ('b => unit) => unit) => 'c",
      "tail": "no"
    },
    {
      "start": { "line": 159, "col": 8 },
      "end": { "line": 159, "col": 38 },
      "type":
        "((Js.optdef '_a => unit) => (Js.t Js.js_string => unit) => unit) => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 159, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 158, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 31 },
      "end": { "line": 168, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 19 },
      "end": { "line": 168, "col": 7 },
      "type": "Js.t (Js.js_array int) => '_a",
      "tail": "position"
    },
    {
      "start": { "line": 152, "col": 21 },
      "end": { "line": 169, "col": 5 },
      "type": "'_a => Js.t (Js.js_array int) => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 151, "col": 2 },
      "end": { "line": 170, "col": 3 },
      "type": "Js.meth_callback '_a '_b => Js.t (Js.js_array int) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 149, "col": 0 },
      "end": { "line": 170, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.28 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.28 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.28 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.28 frontend - output
[ "return", true ]
# 0.28 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 158, "col": 22 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 frontend - output
[
  "return",
  [
    {
      "start": { "line": 158, "col": 19 },
      "end": { "line": 158, "col": 23 },
      "type": "(module M_AtomReason__Atom)",
      "tail": "no"
    },
    {
      "start": { "line": 158, "col": 19 },
      "end": { "line": 158, "col": 38 },
      "type": "AtomReason.Atom.Buffer.t => string",
      "tail": "no"
    },
    {
      "start": { "line": 158, "col": 19 },
      "end": { "line": 158, "col": 71 },
      "type": "string",
      "tail": "no"
    },
    {
      "start": { "line": 158, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 31 },
      "end": { "line": 168, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 19 },
      "end": { "line": 168, "col": 7 },
      "type": "Js.t (Js.js_array int) => '_a",
      "tail": "position"
    },
    {
      "start": { "line": 152, "col": 21 },
      "end": { "line": 169, "col": 5 },
      "type": "'_a => Js.t (Js.js_array int) => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 151, "col": 2 },
      "end": { "line": 170, "col": 3 },
      "type": "Js.meth_callback '_a '_b => Js.t (Js.js_array int) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 149, "col": 0 },
      "end": { "line": 170, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.28 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.28 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.28 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.28 frontend - output
[ "return", true ]
# 0.28 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 158, "col": 27 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 frontend - output
[
  "return",
  [
    {
      "start": { "line": 158, "col": 19 },
      "end": { "line": 158, "col": 30 },
      "type":
        "{\n  type t = Js.Unsafe.any;\n  let fromJs : t => t;\n  let toJs : t => Js.Unsafe.any;\n  let characterIndexForPosition : t => ('a, 'b) => 'c;\n  let getText : t => string;\n  let getTextInRange : t => AtomReason.Atom.Range.t => string;\n}",
      "tail": "no"
    },
    {
      "start": { "line": 158, "col": 19 },
      "end": { "line": 158, "col": 38 },
      "type": "AtomReason.Atom.Buffer.t => string",
      "tail": "no"
    },
    {
      "start": { "line": 158, "col": 19 },
      "end": { "line": 158, "col": 71 },
      "type": "string",
      "tail": "no"
    },
    {
      "start": { "line": 158, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 31 },
      "end": { "line": 168, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 19 },
      "end": { "line": 168, "col": 7 },
      "type": "Js.t (Js.js_array int) => '_a",
      "tail": "position"
    },
    {
      "start": { "line": 152, "col": 21 },
      "end": { "line": 169, "col": 5 },
      "type": "'_a => Js.t (Js.js_array int) => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 151, "col": 2 },
      "end": { "line": 170, "col": 3 },
      "type": "Js.meth_callback '_a '_b => Js.t (Js.js_array int) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 149, "col": 0 },
      "end": { "line": 170, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.28 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.28 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.28 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.28 frontend - output
[ "return", true ]
# 0.28 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 158, "col": 24 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 track_definition - from_string
looking for the source of 'Atom.Buffer' (prioritizing .ml files)
# 0.28 track_definition - lookup
lookup in value namespace
# 0.28 track_definition - lookup
lookup in constructor namespace
# 0.28 track_definition - lookup
lookup in module namespace
# 0.28 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.Atom.Buffer'
# 0.28 typedtrie - ignored node
expression
# 0.28 typedtrie - ignored node
expression
# 0.28 typedtrie - ignored node
expression
# 0.28 typedtrie - ignored node
expression
# 0.28 typedtrie - ignored node
expression
# 0.28 typedtrie - ignored node
expression
# 0.28 typedtrie - ignored node
expression
# 0.28 typedtrie - ignored node
open_description
# 0.28 track_definition - locate
resolves to AtomReason.Atom.Buffer
# 0.28 track_definition - Fallback.setopt
None
# 0.28 track_definition - from_path '%s'
AtomReason.Atom.Buffer
# 0.28 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.28 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.28 track_definition - locate
resolves to M_AtomReason__Atom.Buffer
# 0.28 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 8, characters 0-32
# 0.28 track_definition - from_path '%s'
M_AtomReason__Atom.Buffer
# 0.28 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__Atom.cmt
# 0.28 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__Atom.cmt
# 0.28 typedtrie - ignored node
open_description
# 0.28 typedtrie - ignored node
open_description
# 0.28 track_definition - find_source
multiple files named Atom exist in the source path...
# 0.28 track_definition - find_source
... trying to use source digest to find the right one
# 0.28 track_definition - find_source
Source digest: 86f91dae6212d7654a314004f53a2549
# 0.28 track_definition - find_source
  /Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re (86f91dae6212d7654a314004f53a2549)
# 0.28 track_definition - Locate
/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re
# 0.28 frontend - output
[
  "return",
  {
    "file":
      "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Atom.re",
    "pos": { "line": 154, "col": 0 }
  }
]
# 0.28 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.28 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.28 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.28 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.28 frontend - output
[ "return", true ]
# 0.28 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 158, "col": 27 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.29 frontend - output
[
  "return",
  [
    {
      "start": { "line": 158, "col": 19 },
      "end": { "line": 158, "col": 30 },
      "type":
        "{\n  type t = Js.Unsafe.any;\n  let fromJs : t => t;\n  let toJs : t => Js.Unsafe.any;\n  let characterIndexForPosition : t => ('a, 'b) => 'c;\n  let getText : t => string;\n  let getTextInRange : t => AtomReason.Atom.Range.t => string;\n}",
      "tail": "no"
    },
    {
      "start": { "line": 158, "col": 19 },
      "end": { "line": 158, "col": 38 },
      "type": "Js.Unsafe.any => string",
      "tail": "no"
    },
    {
      "start": { "line": 158, "col": 19 },
      "end": { "line": 158, "col": 71 },
      "type": "string",
      "tail": "no"
    },
    {
      "start": { "line": 158, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 31 },
      "end": { "line": 168, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 19 },
      "end": { "line": 168, "col": 7 },
      "type":
        "Js.t\n< concat : Js.t 'a => Js.meth (Js.t 'a),\n  every : Js.meth_callback unit int => int => Js.t 'a => Js.t bool =>\n          Js.meth (Js.t bool),\n  filter : Js.meth_callback unit int => int => Js.t 'a => Js.t bool =>\n           Js.meth (Js.t 'a),\n  forEach : Js.meth_callback unit int => int => Js.t 'a => unit =>\n            Js.meth unit,\n  join : Js.t\n         < _match : Js.t Js.regExp =>\n                    Js.meth (Js.opt (Js.t Js.match_result_handle)),\n           charAt : int => Js.meth (Js.t 'c) as 'd,\n           charCodeAt : int => Js.meth float,\n           concat : Js.t 'c => Js.meth (Js.t 'c) as 'e,\n           concat_2 : Js.t 'c => Js.t 'c => Js.meth (Js.t 'c) as 'f,\n           concat_3 : Js.t 'c => Js.t 'c => Js.t 'c => Js.meth (Js.t 'c)\n                      as 'g,\n           concat_4 : Js.t 'c =>\n                      Js.t 'c => Js.t 'c => Js.t 'c => Js.meth (Js.t 'c)\n                      as 'h,\n           indexOf : Js.t 'c => Js.meth int as 'i,\n           indexOf_from : Js.t 'c => int => Js.meth int as 'j,\n           lastIndexOf : Js.t 'c => Js.meth int as 'k,\n           lastIndexOf_from : Js.t 'c => int => Js.meth int as 'l,\n           length : Js.readonly_prop int,\n           localeCompare : Js.t 'c => Js.meth float as 'm,\n           replace : Js.t Js.regExp => Js.t 'c => Js.meth (Js.t 'c) as 'n,\n           replace_string : Js.t 'c => Js.t 'c => Js.meth (Js.t 'c) as 'o,\n           search : Js.t Js.regExp => Js.meth int,\n           slice : int => int => Js.meth (Js.t 'c) as 'p,\n           slice_end : int => Js.meth (Js.t 'c) as 'q,\n           split : Js.t 'c => Js.meth (Js.t Js.string_array) as 'r,\n           split_limited : Js.t 'c => int => Js.meth (Js.t Js.string_array)\n                           as 's,\n           split_regExp : Js.t Js.regExp => Js.meth (Js.t Js.string_array),\n           split_regExpLimited : Js.t Js.regExp =>\n                                 int => Js.meth (Js.t Js.string_array),\n           substring : int => int => Js.meth (Js.t 'c) as 't,\n           substring_toEnd : int => Js.meth (Js.t 'c) as 'u,\n           toLocaleLowerCase : Js.meth (Js.t 'c) as 'v,\n           toLocaleUpperCase : Js.meth (Js.t 'c) as 'w,\n           toLowerCase : Js.meth (Js.t 'c) as 'x,\n           toString : Js.meth (Js.t 'c) as 'y,\n           toUpperCase : Js.meth (Js.t 'c) as 'z,\n           trim : Js.meth (Js.t 'c) as 'a1,\n           valueOf : Js.meth (Js.t 'c) as 'b1 >\n         as 'c =>\n         Js.meth\n         (Js.t\n          < _match : Js.t Js.regExp =>\n                     Js.meth (Js.opt (Js.t Js.match_result_handle)),\n            charAt : 'd, charCodeAt : int => Js.meth float, concat : 'e,\n            concat_2 : 'f, concat_3 : 'g, concat_4 : 'h, indexOf : 'i,\n            indexOf_from : 'j, lastIndexOf : 'k, lastIndexOf_from : 'l,\n            length : Js.readonly_prop int, localeCompare : 'm, replace : 'n,\n            replace_string : 'o, search : Js.t Js.regExp => Js.meth int,\n            slice : 'p, slice_end : 'q, split : 'r, split_limited : 's,\n            split_regExp : Js.t Js.regExp => Js.meth (Js.t Js.string_array),\n            split_regExpLimited : Js.t Js.regExp =>\n                                  int => Js.meth (Js.t Js.string_array),\n            substring : 't, substring_toEnd : 'u, toLocaleLowerCase : 'v,\n            toLocaleUpperCase : 'w, toLowerCase : 'x, toString : 'y,\n            toUpperCase : 'z, trim : 'a1, valueOf : 'b1 >),\n  length : Js.gen_prop < get : int, set : int => unit >,\n  map : Js.meth_callback unit int => int => Js.t 'a => int =>\n        Js.meth (Js.t 'a),\n  pop : Js.meth (Js.optdef int), push : int => Js.meth int,\n  push_2 : int => int => Js.meth int,\n  push_3 : int => int => int => Js.meth int,\n  push_4 : int => int => int => int => Js.meth int,\n  reduce : Js.meth_callback unit int => int => int => Js.t 'a => int =>\n           Js.meth int,\n  reduceRight : Js.meth_callback unit int => int => int => Js.t 'a => int =>\n                Js.meth int,\n  reduceRight_init : 'b.\n                       Js.meth_callback\n                       unit 'b => int => int => Js.t 'a => 'b =>\n                       'b => Js.meth 'b,\n  reduce_init : 'b.\n                  Js.meth_callback unit 'b => int => int => Js.t 'a => 'b =>\n                  'b => Js.meth 'b,\n  reverse : Js.meth (Js.t 'a), shift : Js.meth (Js.optdef int),\n  slice : int => int => Js.meth (Js.t 'a),\n  slice_end : int => Js.meth (Js.t 'a),\n  some : Js.meth_callback unit int => int => Js.t 'a => Js.t bool =>\n         Js.meth (Js.t bool),\n  sort : Js.meth_callback unit int => int => float => Js.meth (Js.t 'a),\n  sort_asStrings : Js.meth (Js.t 'a),\n  splice : int => int => Js.meth (Js.t 'a),\n  splice_1 : int => int => int => Js.meth (Js.t 'a),\n  splice_2 : int => int => int => int => Js.meth (Js.t 'a),\n  splice_3 : int => int => int => int => int => Js.meth (Js.t 'a),\n  splice_4 : int => int => int => int => int => int => Js.meth (Js.t 'a),\n  toLocaleString : Js.meth\n                   (Js.t\n                    < _match : Js.t Js.regExp =>\n                               Js.meth (Js.opt (Js.t Js.match_result_handle)),\n                      charAt : 'd, charCodeAt : int => Js.meth float,\n                      concat : 'e, concat_2 : 'f, concat_3 : 'g,\n                      concat_4 : 'h, indexOf : 'i, indexOf_from : 'j,\n                      lastIndexOf : 'k, lastIndexOf_from : 'l,\n                      length : Js.readonly_prop int, localeCompare : 'm,\n                      replace : 'n, replace_string : 'o,\n                      search : Js.t Js.regExp => Js.meth int, slice : 'p,\n                      slice_end : 'q, split : 'r, split_limited : 's,\n                      split_regExp : Js.t Js.regExp =>\n                                     Js.meth (Js.t Js.string_array),\n                      split_regExpLimited : Js.t Js.regExp =>\n                                            int =>\n                                            Js.meth (Js.t Js.string_array),\n                      substring : 't, substring_toEnd : 'u,\n                      toLocaleLowerCase : 'v, toLocaleUpperCase : 'w,\n                      toLowerCase : 'x, toString : 'y, toUpperCase : 'z,\n                      trim : 'a1, valueOf : 'b1 >),\n  toString : Js.meth\n             (Js.t\n              < _match : Js.t Js.regExp =>\n                         Js.meth (Js.opt (Js.t Js.match_result_handle)),\n                charAt : 'd, charCodeAt : int => Js.meth float, concat : 'e,\n                concat_2 : 'f, concat_3 : 'g, concat_4 : 'h, indexOf : 'i,\n                indexOf_from : 'j, lastIndexOf : 'k, lastIndexOf_from : 'l,\n                length : Js.readonly_prop int, localeCompare : 'm,\n                replace : 'n, replace_string : 'o,\n                search : Js.t Js.regExp => Js.meth int, slice : 'p,\n                slice_end : 'q, split : 'r, split_limited : 's,\n                split_regExp : Js.t Js.regExp =>\n                               Js.meth (Js.t Js.string_array),\n                split_regExpLimited : Js.t Js.regExp =>\n                                      int => Js.meth (Js.t Js.string_array),\n                substring : 't, substring_toEnd : 'u, toLocaleLowerCase : 'v,\n                toLocaleUpperCase : 'w, toLowerCase : 'x, toString : 'y,\n                toUpperCase : 'z, trim : 'a1, valueOf : 'b1 >),\n  unshift : int => Js.meth int, unshift_2 : int => int => Js.meth int,\n  unshift_3 : int => int => int => Js.meth int,\n  unshift_4 : int => int => int => int => Js.meth int >\nas 'a => '_c1",
      "tail": "position"
    },
    {
      "start": { "line": 152, "col": 21 },
      "end": { "line": 169, "col": 5 },
      "type":
        "'_a =>\nJs.t\n< concat : Js.t 'c => Js.meth (Js.t 'c),\n  every : Js.meth_callback unit int => int => Js.t 'c => Js.t bool =>\n          Js.meth (Js.t bool),\n  filter : Js.meth_callback unit int => int => Js.t 'c => Js.t bool =>\n           Js.meth (Js.t 'c),\n  forEach : Js.meth_callback unit int => int => Js.t 'c => unit =>\n            Js.meth unit,\n  join : Js.t\n         < _match : Js.t Js.regExp =>\n                    Js.meth (Js.opt (Js.t Js.match_result_handle)),\n           charAt : int => Js.meth (Js.t 'd),\n           charCodeAt : int => Js.meth float,\n           concat : Js.t 'd => Js.meth (Js.t 'd),\n           concat_2 : Js.t 'd => Js.t 'd => Js.meth (Js.t 'd),\n           concat_3 : Js.t 'd => Js.t 'd => Js.t 'd => Js.meth (Js.t 'd),\n           concat_4 : Js.t 'd =>\n                      Js.t 'd => Js.t 'd => Js.t 'd => Js.meth (Js.t 'd),\n           indexOf : Js.t 'd => Js.meth int,\n           indexOf_from : Js.t 'd => int => Js.meth int,\n           lastIndexOf : Js.t 'd => Js.meth int,\n           lastIndexOf_from : Js.t 'd => int => Js.meth int,\n           length : Js.readonly_prop int,\n           localeCompare : Js.t 'd => Js.meth float,\n           replace : Js.t Js.regExp => Js.t 'd => Js.meth (Js.t 'd),\n           replace_string : Js.t 'd => Js.t 'd => Js.meth (Js.t 'd),\n           search : Js.t Js.regExp => Js.meth int,\n           slice : int => int => Js.meth (Js.t 'd),\n           slice_end : int => Js.meth (Js.t 'd),\n           split : Js.t 'd => Js.meth (Js.t Js.string_array),\n           split_limited : Js.t 'd => int => Js.meth (Js.t Js.string_array),\n           split_regExp : Js.t Js.regExp => Js.meth (Js.t Js.string_array),\n           split_regExpLimited : Js.t Js.regExp =>\n                                 int => Js.meth (Js.t Js.string_array),\n           substring : int => int => Js.meth (Js.t 'd),\n           substring_toEnd : int => Js.meth (Js.t 'd),\n           toLocaleLowerCase : Js.meth (Js.t 'd),\n           toLocaleUpperCase : Js.meth (Js.t 'd),\n           toLowerCase : Js.meth (Js.t 'd), toString : Js.meth (Js.t 'd),\n           toUpperCase : Js.meth (Js.t 'd), trim : Js.meth (Js.t 'd),\n           valueOf : Js.meth (Js.t 'd) >\n         as 'd => Js.meth (Js.t 'd),\n  length : Js.gen_prop < get : int, set : int => unit >,\n  map : Js.meth_callback unit int => int => Js.t 'c => int =>\n        Js.meth (Js.t 'c),\n  pop : Js.meth (Js.optdef int), push : int => Js.meth int,\n  push_2 : int => int => Js.meth int,\n  push_3 : int => int => int => Js.meth int,\n  push_4 : int => int => int => int => Js.meth int,\n  reduce : Js.meth_callback unit int => int => int => Js.t 'c => int =>\n           Js.meth int,\n  reduceRight : Js.meth_callback unit int => int => int => Js.t 'c => int =>\n                Js.meth int,\n  reduceRight_init : 'b.\n                       Js.meth_callback\n                       unit 'b => int => int => Js.t 'c => 'b =>\n                       'b => Js.meth 'b,\n  reduce_init : 'b.\n                  Js.meth_callback unit 'b => int => int => Js.t 'c => 'b =>\n                  'b => Js.meth 'b,\n  reverse : Js.meth (Js.t 'c), shift : Js.meth (Js.optdef int),\n  slice : int => int => Js.meth (Js.t 'c),\n  slice_end : int => Js.meth (Js.t 'c),\n  some : Js.meth_callback unit int => int => Js.t 'c => Js.t bool =>\n         Js.meth (Js.t bool),\n  sort : Js.meth_callback unit int => int => float => Js.meth (Js.t 'c),\n  sort_asStrings : Js.meth (Js.t 'c),\n  splice : int => int => Js.meth (Js.t 'c),\n  splice_1 : int => int => int => Js.meth (Js.t 'c),\n  splice_2 : int => int => int => int => Js.meth (Js.t 'c),\n  splice_3 : int => int => int => int => int => Js.meth (Js.t 'c),\n  splice_4 : int => int => int => int => int => int => Js.meth (Js.t 'c),\n  toLocaleString : Js.meth (Js.t 'd), toString : Js.meth (Js.t 'd),\n  unshift : int => Js.meth int, unshift_2 : int => int => Js.meth int,\n  unshift_3 : int => int => int => Js.meth int,\n  unshift_4 : int => int => int => int => Js.meth int >\nas 'c => '_e",
      "tail": "no"
    },
    {
      "start": { "line": 151, "col": 2 },
      "end": { "line": 170, "col": 3 },
      "type":
        "Js.meth_callback\n'_a\n '_c =>\n Js.t\n < concat : Js.t 'd => Js.meth (Js.t 'd),\n   every : Js.meth_callback unit int => int => Js.t 'd => Js.t bool =>\n           Js.meth (Js.t bool),\n   filter : Js.meth_callback unit int => int => Js.t 'd => Js.t bool =>\n            Js.meth (Js.t 'd),\n   forEach : Js.meth_callback unit int => int => Js.t 'd => unit =>\n             Js.meth unit,\n   join : Js.t\n          < _match : Js.t Js.regExp =>\n                     Js.meth (Js.opt (Js.t Js.match_result_handle)),\n            charAt : int => Js.meth (Js.t 'e),\n            charCodeAt : int => Js.meth float,\n            concat : Js.t 'e => Js.meth (Js.t 'e),\n            concat_2 : Js.t 'e => Js.t 'e => Js.meth (Js.t 'e),\n            concat_3 : Js.t 'e => Js.t 'e => Js.t 'e => Js.meth (Js.t 'e),\n            concat_4 : Js.t 'e =>\n                       Js.t 'e => Js.t 'e => Js.t 'e => Js.meth (Js.t 'e),\n            indexOf : Js.t 'e => Js.meth int,\n            indexOf_from : Js.t 'e => int => Js.meth int,\n            lastIndexOf : Js.t 'e => Js.meth int,\n            lastIndexOf_from : Js.t 'e => int => Js.meth int,\n            length : Js.readonly_prop int,\n            localeCompare : Js.t 'e => Js.meth float,\n            replace : Js.t Js.regExp => Js.t 'e => Js.meth (Js.t 'e),\n            replace_string : Js.t 'e => Js.t 'e => Js.meth (Js.t 'e),\n            search : Js.t Js.regExp => Js.meth int,\n            slice : int => int => Js.meth (Js.t 'e),\n            slice_end : int => Js.meth (Js.t 'e),\n            split : Js.t 'e => Js.meth (Js.t Js.string_array),\n            split_limited : Js.t 'e => int => Js.meth (Js.t Js.string_array),\n            split_regExp : Js.t Js.regExp => Js.meth (Js.t Js.string_array),\n            split_regExpLimited : Js.t Js.regExp =>\n                                  int => Js.meth (Js.t Js.string_array),\n            substring : int => int => Js.meth (Js.t 'e),\n            substring_toEnd : int => Js.meth (Js.t 'e),\n            toLocaleLowerCase : Js.meth (Js.t 'e),\n            toLocaleUpperCase : Js.meth (Js.t 'e),\n            toLowerCase : Js.meth (Js.t 'e), toString : Js.meth (Js.t 'e),\n            toUpperCase : Js.meth (Js.t 'e), trim : Js.meth (Js.t 'e),\n            valueOf : Js.meth (Js.t 'e) >\n          as 'e => Js.meth (Js.t 'e),\n   length : Js.gen_prop < get : int, set : int => unit >,\n   map : Js.meth_callback unit int => int => Js.t 'd => int =>\n         Js.meth (Js.t 'd),\n   pop : Js.meth (Js.optdef int), push : int => Js.meth int,\n   push_2 : int => int => Js.meth int,\n   push_3 : int => int => int => Js.meth int,\n   push_4 : int => int => int => int => Js.meth int,\n   reduce : Js.meth_callback unit int => int => int => Js.t 'd => int =>\n            Js.meth int,\n   reduceRight : Js.meth_callback unit int => int => int => Js.t 'd => int =>\n                 Js.meth int,\n   reduceRight_init : 'b.\n                        Js.meth_callback\n                        unit 'b => int => int => Js.t 'd => 'b =>\n                        'b => Js.meth 'b,\n   reduce_init : 'b.\n                   Js.meth_callback unit 'b => int => int => Js.t 'd => 'b =>\n                   'b => Js.meth 'b,\n   reverse : Js.meth (Js.t 'd), shift : Js.meth (Js.optdef int),\n   slice : int => int => Js.meth (Js.t 'd),\n   slice_end : int => Js.meth (Js.t 'd),\n   some : Js.meth_callback unit int => int => Js.t 'd => Js.t bool =>\n          Js.meth (Js.t bool),\n   sort : Js.meth_callback unit int => int => float => Js.meth (Js.t 'd),\n   sort_asStrings : Js.meth (Js.t 'd),\n   splice : int => int => Js.meth (Js.t 'd),\n   splice_1 : int => int => int => Js.meth (Js.t 'd),\n   splice_2 : int => int => int => int => Js.meth (Js.t 'd),\n   splice_3 : int => int => int => int => int => Js.meth (Js.t 'd),\n   splice_4 : int => int => int => int => int => int => Js.meth (Js.t 'd),\n   toLocaleString : Js.meth (Js.t 'e), toString : Js.meth (Js.t 'e),\n   unshift : int => Js.meth int, unshift_2 : int => int => Js.meth int,\n   unshift_3 : int => int => int => Js.meth int,\n   unshift_4 : int => int => int => int => Js.meth int >\n as 'd => '_f",
      "tail": "no"
    },
    {
      "start": { "line": 149, "col": 0 },
      "end": { "line": 170, "col": 3 },
      "type": "type unit = ()",
      "tail": "no"
    }
  ]
]
# 0.29 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.29 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.29 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.29 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.29 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.29 frontend - output
[ "return", true ]
# 0.29 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 179, "col": 12 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.29 track_definition - from_string
looking for the source of 'AtomReasonLocate' (prioritizing .ml files)
# 0.29 track_definition - lookup
lookup in value namespace
# 0.29 track_definition - lookup
lookup in constructor namespace
# 0.29 track_definition - lookup
lookup in module namespace
# 0.29 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.AtomReasonLocate'
# 0.29 typedtrie - ignored node
expression
# 0.29 typedtrie - ignored node
expression
# 0.29 typedtrie - ignored node
expression
# 0.29 typedtrie - ignored node
expression
# 0.29 typedtrie - ignored node
expression
# 0.29 typedtrie - ignored node
expression
# 0.29 typedtrie - ignored node
expression
# 0.29 typedtrie - ignored node
open_description
# 0.29 track_definition - locate
resolves to AtomReason.AtomReasonLocate
# 0.29 track_definition - Fallback.setopt
None
# 0.29 track_definition - from_path '%s'
AtomReason.AtomReasonLocate
# 0.29 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.29 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.29 track_definition - locate
alias of M_AtomReason__AtomReasonLocate
# 0.29 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 80, characters 0-56
# 0.29 track_definition - from_path '%s'
M_AtomReason__AtomReasonLocate
# 0.29 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__AtomReasonLocate.cmt
# 0.29 track_definition - find_source
failed to find "M_AtomReason__AtomReasonLocate" in source path (fallback = true)
# 0.29 track_definition - find_source
(for reference: fname = "M_AtomReason__AtomReasonLocate")
# 0.29 track_definition - find_source
looking in '/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules'
# 0.29 track_definition - find_source
multiple files named AtomReasonLocate exist in the source path...
# 0.29 track_definition - find_source
... trying to use source digest to find the right one
# 0.29 track_definition - find_source
Source digest: 2223b4da4c5beecafb879ea459d4c369
# 0.29 track_definition - find_source
  /Users/chenglou/Github/Reason/editorSupport/AtomReason/src/AtomReasonLocate.re (2223b4da4c5beecafb879ea459d4c369)
# 0.29 track_definition - Locate
/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/AtomReasonLocate.re
# 0.29 frontend - output
[
  "return",
  {
    "file":
      "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/AtomReasonLocate.re",
    "pos": { "line": 1, "col": 0 }
  }
]
# 0.30 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/AtomReasonLocate.re"
  ]
}
# 0.30 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.30 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* This is lifted from nuclide source, from the helper function of the same name. */\nlet goToLocation' = Js.Unsafe.js_expr {|\n  function() {\n    function goToLocation(file, line, column, center) {\n      center = center == null ? true : center;\n      return atom.workspace.open(file, {\n        initialLine: line,\n        initialColumn: column,\n        searchAllPanes: true,\n      })\n      .then(function(editor) {\n        if (center) {\n          return editor.scrollToBufferPosition([line, column], {center: true});\n        }\n        return editor;\n      });\n    }\n\n    return function(res) {\n      // TODO: rewrite this in reason.\n      if (typeof res === \"string\") {\n        console.error(res);\n        return;\n      }\n      goToLocation(res.file, res.pos.line - 1, res.pos.col);\n    }\n  }()\n|};\n\nlet goToLocation result => Js.Unsafe.fun_call goToLocation' [|result|];\n\nlet getMerlinLocation editor::editor range::range => {\n  let path = AtomReasonCommon.path editor;\n  let extension = AtomReasonCommon.isInterface (Some path) ? \"mli\" : \"ml\";\n  let text = Atom.Buffer.getText editor;\n  let (startPosition, _) = range;\n  SuperMerlin.locate\n    path::path\n    text::text\n    extension::extension\n    position::startPosition\n    (fun successResult => goToLocation successResult)\n    /* TODO: use this */\n    (fun _ => ())\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/AtomReasonLocate.re"
  ]
}
# 0.30 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.30 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.30 frontend - output
[ "return", true ]
# 0.30 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/AtomReasonLocate.re"
  ]
}
# 0.30 frontend - output
[ "return", [] ]
# 0.30 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/AtomReasonLocate.re"
  ]
}
# 0.30 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.30 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/* This is lifted from nuclide source, from the helper function of the same name. */\nlet goToLocation' = Js.Unsafe.js_expr {|\n  function() {\n    function goToLocation(file, line, column, center) {\n      center = center == null ? true : center;\n      return atom.workspace.open(file, {\n        initialLine: line,\n        initialColumn: column,\n        searchAllPanes: true,\n      })\n      .then(function(editor) {\n        if (center) {\n          return editor.scrollToBufferPosition([line, column], {center: true});\n        }\n        return editor;\n      });\n    }\n\n    return function(res) {\n      // TODO: rewrite this in reason.\n      if (typeof res === \"string\") {\n        console.error(res);\n        return;\n      }\n      goToLocation(res.file, res.pos.line - 1, res.pos.col);\n    }\n  }()\n|};\n\nlet goToLocation result => Js.Unsafe.fun_call goToLocation' [|result|];\n\nlet getMerlinLocation editor::editor range::range => {\n  let path = AtomReasonCommon.path editor;\n  let extension = AtomReasonCommon.isInterface (Some path) ? \"mli\" : \"ml\";\n  let text = Atom.Buffer.getText editor;\n  let (startPosition, _) = range;\n  SuperMerlin.locate\n    path::path\n    text::text\n    extension::extension\n    position::startPosition\n    (fun successResult => goToLocation successResult)\n    /* TODO: use this */\n    (fun _ => ())\n};\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/AtomReasonLocate.re"
  ]
}
# 0.30 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.30 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.30 frontend - output
[ "return", true ]
# 0.30 frontend - input
{
  "query": [ "errors" ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/AtomReasonLocate.re"
  ]
}
# 0.30 frontend - output
[ "return", [] ]
# 0.30 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.30 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.30 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.30 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.30 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.30 frontend - output
[ "return", true ]
# 0.30 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 161, "col": 24 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.30 frontend - output
[
  "return",
  [
    {
      "start": { "line": 161, "col": 12 },
      "end": { "line": 161, "col": 35 },
      "type":
        "path::string =>\ntext::string => position::(int, int) => ('a => 'b) => ('c => 'd) => 'e",
      "tail": "no"
    },
    {
      "start": { "line": 161, "col": 12 },
      "end": { "line": 161, "col": 35 },
      "type":
        "path::string =>\ntext::string =>\nposition::(int, int) => ('_a => unit) => (string => unit) => unit",
      "tail": "no"
    },
    {
      "start": { "line": 161, "col": 12 },
      "end": { "line": 166, "col": 65 },
      "type": "unit",
      "tail": "call"
    },
    {
      "start": { "line": 160, "col": 22 },
      "end": { "line": 166, "col": 65 },
      "type": "(Js.t Js.js_string => unit) => unit",
      "tail": "position"
    },
    {
      "start": { "line": 159, "col": 39 },
      "end": { "line": 167, "col": 9 },
      "type":
        "(Js.optdef '_a => unit) => (Js.t Js.js_string => unit) => unit",
      "tail": "no"
    },
    {
      "start": { "line": 159, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "call"
    },
    {
      "start": { "line": 158, "col": 8 },
      "end": { "line": 167, "col": 9 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 31 },
      "end": { "line": 168, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 153, "col": 19 },
      "end": { "line": 168, "col": 7 },
      "type": "Js.t (Js.js_array int) => '_a",
      "tail": "position"
    },
    {
      "start": { "line": 152, "col": 21 },
      "end": { "line": 169, "col": 5 },
      "type": "'_a => Js.t (Js.js_array int) => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 151, "col": 2 },
      "end": { "line": 170, "col": 3 },
      "type": "Js.meth_callback '_a '_b => Js.t (Js.js_array int) => '_c",
      "tail": "no"
    },
    {
      "start": { "line": 149, "col": 0 },
      "end": { "line": 170, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]
# 0.30 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.31 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.31 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.31 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.31 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.31 frontend - output
[ "return", true ]
# 0.31 frontend - input
{
  "query": [ "locate", "", "ml", "at", { "line": 195, "col": 8 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.31 track_definition - from_string
looking for the source of 'SuperMerlin' (prioritizing .ml files)
# 0.31 track_definition - lookup
lookup in value namespace
# 0.31 track_definition - lookup
lookup in constructor namespace
# 0.31 track_definition - lookup
lookup in module namespace
# 0.31 track_definition - locate
present in the environment, but ghost lock.
walking up the typedtree looking for 'AtomReason.SuperMerlin'
# 0.31 typedtrie - ignored node
expression
# 0.31 typedtrie - ignored node
expression
# 0.31 typedtrie - ignored node
expression
# 0.31 typedtrie - ignored node
expression
# 0.31 typedtrie - ignored node
expression
# 0.31 typedtrie - ignored node
expression
# 0.31 typedtrie - ignored node
expression
# 0.31 typedtrie - ignored node
open_description
# 0.31 track_definition - locate
resolves to AtomReason.SuperMerlin
# 0.31 track_definition - Fallback.setopt
None
# 0.31 track_definition - from_path '%s'
AtomReason.SuperMerlin
# 0.31 track_definition - browse_cmts
inspecting /Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.31 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.cmt
# 0.31 track_definition - locate
alias of M_AtomReason__SuperMerlin
# 0.31 track_definition - Fallback.set
File "/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/atomReason.ml", line 62, characters 0-46
# 0.31 track_definition - from_path '%s'
M_AtomReason__SuperMerlin
# 0.31 track_definition - File_switching.move_to
/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules/m_AtomReason__SuperMerlin.cmt
# 0.31 track_definition - find_source
failed to find "M_AtomReason__SuperMerlin" in source path (fallback = true)
# 0.31 track_definition - find_source
(for reference: fname = "M_AtomReason__SuperMerlin")
# 0.31 track_definition - find_source
looking in '/Users/chenglou/Github/Reason/editorSupport/AtomReason/output_byte_debug/AtomReason/privateInnerModules'
# 0.31 track_definition - find_source
multiple files named SuperMerlin exist in the source path...
# 0.31 track_definition - find_source
... trying to use source digest to find the right one
# 0.31 track_definition - find_source
Source digest: ecd1ffd885e6e551e7df8275ac960d85
# 0.31 track_definition - find_source
  /Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re (ecd1ffd885e6e551e7df8275ac960d85)
# 0.31 track_definition - Locate
/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re
# 0.31 frontend - output
[
  "return",
  {
    "file":
      "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/SuperMerlin.re",
    "pos": { "line": 1, "col": 0 }
  }
]
# 0.31 frontend - input
{
  "query": [ "protocol", "version", 2 ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.31 frontend - output
[
  "return",
  {
    "selected": 2,
    "latest": 3,
    "merlin": "The Merlin toolkit version 2.3.1, for Ocaml 4.02.3"
  }
]
# 0.31 frontend - input
{
  "query": [
    "tell", "start", "end",
    "/*\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\n/*\n * Ideally, most of AtomReason would be in pure Reason, and the parts that need to\n * to convert to/from JS would be at the edges (Index.re, and SuperMerlin.re).\n */\nopen AtomReasonCommon;\n\n/* These exports will be visible to main.js, under AtomReason */\nexport\n  \"getDiagnostics\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => Atom.Promise.createFakePromise (\n        fun resolve reject =>\n          AtomReasonDiagnostics.getMerlinDiagnostics\n            /* editor::(Atom.Editor.fromJs jsEditor) */\n            editor::(Atom.Editor.fromJs jsEditor)\n            (\n              fun successResult => resolve (\n                Js.array (Array.map NuclideJs.Diagnostic.Message.toJs successResult)\n              )\n            )\n            /* TODO: this has never been used. */\n            reject\n      )\n    )\n  );\n\nexport\n  \"getEntireFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getEntireFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (NuclideJs.FileFormat.toJs successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getPartialFormatting\"\n  (\n    Js.wrap_callback (\n      fun jsEditor jsRange jsNotifySuccess jsNotifyInvalid jsNotifyInfo => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let range = Atom.Range.fromJs jsRange;\n        let notifySuccess msg => Js.Unsafe.fun_call jsNotifySuccess [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInvalid msg => Js.Unsafe.fun_call jsNotifyInvalid [|Js.Unsafe.inject (Js.string msg)|];\n        let notifyInfo msg => Js.Unsafe.fun_call jsNotifyInfo [|Js.Unsafe.inject (Js.string msg)|];\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            AtomReasonFormat.getPartialFormatting\n              editor\n              range\n              notifySuccess\n              notifyInvalid\n              notifyInfo\n              (fun successResult => resolve (Js.string successResult))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsAutocompleteSuggestions\"\n  (\n    Js.wrap_callback (\n      fun request => {\n        let request = NuclideJs.AutocompleteProviderRequest.fromJs request;\n        let editor = request.Nuclide.AutocompleteProviderRequest.editor;\n        let prefix = request.prefix;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer editor);\n        let (line, col) as position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        /**\n         * The default prefix at something like `Printf.[cursor]` is just the dot. Compute\n         * `linePrefix` so that ocamlmerlin gets more context. Compute `replacementPrefix`\n         * to make sure that the existing dot doesn't get clobbered when autocompleting.\n         */\n        let linePrefix = String.sub (Atom.Editor.lineTextForBufferRow editor line) 0 col;\n        let linePrefix =\n          String.length linePrefix === 0 ?\n            linePrefix :\n            {\n              let regex = Js.Unsafe.js_expr {|/([ |\\t\\[\\](){}<>,+*\\/-])/|};\n              let lst = StringUtils.split linePrefix by::regex;\n              let len = List.length lst;\n              len > 0 ? List.nth lst (len - 1) : linePrefix\n            };\n        if (String.length (String.trim linePrefix) === 0 || String.length (String.trim prefix) === 0) {\n          Atom.Promise.createFakePromise (fun resolve reject => resolve (Js.array [||]))\n        } else {\n          let replacementPrefix =\n            if (String.contains prefix '.' && String.index prefix '.' === 0) {\n              String.sub prefix 1 (String.length prefix - 1)\n            } else {\n              prefix\n            };\n          Atom.Promise.createFakePromise (\n            fun resolve reject =>\n              SuperMerlin.getAutoCompleteSuggestions\n                path::(path editor)\n                text::text\n                position::position\n                prefix::linePrefix\n                (\n                  fun result => {\n                    let resultRe =\n                      Js.Unsafe.get result \"entries\" |>\n                        Js.to_array |>\n                        Array.to_list |>\n                        List.map MerlinServiceConvert.jsMerlinCompletionEntryToMerlinEntry;\n                    resultRe |>\n                      List.map (MerlinServiceConvert.merlinCompletionEntryToNuclide replacementPrefix) |>\n                      List.map NuclideJs.Autocomplete.entryToJs |>\n                      Array.of_list |>\n                      Js.array |>\n                      resolve\n                  }\n                )\n                /* TODO: NOT ALWAYS STRING MIGHT BE ERROR FRMATTER */\n                reject\n          )\n        }\n      }\n    )\n  );\n\nexport\n  \"getNuclideJsTypeHint\"\n  (\n    Js.wrap_callback (\n      fun jsEditor position => {\n        /* TODO: make selection work in conjunction with expansion */\n        /* TODO: currently gets the first type hint. The rest are the types of the expanded scope. Will use\n           them one day. */\n        let position = Atom.Point.fromJs position;\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        Atom.Promise.createFakePromise (\n          fun resolve reject =>\n            SuperMerlin.getTypeHint\n              path::(path jsEditor)\n              text::text\n              position::position\n              (fun result => resolve (MerlinServiceConvert.jsMerlinTypeHintEntryToNuclide result))\n              (fun rejectedMsg => reject (Js.string rejectedMsg))\n        )\n      }\n    )\n  );\n\nexport\n  \"getLocation\"\n  (\n    Js.wrap_callback (\n      fun jsEditor _ range => {\n        let callback = Js.wrap_callback (\n          fun () =>\n            AtomReasonLocate.getMerlinLocation\n              editor::(Atom.Editor.fromJs jsEditor) range::(Atom.Range.fromJs range)\n        );\n        Js.Unsafe.obj [|(\"range\", Js.Unsafe.inject range), (\"callback\", Js.Unsafe.inject callback)|]\n      }\n    )\n  );\n\nexport\n  \"selectOccurrences\"\n  (\n    Js.wrap_callback (\n      fun jsEditor => {\n        let editor = Atom.Editor.fromJs jsEditor;\n        let position = Atom.Cursor.getBufferPosition (List.hd (Atom.Editor.getCursors editor));\n        let text = Atom.Buffer.getText (Atom.Editor.getBuffer jsEditor);\n        SuperMerlin.getOccurrences\n          path::(path jsEditor)\n          text::text\n          position::position\n          (\n            fun result =>\n              MerlinServiceConvert.jsMerlinOccurrencesToAtom result |>\n                AtomReasonOccurrences.selectOccurrences editor::editor\n          )\n          /* TODO: do something here. */\n          (fun rejectedMsg => ())\n      }\n    )\n  );\n"
  ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.31 dot_merlin - update filenames
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src" ]
# 0.31 dot_merlin - update files
[ "/Users/chenglou/Github/Reason/editorSupport/AtomReason/.merlin" ]
# 0.31 frontend - output
[ "return", true ]
# 0.31 frontend - input
{
  "query": [ "type", "enclosing", "at", { "line": 193, "col": 89 } ],
  "context": [
    "auto",
    "/Users/chenglou/Github/Reason/editorSupport/AtomReason/src/Index.re"
  ]
}
# 0.31 frontend - output
[
  "return",
  [
    {
      "start": { "line": 193, "col": 86 },
      "end": { "line": 193, "col": 92 },
      "type": "AtomReason.Atom.Editor.t",
      "tail": "no"
    },
    {
      "start": { "line": 193, "col": 62 },
      "end": { "line": 193, "col": 93 },
      "type": "list AtomReason.Atom.Cursor.t",
      "tail": "no"
    },
    {
      "start": { "line": 193, "col": 53 },
      "end": { "line": 193, "col": 94 },
      "type": "AtomReason.Atom.Cursor.t",
      "tail": "no"
    },
    {
      "start": { "line": 193, "col": 23 },
      "end": { "line": 193, "col": 94 },
      "type": "('a, 'a)",
      "tail": "no"
    },
    {
      "start": { "line": 193, "col": 8 },
      "end": { "line": 205, "col": 33 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 191, "col": 22 },
      "end": { "line": 206, "col": 7 },
      "type": "'_a",
      "tail": "position"
    },
    {
      "start": { "line": 190, "col": 21 },
      "end": { "line": 207, "col": 5 },
      "type": "AtomReason.Atom.Editor.t => '_a",
      "tail": "no"
    },
    {
      "start": { "line": 189, "col": 2 },
      "end": { "line": 208, "col": 3 },
      "type": "Js.meth_callback '_a AtomReason.Atom.Editor.t => '_b",
      "tail": "no"
    },
    {
      "start": { "line": 187, "col": 0 },
      "end": { "line": 208, "col": 3 },
      "type": "unit",
      "tail": "no"
    }
  ]
]